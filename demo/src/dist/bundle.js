/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./communication.wasm.js":
/*!*******************************!*\
  !*** ./communication.wasm.js ***!
  \*******************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n\r\nvar Module = (() => {\r\n  var _scriptName = \"file:///F:/project/WebAssembly/demo/src/communication.wasm.js\";\r\n  \r\n  return (\r\nasync function(moduleArg = {}) {\r\n  var moduleRtn;\r\n\r\n// include: shell.js\r\n// The Module object: Our interface to the outside world. We import\r\n// and export values on it. There are various ways Module can be used:\r\n// 1. Not defined. We create it here\r\n// 2. A function parameter, function(moduleArg) => Promise<Module>\r\n// 3. pre-run appended it, var Module = {}; ..generated code..\r\n// 4. External script tag defines var Module.\r\n// We need to check if Module already exists (e.g. case 3 above).\r\n// Substitution will be replaced with actual code on later stage of the build,\r\n// this way Closure Compiler will not mangle it (e.g. case 4. above).\r\n// Note that if you want to run closure, and also to use Module\r\n// after the generated code, you will need to define   var Module = {};\r\n// before the code. Then that object will be used in the code, and you\r\n// can continue to use Module afterwards as well.\r\nvar Module = moduleArg;\r\n\r\n// Set up the promise that indicates the Module is initialized\r\nvar readyPromiseResolve, readyPromiseReject;\r\nvar readyPromise = new Promise((resolve, reject) => {\r\n  readyPromiseResolve = resolve;\r\n  readyPromiseReject = reject;\r\n});\r\n[\"_memory\",\"___indirect_function_table\",\"onRuntimeInitialized\"].forEach((prop) => {\r\n  if (!Object.getOwnPropertyDescriptor(readyPromise, prop)) {\r\n    Object.defineProperty(readyPromise, prop, {\r\n      get: () => abort('You are getting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\r\n      set: () => abort('You are setting ' + prop + ' on the Promise object, instead of the instance. Use .then() to get called back with the instance, see the MODULARIZE docs in src/settings.js'),\r\n    });\r\n  }\r\n});\r\n\r\n// Determine the runtime environment we are in. You can customize this by\r\n// setting the ENVIRONMENT setting at compile time (see settings.js).\r\n\r\n// Attempt to auto-detect the environment\r\nvar ENVIRONMENT_IS_WEB = typeof window == 'object';\r\nvar ENVIRONMENT_IS_WORKER = typeof importScripts == 'function';\r\n// N.b. Electron.js environment is simultaneously a NODE-environment, but\r\n// also a web environment.\r\nvar ENVIRONMENT_IS_NODE = typeof process == 'object' && typeof process.versions == 'object' && typeof process.versions.node == 'string' && process.type != 'renderer';\r\nvar ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  // `require()` is no-op in an ESM module, use `createRequire()` to construct\r\n  // the require()` function.  This is only necessary for multi-environment\r\n  // builds, `-sENVIRONMENT=node` emits a static import declaration instead.\r\n  // TODO: Swap all `require()`'s with `import()`'s?\r\n  const { createRequire } = await Promise.resolve().then(function webpackMissingModule() { var e = new Error(\"Cannot find module 'module'\"); e.code = 'MODULE_NOT_FOUND'; throw e; });\r\n  let dirname = \"file:///F:/project/WebAssembly/demo/src/communication.wasm.js\";\r\n  if (dirname.startsWith(\"data:\")) {\r\n    dirname = '/';\r\n  }\r\n  /** @suppress{duplicate} */\r\n  var require = createRequire(dirname);\r\n\r\n}\r\n\r\n// --pre-jses are emitted after the Module integration code, so that they can\r\n// refer to Module (if they choose; they can also define Module)\r\n\r\n\r\n// Sometimes an existing Module object exists with properties\r\n// meant to overwrite the default module functionality. Here\r\n// we collect those properties and reapply _after_ we configure\r\n// the current environment's defaults to avoid having to be so\r\n// defensive during initialization.\r\nvar moduleOverrides = Object.assign({}, Module);\r\n\r\nvar arguments_ = [];\r\nvar thisProgram = './this.program';\r\nvar quit_ = (status, toThrow) => {\r\n  throw toThrow;\r\n};\r\n\r\n// `/` should be present at the end if `scriptDirectory` is not empty\r\nvar scriptDirectory = '';\r\nfunction locateFile(path) {\r\n  if (Module['locateFile']) {\r\n    return Module['locateFile'](path, scriptDirectory);\r\n  }\r\n  return scriptDirectory + path;\r\n}\r\n\r\n// Hooks that are implemented differently in different runtime environments.\r\nvar readAsync, readBinary;\r\n\r\nif (ENVIRONMENT_IS_NODE) {\r\n  if (typeof process == 'undefined' || !process.release || process.release.name !== 'node') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  var nodeVersion = process.versions.node;\r\n  var numericVersion = nodeVersion.split('.').slice(0, 3);\r\n  numericVersion = (numericVersion[0] * 10000) + (numericVersion[1] * 100) + (numericVersion[2].split('-')[0] * 1);\r\n  var minVersion = 160000;\r\n  if (numericVersion < 160000) {\r\n    throw new Error('This emscripten-generated code requires node v16.0.0 (detected v' + nodeVersion + ')');\r\n  }\r\n\r\n  // These modules will usually be used on Node.js. Load them eagerly to avoid\r\n  // the complexity of lazy-loading.\r\n  var fs = require('fs');\r\n  var nodePath = require('path');\r\n\r\n  // EXPORT_ES6 + ENVIRONMENT_IS_NODE always requires use of import.meta.url,\r\n  // since there's no way getting the current absolute path of the module when\r\n  // support for that is not available.\r\n  if (!\"file:///F:/project/WebAssembly/demo/src/communication.wasm.js\".startsWith('data:')) {\r\n    scriptDirectory = nodePath.dirname(require('url').fileURLToPath(\"file:///F:/project/WebAssembly/demo/src/communication.wasm.js\")) + '/';\r\n  }\r\n\r\n// include: node_shell_read.js\r\nreadBinary = (filename) => {\r\n  // We need to re-wrap `file://` strings to URLs. Normalizing isn't\r\n  // necessary in that case, the path should already be absolute.\r\n  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\r\n  var ret = fs.readFileSync(filename);\r\n  assert(ret.buffer);\r\n  return ret;\r\n};\r\n\r\nreadAsync = (filename, binary = true) => {\r\n  // See the comment in the `readBinary` function.\r\n  filename = isFileURI(filename) ? new URL(filename) : nodePath.normalize(filename);\r\n  return new Promise((resolve, reject) => {\r\n    fs.readFile(filename, binary ? undefined : 'utf8', (err, data) => {\r\n      if (err) reject(err);\r\n      else resolve(binary ? data.buffer : data);\r\n    });\r\n  });\r\n};\r\n// end include: node_shell_read.js\r\n  if (!Module['thisProgram'] && process.argv.length > 1) {\r\n    thisProgram = process.argv[1].replace(/\\\\/g, '/');\r\n  }\r\n\r\n  arguments_ = process.argv.slice(2);\r\n\r\n  // MODULARIZE will export the module in the proper place outside, we don't need to export here\r\n\r\n  quit_ = (status, toThrow) => {\r\n    process.exitCode = status;\r\n    throw toThrow;\r\n  };\r\n\r\n} else\r\nif (ENVIRONMENT_IS_SHELL) {\r\n\r\n  if ((typeof process == 'object' && typeof require === 'function') || typeof window == 'object' || typeof importScripts == 'function') throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n} else\r\n\r\n// Note that this includes Node.js workers when relevant (pthreads is enabled).\r\n// Node.js workers are detected as a combination of ENVIRONMENT_IS_WORKER and\r\n// ENVIRONMENT_IS_NODE.\r\nif (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {\r\n  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled\r\n    scriptDirectory = self.location.href;\r\n  } else if (typeof document != 'undefined' && document.currentScript) { // web\r\n    scriptDirectory = document.currentScript.src;\r\n  }\r\n  // When MODULARIZE, this JS may be executed later, after document.currentScript\r\n  // is gone, so we saved it, and we use it here instead of any other info.\r\n  if (_scriptName) {\r\n    scriptDirectory = _scriptName;\r\n  }\r\n  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.\r\n  // otherwise, slice off the final part of the url to find the script directory.\r\n  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,\r\n  // and scriptDirectory will correctly be replaced with an empty string.\r\n  // If scriptDirectory contains a query (starting with ?) or a fragment (starting with #),\r\n  // they are removed because they could contain a slash.\r\n  if (scriptDirectory.startsWith('blob:')) {\r\n    scriptDirectory = '';\r\n  } else {\r\n    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.replace(/[?#].*/, '').lastIndexOf('/')+1);\r\n  }\r\n\r\n  if (!(typeof window == 'object' || typeof importScripts == 'function')) throw new Error('not compiled for this environment (did you build to HTML and try to run it not on the web, or set ENVIRONMENT to something - like node - and run it someplace else - like on the web?)');\r\n\r\n  {\r\n// include: web_or_worker_shell_read.js\r\nif (ENVIRONMENT_IS_WORKER) {\r\n    readBinary = (url) => {\r\n      var xhr = new XMLHttpRequest();\r\n      xhr.open('GET', url, false);\r\n      xhr.responseType = 'arraybuffer';\r\n      xhr.send(null);\r\n      return new Uint8Array(/** @type{!ArrayBuffer} */(xhr.response));\r\n    };\r\n  }\r\n\r\n  readAsync = (url) => {\r\n    // Fetch has some additional restrictions over XHR, like it can't be used on a file:// url.\r\n    // See https://github.com/github/fetch/pull/92#issuecomment-140665932\r\n    // Cordova or Electron apps are typically loaded from a file:// url.\r\n    // So use XHR on webview if URL is a file URL.\r\n    if (isFileURI(url)) {\r\n      return new Promise((resolve, reject) => {\r\n        var xhr = new XMLHttpRequest();\r\n        xhr.open('GET', url, true);\r\n        xhr.responseType = 'arraybuffer';\r\n        xhr.onload = () => {\r\n          if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0\r\n            resolve(xhr.response);\r\n            return;\r\n          }\r\n          reject(xhr.status);\r\n        };\r\n        xhr.onerror = reject;\r\n        xhr.send(null);\r\n      });\r\n    }\r\n    return fetch(url, { credentials: 'same-origin' })\r\n      .then((response) => {\r\n        if (response.ok) {\r\n          return response.arrayBuffer();\r\n        }\r\n        return Promise.reject(new Error(response.status + ' : ' + response.url));\r\n      })\r\n  };\r\n// end include: web_or_worker_shell_read.js\r\n  }\r\n} else\r\n{\r\n  throw new Error('environment detection error');\r\n}\r\n\r\nvar out = Module['print'] || console.log.bind(console);\r\nvar err = Module['printErr'] || console.error.bind(console);\r\n\r\n// Merge back in the overrides\r\nObject.assign(Module, moduleOverrides);\r\n// Free the object hierarchy contained in the overrides, this lets the GC\r\n// reclaim data used.\r\nmoduleOverrides = null;\r\ncheckIncomingModuleAPI();\r\n\r\n// Emit code to handle expected values on the Module object. This applies Module.x\r\n// to the proper local x. This has two benefits: first, we only emit it if it is\r\n// expected to arrive, and second, by using a local everywhere else that can be\r\n// minified.\r\n\r\nif (Module['arguments']) arguments_ = Module['arguments'];legacyModuleProp('arguments', 'arguments_');\r\n\r\nif (Module['thisProgram']) thisProgram = Module['thisProgram'];legacyModuleProp('thisProgram', 'thisProgram');\r\n\r\n// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message\r\n// Assertions on removed incoming Module JS APIs.\r\nassert(typeof Module['memoryInitializerPrefixURL'] == 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['pthreadMainPrefixURL'] == 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['cdInitializerPrefixURL'] == 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['filePackagePrefixURL'] == 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');\r\nassert(typeof Module['read'] == 'undefined', 'Module.read option was removed');\r\nassert(typeof Module['readAsync'] == 'undefined', 'Module.readAsync option was removed (modify readAsync in JS)');\r\nassert(typeof Module['readBinary'] == 'undefined', 'Module.readBinary option was removed (modify readBinary in JS)');\r\nassert(typeof Module['setWindowTitle'] == 'undefined', 'Module.setWindowTitle option was removed (modify emscripten_set_window_title in JS)');\r\nassert(typeof Module['TOTAL_MEMORY'] == 'undefined', 'Module.TOTAL_MEMORY has been renamed Module.INITIAL_MEMORY');\r\nlegacyModuleProp('asm', 'wasmExports');\r\nlegacyModuleProp('readAsync', 'readAsync');\r\nlegacyModuleProp('readBinary', 'readBinary');\r\nlegacyModuleProp('setWindowTitle', 'setWindowTitle');\r\nvar IDBFS = 'IDBFS is no longer included by default; build with -lidbfs.js';\r\nvar PROXYFS = 'PROXYFS is no longer included by default; build with -lproxyfs.js';\r\nvar WORKERFS = 'WORKERFS is no longer included by default; build with -lworkerfs.js';\r\nvar FETCHFS = 'FETCHFS is no longer included by default; build with -lfetchfs.js';\r\nvar ICASEFS = 'ICASEFS is no longer included by default; build with -licasefs.js';\r\nvar JSFILEFS = 'JSFILEFS is no longer included by default; build with -ljsfilefs.js';\r\nvar OPFS = 'OPFS is no longer included by default; build with -lopfs.js';\r\n\r\nvar NODEFS = 'NODEFS is no longer included by default; build with -lnodefs.js';\r\n\r\nassert(!ENVIRONMENT_IS_SHELL, 'shell environment detected but not enabled at build time.  Add `shell` to `-sENVIRONMENT` to enable.');\r\n\r\n// end include: shell.js\r\n\r\n// include: preamble.js\r\n// === Preamble library stuff ===\r\n\r\n// Documentation for the public APIs defined in this file must be updated in:\r\n//    site/source/docs/api_reference/preamble.js.rst\r\n// A prebuilt local version of the documentation is available at:\r\n//    site/build/text/docs/api_reference/preamble.js.txt\r\n// You can also build docs locally as HTML or other formats in site/\r\n// An online HTML version (which may be of a different version of Emscripten)\r\n//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html\r\n\r\nvar wasmBinary = Module['wasmBinary'];legacyModuleProp('wasmBinary', 'wasmBinary');\r\n\r\n// include: wasm2js.js\r\n// wasm2js.js - enough of a polyfill for the WebAssembly object so that we can load\r\n// wasm2js code that way.\r\n\r\n// Emit \"var WebAssembly\" if definitely using wasm2js. Otherwise, in MAYBE_WASM2JS\r\n// mode, we can't use a \"var\" since it would prevent normal wasm from working.\r\n/** @suppress{duplicate, const} */\r\nvar\r\nWebAssembly = {\r\n  // Note that we do not use closure quoting (this['buffer'], etc.) on these\r\n  // functions, as they are just meant for internal use. In other words, this is\r\n  // not a fully general polyfill.\r\n  /** @constructor */\r\n  Memory: function(opts) {\r\n    this.buffer = new ArrayBuffer(opts['initial'] * 65536);\r\n  },\r\n\r\n  Module: function(binary) {\r\n    // TODO: use the binary and info somehow - right now the wasm2js output is embedded in\r\n    // the main JS\r\n  },\r\n\r\n  /** @constructor */\r\n  Instance: function(module, info) {\r\n    // TODO: use the module somehow - right now the wasm2js output is embedded in\r\n    // the main JS\r\n    // This will be replaced by the actual wasm2js code.\r\n    this.exports = (\r\nfunction instantiate(info) {\r\nfunction Table(ret) {\r\n  // grow method not included; table is not growable\r\n  ret.set = function(i, func) {\r\n    this[i] = func;\r\n  };\r\n  ret.get = function(i) {\r\n    return this[i];\r\n  };\r\n  return ret;\r\n}\r\n\r\n  var bufferView;\r\n  var base64ReverseLookup = new Uint8Array(123/*'z'+1*/);\r\n  for (var i = 25; i >= 0; --i) {\r\n    base64ReverseLookup[48+i] = 52+i; // '0-9'\r\n    base64ReverseLookup[65+i] = i; // 'A-Z'\r\n    base64ReverseLookup[97+i] = 26+i; // 'a-z'\r\n  }\r\n  base64ReverseLookup[43] = 62; // '+'\r\n  base64ReverseLookup[47] = 63; // '/'\r\n  /** @noinline Inlining this function would mean expanding the base64 string 4x times in the source code, which Closure seems to be happy to do. */\r\n  function base64DecodeToExistingUint8Array(uint8Array, offset, b64) {\r\n    var b1, b2, i = 0, j = offset, bLength = b64.length, end = offset + (bLength*3>>2) - (b64[bLength-2] == '=') - (b64[bLength-1] == '=');\r\n    for (; i < bLength; i += 4) {\r\n      b1 = base64ReverseLookup[b64.charCodeAt(i+1)];\r\n      b2 = base64ReverseLookup[b64.charCodeAt(i+2)];\r\n      uint8Array[j++] = base64ReverseLookup[b64.charCodeAt(i)] << 2 | b1 >> 4;\r\n      if (j < end) uint8Array[j++] = b1 << 4 | b2 >> 2;\r\n      if (j < end) uint8Array[j++] = b2 << 6 | base64ReverseLookup[b64.charCodeAt(i+3)];\r\n    }\r\n  }\r\nfunction initActiveSegments(imports) {\r\n  base64DecodeToExistingUint8Array(bufferView, 65536, \"dW5zaWduZWQgc2hvcnQAdW5zaWduZWQgaW50AGZsb2F0AHVpbnQ2NF90AHVuc2lnbmVkIGNoYXIAc3lzdGVtL2xpYi9saWJjeHhhYmkvc3JjL3ByaXZhdGVfdHlwZWluZm8uY3BwAENvbW11bmljYXRpb24AYm9vbABjYW5fY2F0Y2gAdW5zaWduZWQgbG9uZwBzdGQ6OndzdHJpbmcAc3RkOjpzdHJpbmcAc3RkOjp1MTZzdHJpbmcAc3RkOjp1MzJzdHJpbmcAZG91YmxlAHZvaWQAbW9uaXRvckNiAGV4ZWN1dGVDYgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaG9ydD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgc2hvcnQ+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgaW50PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxmbG9hdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDhfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50OF90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8aW50MTZfdD4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dWludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PGludDY0X3Q+AGVtc2NyaXB0ZW46Om1lbW9yeV92aWV3PHVpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxpbnQzMl90PgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzx1bnNpZ25lZCBjaGFyPgBzdGQ6OmJhc2ljX3N0cmluZzx1bnNpZ25lZCBjaGFyPgBlbXNjcmlwdGVuOjptZW1vcnlfdmlldzxzaWduZWQgY2hhcj4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8bG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8dW5zaWduZWQgbG9uZz4AZW1zY3JpcHRlbjo6bWVtb3J5X3ZpZXc8ZG91YmxlPgBhZGp1c3RlZFB0ciAmJiAiY2F0Y2hpbmcgYSBjbGFzcyB3aXRob3V0IGFuIG9iamVjdD8iAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0ljTlNfMTFjaGFyX3RyYWl0c0ljRUVOU185YWxsb2NhdG9ySWNFRUVFAEAKAQDBAwEATlN0M19fMjEyYmFzaWNfc3RyaW5nSWhOU18xMWNoYXJfdHJhaXRzSWhFRU5TXzlhbGxvY2F0b3JJaEVFRUUAAEAKAQAIBAEATlN0M19fMjEyYmFzaWNfc3RyaW5nSXdOU18xMWNoYXJfdHJhaXRzSXdFRU5TXzlhbGxvY2F0b3JJd0VFRUUAAEAKAQBQBAEATlN0M19fMjEyYmFzaWNfc3RyaW5nSURzTlNfMTFjaGFyX3RyYWl0c0lEc0VFTlNfOWFsbG9jYXRvcklEc0VFRUUAAABACgEAmAQBAE5TdDNfXzIxMmJhc2ljX3N0cmluZ0lEaU5TXzExY2hhcl90cmFpdHNJRGlFRU5TXzlhbGxvY2F0b3JJRGlFRUVFAAAAQAoBAOQEAQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0ljRUUAAEAKAQAwBQEATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJYUVFAABACgEAWAUBAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWhFRQAAQAoBAIAFAQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lzRUUAAEAKAQCoBQEATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJdEVFAABACgEA0AUBAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWlFRQAAQAoBAPgFAQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lqRUUAAEAKAQAgBgEATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJbEVFAABACgEASAYBAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SW1FRQAAQAoBAHAGAQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0l4RUUAAEAKAQCYBgEATjEwZW1zY3JpcHRlbjExbWVtb3J5X3ZpZXdJeUVFAABACgEAwAYBAE4xMGVtc2NyaXB0ZW4xMW1lbW9yeV92aWV3SWZFRQAAQAoBAOgGAQBOMTBlbXNjcmlwdGVuMTFtZW1vcnlfdmlld0lkRUUAAEAKAQAQBwEAMTNDb21tdW5pY2F0aW9uAEAKAQA4BwEAUDEzQ29tbXVuaWNhdGlvbgAAAADECgEAUAcBAAAAAABIBwEAUEsxM0NvbW11bmljYXRpb24AAADECgEAdAcBAAEAAABIBwEAcHAAdgB2cABkBwEAfAkBAGQHAQB2cHAAAAAAAAAAAAAAAAAAAAAAAHwJAQBkBwEA5AcBAJQJAQBOMTBlbXNjcmlwdGVuM3ZhbEUAAEAKAQDQBwEAdnBwcGkAAADkBwEATjEwX19jeHhhYml2MTE2X19zaGltX3R5cGVfaW5mb0UAAAAAaAoBAPgHAQDoCgEATjEwX19jeHhhYml2MTE3X19jbGFzc190eXBlX2luZm9FAAAAaAoBACgIAQAcCAEATjEwX19jeHhhYml2MTE3X19wYmFzZV90eXBlX2luZm9FAAAAaAoBAFgIAQAcCAEATjEwX19jeHhhYml2MTE5X19wb2ludGVyX3R5cGVfaW5mb0UAaAoBAIgIAQB8CAEATjEwX19jeHhhYml2MTIwX19mdW5jdGlvbl90eXBlX2luZm9FAAAAAGgKAQC4CAEAHAgBAE4xMF9fY3h4YWJpdjEyOV9fcG9pbnRlcl90b19tZW1iZXJfdHlwZV9pbmZvRQAAAGgKAQDsCAEAfAgBAAAAAABsCQEADwAAABAAAAARAAAAEgAAABMAAABOMTBfX2N4eGFiaXYxMjNfX2Z1bmRhbWVudGFsX3R5cGVfaW5mb0UAaAoBAEQJAQAcCAEAdgAAADAJAQB4CQEARG4AADAJAQCECQEAYgAAADAJAQCQCQEAYwAAADAJAQCcCQEAaAAAADAJAQCoCQEAYQAAADAJAQC0CQEAcwAAADAJAQDACQEAdAAAADAJAQDMCQEAaQAAADAJAQDYCQEAagAAADAJAQDkCQEAbAAAADAJAQDwCQEAbQAAADAJAQD8CQEAeAAAADAJAQAICgEAeQAAADAJAQAUCgEAZgAAADAJAQAgCgEAZAAAADAJAQAsCgEAAAAAAEwIAQAPAAAAFAAAABEAAAASAAAAFQAAABYAAAAXAAAAGAAAAAAAAACwCgEADwAAABkAAAARAAAAEgAAABUAAAAaAAAAGwAAABwAAABOMTBfX2N4eGFiaXYxMjBfX3NpX2NsYXNzX3R5cGVfaW5mb0UAAAAAaAoBAIgKAQBMCAEAAAAAAKwIAQAPAAAAHQAAABEAAAASAAAAHgAAAFN0OXR5cGVfaW5mbwAAAABACgEA2AoBAE5vIGVycm9yIGluZm9ybWF0aW9uAElsbGVnYWwgYnl0ZSBzZXF1ZW5jZQBEb21haW4gZXJyb3IAUmVzdWx0IG5vdCByZXByZXNlbnRhYmxlAE5vdCBhIHR0eQBQZXJtaXNzaW9uIGRlbmllZABPcGVyYXRpb24gbm90IHBlcm1pdHRlZABObyBzdWNoIGZpbGUgb3IgZGlyZWN0b3J5AE5vIHN1Y2ggcHJvY2VzcwBGaWxlIGV4aXN0cwBWYWx1ZSB0b28gbGFyZ2UgZm9yIGRhdGEgdHlwZQBObyBzcGFjZSBsZWZ0IG9uIGRldmljZQBPdXQgb2YgbWVtb3J5AFJlc291cmNlIGJ1c3kASW50ZXJydXB0ZWQgc3lzdGVtIGNhbGwAUmVzb3VyY2UgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUASW52YWxpZCBzZWVrAENyb3NzLWRldmljZSBsaW5rAFJlYWQtb25seSBmaWxlIHN5c3RlbQBEaXJlY3Rvcnkgbm90IGVtcHR5AENvbm5lY3Rpb24gcmVzZXQgYnkgcGVlcgBPcGVyYXRpb24gdGltZWQgb3V0AENvbm5lY3Rpb24gcmVmdXNlZABIb3N0IGlzIGRvd24ASG9zdCBpcyB1bnJlYWNoYWJsZQBBZGRyZXNzIGluIHVzZQBCcm9rZW4gcGlwZQBJL08gZXJyb3IATm8gc3VjaCBkZXZpY2Ugb3IgYWRkcmVzcwBCbG9jayBkZXZpY2UgcmVxdWlyZWQATm8gc3VjaCBkZXZpY2UATm90IGEgZGlyZWN0b3J5AElzIGEgZGlyZWN0b3J5AFRleHQgZmlsZSBidXN5AEV4ZWMgZm9ybWF0IGVycm9yAEludmFsaWQgYXJndW1lbnQAQXJndW1lbnQgbGlzdCB0b28gbG9uZwBTeW1ib2xpYyBsaW5rIGxvb3AARmlsZW5hbWUgdG9vIGxvbmcAVG9vIG1hbnkgb3BlbiBmaWxlcyBpbiBzeXN0ZW0ATm8gZmlsZSBkZXNjcmlwdG9ycyBhdmFpbGFibGUAQmFkIGZpbGUgZGVzY3JpcHRvcgBObyBjaGlsZCBwcm9jZXNzAEJhZCBhZGRyZXNzAEZpbGUgdG9vIGxhcmdlAFRvbyBtYW55IGxpbmtzAE5vIGxvY2tzIGF2YWlsYWJsZQBSZXNvdXJjZSBkZWFkbG9jayB3b3VsZCBvY2N1cgBTdGF0ZSBub3QgcmVjb3ZlcmFibGUAUHJldmlvdXMgb3duZXIgZGllZABPcGVyYXRpb24gY2FuY2VsZWQARnVuY3Rpb24gbm90IGltcGxlbWVudGVkAE5vIG1lc3NhZ2Ugb2YgZGVzaXJlZCB0eXBlAElkZW50aWZpZXIgcmVtb3ZlZABEZXZpY2Ugbm90IGEgc3RyZWFtAE5vIGRhdGEgYXZhaWxhYmxlAERldmljZSB0aW1lb3V0AE91dCBvZiBzdHJlYW1zIHJlc291cmNlcwBMaW5rIGhhcyBiZWVuIHNldmVyZWQAUHJvdG9jb2wgZXJyb3IAQmFkIG1lc3NhZ2UARmlsZSBkZXNjcmlwdG9yIGluIGJhZCBzdGF0ZQBOb3QgYSBzb2NrZXQARGVzdGluYXRpb24gYWRkcmVzcyByZXF1aXJlZABNZXNzYWdlIHRvbyBsYXJnZQBQcm90b2NvbCB3cm9uZyB0eXBlIGZvciBzb2NrZXQAUHJvdG9jb2wgbm90IGF2YWlsYWJsZQBQcm90b2NvbCBub3Qgc3VwcG9ydGVkAFNvY2tldCB0eXBlIG5vdCBzdXBwb3J0ZWQATm90IHN1cHBvcnRlZABQcm90b2NvbCBmYW1pbHkgbm90IHN1cHBvcnRlZABBZGRyZXNzIGZhbWlseSBub3Qgc3VwcG9ydGVkIGJ5IHByb3RvY29sAEFkZHJlc3Mgbm90IGF2YWlsYWJsZQBOZXR3b3JrIGlzIGRvd24ATmV0d29yayB1bnJlYWNoYWJsZQBDb25uZWN0aW9uIHJlc2V0IGJ5IG5ldHdvcmsAQ29ubmVjdGlvbiBhYm9ydGVkAE5vIGJ1ZmZlciBzcGFjZSBhdmFpbGFibGUAU29ja2V0IGlzIGNvbm5lY3RlZABTb2NrZXQgbm90IGNvbm5lY3RlZABDYW5ub3Qgc2VuZCBhZnRlciBzb2NrZXQgc2h1dGRvd24AT3BlcmF0aW9uIGFscmVhZHkgaW4gcHJvZ3Jlc3MAT3BlcmF0aW9uIGluIHByb2dyZXNzAFN0YWxlIGZpbGUgaGFuZGxlAFJlbW90ZSBJL08gZXJyb3IAUXVvdGEgZXhjZWVkZWQATm8gbWVkaXVtIGZvdW5kAFdyb25nIG1lZGl1bSB0eXBlAE11bHRpaG9wIGF0dGVtcHRlZABSZXF1aXJlZCBrZXkgbm90IGF2YWlsYWJsZQBLZXkgaGFzIGV4cGlyZWQAS2V5IGhhcyBiZWVuIHJldm9rZWQAS2V5IHdhcyByZWplY3RlZCBieSBzZXJ2aWNlAAAAAAAAAAAApQJbAPABtQWMBSUBgwYdA5QE/wDHAzEDCwa8AY8BfwPKBCsA2gavAEIDTgPcAQ4EFQChBg0BlAILAjgGZAK8Av8CXQPnBAsHzwLLBe8F2wXhAh4GRQKFAIICbANvBPEA8wMYBdkA2gNMBlQCewGdA70EAABRABUCuwCzA20A/wGFBC8F+QQ4AGUBRgGfALcGqAFzAlMBAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAIQQAAAAAAAAAAC8CAAAAAAAAAAAAAAAAAAAAAAAAAAA1BEcEVgQAAAAAAAAAAAAAAAAAAAAAoAQAAAAAAAAAAAAAAAAAAAAAAABGBWAFbgVhBgAAzwEAAAAAAAAAAMkG6Qb5Bh4HOQdJB14H\");\r\n  base64DecodeToExistingUint8Array(bufferView, 70568, \"kBcBAAAAAAAFAAAAAAAAAAAAAAAMAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAANAAAADgAAAHgXAQAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAA//////////8AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACwEwEA\");\r\n  base64DecodeToExistingUint8Array(bufferView, 70724, \"eyBjb25zb2xlLmxvZygn6L+Z5pivIEMrKyDlsYLnmoTlh73mlbDlnKgganMg5bGC6KKr6LCD55SoLOS4lOWcqCBDKysg5YaF5bWM5aWXIGpzIOS7o+eggScpOyB9AA==\");\r\n}\r\nfunction wasm2js_trap() { throw new Error('abort'); }\r\n\r\nfunction asmFunc(imports) {\r\n var buffer = new ArrayBuffer(16908288);\r\n var HEAP8 = new Int8Array(buffer);\r\n var HEAP16 = new Int16Array(buffer);\r\n var HEAP32 = new Int32Array(buffer);\r\n var HEAPU8 = new Uint8Array(buffer);\r\n var HEAPU16 = new Uint16Array(buffer);\r\n var HEAPU32 = new Uint32Array(buffer);\r\n var HEAPF32 = new Float32Array(buffer);\r\n var HEAPF64 = new Float64Array(buffer);\r\n var Math_imul = Math.imul;\r\n var Math_fround = Math.fround;\r\n var Math_abs = Math.abs;\r\n var Math_clz32 = Math.clz32;\r\n var Math_min = Math.min;\r\n var Math_max = Math.max;\r\n var Math_floor = Math.floor;\r\n var Math_ceil = Math.ceil;\r\n var Math_trunc = Math.trunc;\r\n var Math_sqrt = Math.sqrt;\r\n var env = imports.env;\r\n var fimport$0 = env._embind_register_class;\r\n var fimport$1 = env._embind_register_void;\r\n var fimport$2 = env._embind_register_bool;\r\n var fimport$3 = env._embind_register_integer;\r\n var fimport$4 = env._embind_register_float;\r\n var fimport$5 = env._embind_register_std_string;\r\n var fimport$6 = env._embind_register_std_wstring;\r\n var fimport$7 = env._embind_register_emval;\r\n var fimport$8 = env._embind_register_memory_view;\r\n var fimport$9 = env.emscripten_asm_const_int;\r\n var fimport$10 = env._embind_register_class_constructor;\r\n var fimport$11 = env._embind_register_class_function;\r\n var fimport$12 = env._emval_decref;\r\n var fimport$13 = env._emval_call;\r\n var fimport$14 = env._emval_get_method_caller;\r\n var fimport$15 = env._emval_run_destructors;\r\n var fimport$16 = env._emscripten_memcpy_js;\r\n var fimport$17 = env.emscripten_resize_heap;\r\n var fimport$18 = env._abort_js;\r\n var wasi_snapshot_preview1 = imports.wasi_snapshot_preview1;\r\n var fimport$19 = wasi_snapshot_preview1.fd_close;\r\n var fimport$20 = wasi_snapshot_preview1.fd_write;\r\n var fimport$21 = env.__assert_fail;\r\n var fimport$22 = env._embind_register_bigint;\r\n var fimport$23 = wasi_snapshot_preview1.fd_seek;\r\n var global$0 = 65536;\r\n var global$1 = 0;\r\n var global$2 = 0;\r\n var global$3 = 0;\r\n var global$4 = 70724;\r\n var global$5 = 70818;\r\n var i64toi32_i32$HIGH_BITS = 0;\r\n // EMSCRIPTEN_START_FUNCS\r\n;\r\n function $0() {\r\n  $141();\r\n  $4();\r\n  $71();\r\n  $77();\r\n }\r\n \r\n function $1($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return $79(HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 0) | 0 | 0;\r\n }\r\n \r\n function $2($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[(0 + 70820 | 0) >> 2] | 0;\r\n  HEAP32[(0 + 70820 | 0) >> 2] = $0_1;\r\n }\r\n \r\n function $3() {\r\n  var i64toi32_i32$0 = 0, i64toi32_i32$1 = 0;\r\n  fimport$1(67964 | 0, 65744 | 0);\r\n  fimport$2(67988 | 0, 65653 | 0, 1 | 0, 0 | 0);\r\n  fimport$3(68e3 | 0, 65588 | 0, 1 | 0, -128 | 0, 127 | 0);\r\n  fimport$3(68024 | 0, 65581 | 0, 1 | 0, -128 | 0, 127 | 0);\r\n  fimport$3(68012 | 0, 65579 | 0, 1 | 0, 0 | 0, 255 | 0);\r\n  fimport$3(68036 | 0, 65545 | 0, 2 | 0, -32768 | 0, 32767 | 0);\r\n  fimport$3(68048 | 0, 65536 | 0, 2 | 0, 0 | 0, 65535 | 0);\r\n  fimport$3(68060 | 0, 65560 | 0, 4 | 0, -2147483648 | 0, 2147483647 | 0);\r\n  fimport$3(68072 | 0, 65551 | 0, 4 | 0, 0 | 0, -1 | 0);\r\n  fimport$3(68084 | 0, 65677 | 0, 4 | 0, -2147483648 | 0, 2147483647 | 0);\r\n  fimport$3(68096 | 0, 65668 | 0, 4 | 0, 0 | 0, -1 | 0);\r\n  i64toi32_i32$0 = -2147483648;\r\n  i64toi32_i32$1 = 2147483647;\r\n  $153(68108 | 0, 65571 | 0, 8 | 0, 0 | 0, i64toi32_i32$0 | 0, -1 | 0, i64toi32_i32$1 | 0);\r\n  i64toi32_i32$1 = 0;\r\n  i64toi32_i32$0 = -1;\r\n  $153(68120 | 0, 65570 | 0, 8 | 0, 0 | 0, i64toi32_i32$1 | 0, -1 | 0, i64toi32_i32$0 | 0);\r\n  fimport$4(68132 | 0, 65564 | 0, 4 | 0);\r\n  fimport$4(68144 | 0, 65737 | 0, 8 | 0);\r\n  fimport$5(66560 | 0, 65695 | 0);\r\n  fimport$5(66632 | 0, 66273 | 0);\r\n  fimport$6(66704 | 0, 4 | 0, 65682 | 0);\r\n  fimport$6(66780 | 0, 2 | 0, 65707 | 0);\r\n  fimport$6(66856 | 0, 4 | 0, 65722 | 0);\r\n  fimport$7(67556 | 0);\r\n  fimport$8(66896 | 0, 0 | 0, 66204 | 0);\r\n  fimport$8(66936 | 0, 0 | 0, 66306 | 0);\r\n  fimport$8(66976 | 0, 1 | 0, 66234 | 0);\r\n  fimport$8(67016 | 0, 2 | 0, 65769 | 0);\r\n  fimport$8(67056 | 0, 3 | 0, 65800 | 0);\r\n  fimport$8(67096 | 0, 4 | 0, 65840 | 0);\r\n  fimport$8(67136 | 0, 5 | 0, 65869 | 0);\r\n  fimport$8(67176 | 0, 4 | 0, 66343 | 0);\r\n  fimport$8(67216 | 0, 5 | 0, 66373 | 0);\r\n  fimport$8(66936 | 0, 0 | 0, 65971 | 0);\r\n  fimport$8(66976 | 0, 1 | 0, 65938 | 0);\r\n  fimport$8(67016 | 0, 2 | 0, 66037 | 0);\r\n  fimport$8(67056 | 0, 3 | 0, 66003 | 0);\r\n  fimport$8(67096 | 0, 4 | 0, 66171 | 0);\r\n  fimport$8(67136 | 0, 5 | 0, 66137 | 0);\r\n  fimport$8(67256 | 0, 8 | 0, 66104 | 0);\r\n  fimport$8(67296 | 0, 9 | 0, 66070 | 0);\r\n  fimport$8(67336 | 0, 6 | 0, 65907 | 0);\r\n  fimport$8(67376 | 0, 7 | 0, 66412 | 0);\r\n }\r\n \r\n function $4() {\r\n  HEAP32[(0 + 70824 | 0) >> 2] = 1;\r\n  HEAP32[(0 + 70828 | 0) >> 2] = 0;\r\n  $3();\r\n  HEAP32[(0 + 70828 | 0) >> 2] = HEAP32[(0 + 70820 | 0) >> 2] | 0;\r\n  HEAP32[(0 + 70820 | 0) >> 2] = 70824;\r\n }\r\n \r\n function $5() {\r\n  $6(70832 | 0) | 0;\r\n  return;\r\n }\r\n \r\n function $6($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  $8($4_1 | 0, 2 | 0) | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $7() {\r\n  var $2_1 = 0, i64toi32_i32$0 = 0, i64toi32_i32$1 = 0, $33_1 = 0, $10_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $15_1 = 0, $16_1 = 0, $18_1 = 0, $19_1 = 0, $21_1 = 0, $22_1 = 0, $23_1 = 0, $31_1 = 0, $151_1 = 0, $35_1 = 0, $36_1 = 0, $38_1 = 0, $39_1 = 0, $40_1 = 0, $179 = 0, $192 = 0, $45_1 = 0, $46_1 = 0, $48_1 = 0, $49_1 = 0, $218 = 0;\r\n  $2_1 = global$0 - 160 | 0;\r\n  global$0 = $2_1;\r\n  HEAP32[($2_1 + 64 | 0) >> 2] = $2_1 + 43 | 0;\r\n  HEAP32[($2_1 + 60 | 0) >> 2] = 65639;\r\n  $9();\r\n  HEAP32[($2_1 + 56 | 0) >> 2] = 3;\r\n  HEAP32[($2_1 + 52 | 0) >> 2] = $11() | 0;\r\n  HEAP32[($2_1 + 48 | 0) >> 2] = $12() | 0;\r\n  HEAP32[($2_1 + 44 | 0) >> 2] = 4;\r\n  $10_1 = $14() | 0;\r\n  $11_1 = $15() | 0;\r\n  $12_1 = $16() | 0;\r\n  $13_1 = $17() | 0;\r\n  HEAP32[($2_1 + 136 | 0) >> 2] = HEAP32[($2_1 + 56 | 0) >> 2] | 0;\r\n  $15_1 = $18() | 0;\r\n  $16_1 = HEAP32[($2_1 + 56 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 144 | 0) >> 2] = HEAP32[($2_1 + 52 | 0) >> 2] | 0;\r\n  $18_1 = $19() | 0;\r\n  $19_1 = HEAP32[($2_1 + 52 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 140 | 0) >> 2] = HEAP32[($2_1 + 48 | 0) >> 2] | 0;\r\n  $21_1 = $19() | 0;\r\n  $22_1 = HEAP32[($2_1 + 48 | 0) >> 2] | 0;\r\n  $23_1 = HEAP32[($2_1 + 60 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 148 | 0) >> 2] = HEAP32[($2_1 + 44 | 0) >> 2] | 0;\r\n  fimport$0($10_1 | 0, $11_1 | 0, $12_1 | 0, $13_1 | 0, $15_1 | 0, $16_1 | 0, $18_1 | 0, $19_1 | 0, $21_1 | 0, $22_1 | 0, $23_1 | 0, $20() | 0 | 0, HEAP32[($2_1 + 44 | 0) >> 2] | 0 | 0);\r\n  HEAP32[($2_1 + 68 | 0) >> 2] = $2_1 + 43 | 0;\r\n  HEAP32[($2_1 + 156 | 0) >> 2] = HEAP32[($2_1 + 68 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 152 | 0) >> 2] = 5;\r\n  $31_1 = HEAP32[($2_1 + 156 | 0) >> 2] | 0;\r\n  $22(HEAP32[($2_1 + 152 | 0) >> 2] | 0 | 0);\r\n  $33_1 = 0;\r\n  HEAP32[($2_1 + 36 | 0) >> 2] = $33_1;\r\n  HEAP32[($2_1 + 32 | 0) >> 2] = 6;\r\n  i64toi32_i32$0 = HEAP32[($2_1 + 32 | 0) >> 2] | 0;\r\n  i64toi32_i32$1 = HEAP32[($2_1 + 36 | 0) >> 2] | 0;\r\n  $151_1 = i64toi32_i32$0;\r\n  i64toi32_i32$0 = $2_1;\r\n  HEAP32[($2_1 + 72 | 0) >> 2] = $151_1;\r\n  HEAP32[($2_1 + 76 | 0) >> 2] = i64toi32_i32$1;\r\n  $35_1 = HEAP32[($2_1 + 72 | 0) >> 2] | 0;\r\n  $36_1 = HEAP32[($2_1 + 76 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 100 | 0) >> 2] = $31_1;\r\n  HEAP32[($2_1 + 96 | 0) >> 2] = 65759;\r\n  HEAP32[($2_1 + 92 | 0) >> 2] = $36_1;\r\n  HEAP32[($2_1 + 88 | 0) >> 2] = $35_1;\r\n  $38_1 = HEAP32[($2_1 + 100 | 0) >> 2] | 0;\r\n  $39_1 = HEAP32[($2_1 + 96 | 0) >> 2] | 0;\r\n  $40_1 = HEAP32[($2_1 + 88 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 84 | 0) >> 2] = HEAP32[($2_1 + 92 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 80 | 0) >> 2] = $40_1;\r\n  i64toi32_i32$1 = HEAP32[($2_1 + 80 | 0) >> 2] | 0;\r\n  i64toi32_i32$0 = HEAP32[($2_1 + 84 | 0) >> 2] | 0;\r\n  $179 = i64toi32_i32$1;\r\n  i64toi32_i32$1 = $2_1;\r\n  HEAP32[($2_1 + 8 | 0) >> 2] = $179;\r\n  HEAP32[($2_1 + 12 | 0) >> 2] = i64toi32_i32$0;\r\n  $24($39_1 | 0, $2_1 + 8 | 0 | 0);\r\n  HEAP32[($2_1 + 28 | 0) >> 2] = $33_1;\r\n  HEAP32[($2_1 + 24 | 0) >> 2] = 7;\r\n  i64toi32_i32$0 = HEAP32[($2_1 + 24 | 0) >> 2] | 0;\r\n  i64toi32_i32$1 = HEAP32[($2_1 + 28 | 0) >> 2] | 0;\r\n  $192 = i64toi32_i32$0;\r\n  i64toi32_i32$0 = $2_1;\r\n  HEAP32[($2_1 + 104 | 0) >> 2] = $192;\r\n  HEAP32[($2_1 + 108 | 0) >> 2] = i64toi32_i32$1;\r\n  $45_1 = HEAP32[($2_1 + 104 | 0) >> 2] | 0;\r\n  $46_1 = HEAP32[($2_1 + 108 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 132 | 0) >> 2] = $38_1;\r\n  HEAP32[($2_1 + 128 | 0) >> 2] = 65749;\r\n  HEAP32[($2_1 + 124 | 0) >> 2] = $46_1;\r\n  HEAP32[($2_1 + 120 | 0) >> 2] = $45_1;\r\n  $48_1 = HEAP32[($2_1 + 128 | 0) >> 2] | 0;\r\n  $49_1 = HEAP32[($2_1 + 120 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 116 | 0) >> 2] = HEAP32[($2_1 + 124 | 0) >> 2] | 0;\r\n  HEAP32[($2_1 + 112 | 0) >> 2] = $49_1;\r\n  i64toi32_i32$1 = HEAP32[($2_1 + 112 | 0) >> 2] | 0;\r\n  i64toi32_i32$0 = HEAP32[($2_1 + 116 | 0) >> 2] | 0;\r\n  $218 = i64toi32_i32$1;\r\n  i64toi32_i32$1 = $2_1;\r\n  HEAP32[($2_1 + 16 | 0) >> 2] = $218;\r\n  HEAP32[($2_1 + 20 | 0) >> 2] = i64toi32_i32$0;\r\n  $26($48_1 | 0, $2_1 + 16 | 0 | 0);\r\n  global$0 = $2_1 + 160 | 0;\r\n  return;\r\n }\r\n \r\n function $8($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0, $5_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $5_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n  HEAP32[$5_1 >> 2] = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n  HEAP32[($5_1 + 4 | 0) >> 2] = 0;\r\n  FUNCTION_TABLE[HEAP32[($4_1 + 8 | 0) >> 2] | 0 | 0]();\r\n  $2($5_1 | 0);\r\n  global$0 = $4_1 + 16 | 0;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $9() {\r\n  \r\n }\r\n \r\n function $10($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $5_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $5_1 = $29(HEAP32[($3_1 + 12 | 0) >> 2] | 0 | 0) | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $11() {\r\n  return 0 | 0;\r\n }\r\n \r\n function $12() {\r\n  return 0 | 0;\r\n }\r\n \r\n function $13($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  label$1 : {\r\n   if (($4_1 | 0) == (0 | 0) & 1 | 0) {\r\n    break label$1\r\n   }\r\n   $91($4_1 | 0, 1 | 0);\r\n  }\r\n  global$0 = $3_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $14() {\r\n  return $30() | 0 | 0;\r\n }\r\n \r\n function $15() {\r\n  return $31() | 0 | 0;\r\n }\r\n \r\n function $16() {\r\n  return $32() | 0 | 0;\r\n }\r\n \r\n function $17() {\r\n  return 0 | 0;\r\n }\r\n \r\n function $18() {\r\n  return 67480 | 0;\r\n }\r\n \r\n function $19() {\r\n  return 67483 | 0;\r\n }\r\n \r\n function $20() {\r\n  return 67485 | 0;\r\n }\r\n \r\n function $21() {\r\n  return $87(1 | 0) | 0 | 0;\r\n }\r\n \r\n function $22($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $5_1 = 0, $9_1 = 0, $13_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $0_1;\r\n  HEAP32[$3_1 >> 2] = 8;\r\n  $5_1 = $14() | 0;\r\n  $9_1 = $34($3_1 + 7 | 0 | 0) | 0;\r\n  $13_1 = $35($3_1 + 7 | 0 | 0) | 0;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = HEAP32[$3_1 >> 2] | 0;\r\n  fimport$10($5_1 | 0, $9_1 | 0, $13_1 | 0, $18() | 0 | 0, HEAP32[$3_1 >> 2] | 0 | 0, HEAP32[($3_1 + 8 | 0) >> 2] | 0 | 0);\r\n  global$0 = $3_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $23($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = 70724;\r\n  fimport$9(HEAP32[($3_1 + 8 | 0) >> 2] | 0 | 0, 67504 | 0, 0 | 0) | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $24($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0, $26_1 = 0, $5_1 = 0, $6_1 = 0, $8_1 = 0, $9_1 = 0, $13_1 = 0, $17_1 = 0;\r\n  $4_1 = global$0 - 32 | 0;\r\n  global$0 = $4_1;\r\n  $5_1 = HEAP32[$1_1 >> 2] | 0;\r\n  $6_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;\r\n  HEAP32[($4_1 + 24 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 20 | 0) >> 2] = $6_1;\r\n  HEAP32[($4_1 + 16 | 0) >> 2] = $5_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = 9;\r\n  $8_1 = $14() | 0;\r\n  $9_1 = HEAP32[($4_1 + 24 | 0) >> 2] | 0;\r\n  $13_1 = $39($4_1 + 11 | 0 | 0) | 0;\r\n  $17_1 = $40($4_1 + 11 | 0 | 0) | 0;\r\n  HEAP32[($4_1 + 28 | 0) >> 2] = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n  $26_1 = 0;\r\n  fimport$11($8_1 | 0, $9_1 | 0, $13_1 | 0, $17_1 | 0, $41() | 0 | 0, HEAP32[($4_1 + 12 | 0) >> 2] | 0 | 0, $42($4_1 + 16 | 0 | 0) | 0 | 0, 0 | 0, $26_1 & 1 | 0 | 0, $26_1 & 1 | 0 | 0);\r\n  global$0 = $4_1 + 32 | 0;\r\n  return;\r\n }\r\n \r\n function $25($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $5_1 = 0;\r\n  $5_1 = global$0 - 32 | 0;\r\n  global$0 = $5_1;\r\n  HEAP32[($5_1 + 28 | 0) >> 2] = $0_1;\r\n  HEAP32[($5_1 + 24 | 0) >> 2] = $1_1;\r\n  HEAP8[($5_1 + 23 | 0) >> 0] = $2_1;\r\n  label$1 : {\r\n   if (!((HEAPU8[($5_1 + 23 | 0) >> 0] | 0) & 1 | 0)) {\r\n    break label$1\r\n   }\r\n   $27($5_1 + 12 | 0 | 0, $1_1 | 0);\r\n   $28($5_1 + 12 | 0 | 0) | 0;\r\n  }\r\n  global$0 = $5_1 + 32 | 0;\r\n  return;\r\n }\r\n \r\n function $26($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0, $26_1 = 0, $5_1 = 0, $6_1 = 0, $8_1 = 0, $9_1 = 0, $13_1 = 0, $17_1 = 0;\r\n  $4_1 = global$0 - 32 | 0;\r\n  global$0 = $4_1;\r\n  $5_1 = HEAP32[$1_1 >> 2] | 0;\r\n  $6_1 = HEAP32[($1_1 + 4 | 0) >> 2] | 0;\r\n  HEAP32[($4_1 + 24 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 20 | 0) >> 2] = $6_1;\r\n  HEAP32[($4_1 + 16 | 0) >> 2] = $5_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = 10;\r\n  $8_1 = $14() | 0;\r\n  $9_1 = HEAP32[($4_1 + 24 | 0) >> 2] | 0;\r\n  $13_1 = $46($4_1 + 11 | 0 | 0) | 0;\r\n  $17_1 = $47($4_1 + 11 | 0 | 0) | 0;\r\n  HEAP32[($4_1 + 28 | 0) >> 2] = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n  $26_1 = 0;\r\n  fimport$11($8_1 | 0, $9_1 | 0, $13_1 | 0, $17_1 | 0, $48() | 0 | 0, HEAP32[($4_1 + 12 | 0) >> 2] | 0 | 0, $49($4_1 + 16 | 0 | 0) | 0 | 0, 0 | 0, $26_1 & 1 | 0 | 0, $26_1 & 1 | 0 | 0);\r\n  global$0 = $4_1 + 32 | 0;\r\n  return;\r\n }\r\n \r\n function $27($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $57($0_1 | 0, HEAP32[($4_1 + 8 | 0) >> 2] | 0 | 0, 11 | 0);\r\n  global$0 = $4_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $28($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0, $10_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $0_1;\r\n  $4_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $4_1;\r\n  label$1 : {\r\n   if (!(($54($4_1 | 0) | 0) & 1 | 0)) {\r\n    break label$1\r\n   }\r\n   fimport$12($55($4_1 | 0) | 0 | 0);\r\n   HEAP32[($4_1 + 4 | 0) >> 2] = 0;\r\n  }\r\n  $10_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $10_1 | 0;\r\n }\r\n \r\n function $29($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 67400 | 0;\r\n }\r\n \r\n function $30() {\r\n  return 67400 | 0;\r\n }\r\n \r\n function $31() {\r\n  return 67428 | 0;\r\n }\r\n \r\n function $32() {\r\n  return 67464 | 0;\r\n }\r\n \r\n function $33($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $6_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $6_1 = $36(FUNCTION_TABLE[HEAP32[($3_1 + 12 | 0) >> 2] | 0 | 0]() | 0 | 0) | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $6_1 | 0;\r\n }\r\n \r\n function $34($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 1 | 0;\r\n }\r\n \r\n function $35($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = $37() | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $36($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $0_1;\r\n  return HEAP32[($3_1 + 8 | 0) >> 2] | 0 | 0;\r\n }\r\n \r\n function $37() {\r\n  return 67488 | 0;\r\n }\r\n \r\n function $38($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0, $7_1 = 0, $8_1 = 0, $9_1 = 0, $12_1 = 0, $18_1 = 0, $6_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $6_1 = $43(HEAP32[($4_1 + 8 | 0) >> 2] | 0 | 0) | 0;\r\n  $7_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n  $8_1 = HEAP32[($7_1 + 4 | 0) >> 2] | 0;\r\n  $9_1 = HEAP32[$7_1 >> 2] | 0;\r\n  $12_1 = $6_1 + ($8_1 >> 1 | 0) | 0;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (!($8_1 & 1 | 0)) {\r\n     break label$2\r\n    }\r\n    $18_1 = HEAP32[((HEAP32[$12_1 >> 2] | 0) + $9_1 | 0) >> 2] | 0;\r\n    break label$1;\r\n   }\r\n   $18_1 = $9_1;\r\n  }\r\n  FUNCTION_TABLE[$18_1 | 0]($12_1);\r\n  global$0 = $4_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $39($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 2 | 0;\r\n }\r\n \r\n function $40($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = $44() | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $41() {\r\n  return 67500 | 0;\r\n }\r\n \r\n function $42($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $9_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $5_1 = $87(8 | 0) | 0;\r\n  $6_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  $7_1 = HEAP32[$6_1 >> 2] | 0;\r\n  HEAP32[($5_1 + 4 | 0) >> 2] = HEAP32[($6_1 + 4 | 0) >> 2] | 0;\r\n  HEAP32[$5_1 >> 2] = $7_1;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $5_1;\r\n  $9_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $9_1 | 0;\r\n }\r\n \r\n function $43($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  return HEAP32[($3_1 + 12 | 0) >> 2] | 0 | 0;\r\n }\r\n \r\n function $44() {\r\n  return 67492 | 0;\r\n }\r\n \r\n function $45($0_1, $1_1, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  var $6_1 = 0, $11_1 = 0, $12_1 = 0, $13_1 = 0, $16_1 = 0, $22_1 = 0, $10_1 = 0;\r\n  $6_1 = global$0 - 32 | 0;\r\n  global$0 = $6_1;\r\n  HEAP32[($6_1 + 28 | 0) >> 2] = $0_1;\r\n  HEAP32[($6_1 + 24 | 0) >> 2] = $1_1;\r\n  HEAP32[($6_1 + 20 | 0) >> 2] = $2_1;\r\n  HEAP8[($6_1 + 19 | 0) >> 0] = $3_1 & 1 | 0;\r\n  $10_1 = $43(HEAP32[($6_1 + 24 | 0) >> 2] | 0 | 0) | 0;\r\n  $11_1 = HEAP32[($6_1 + 28 | 0) >> 2] | 0;\r\n  $12_1 = HEAP32[($11_1 + 4 | 0) >> 2] | 0;\r\n  $13_1 = HEAP32[$11_1 >> 2] | 0;\r\n  $16_1 = $10_1 + ($12_1 >> 1 | 0) | 0;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (!($12_1 & 1 | 0)) {\r\n     break label$2\r\n    }\r\n    $22_1 = HEAP32[((HEAP32[$16_1 >> 2] | 0) + $13_1 | 0) >> 2] | 0;\r\n    break label$1;\r\n   }\r\n   $22_1 = $13_1;\r\n  }\r\n  $50($6_1 + 8 | 0 | 0, HEAP32[($6_1 + 20 | 0) >> 2] | 0 | 0);\r\n  FUNCTION_TABLE[$22_1 | 0]($16_1, $6_1 + 8 | 0, ($51((HEAPU8[($6_1 + 19 | 0) >> 0] | 0) & 1 | 0 | 0) | 0) & 1 | 0);\r\n  $28($6_1 + 8 | 0 | 0) | 0;\r\n  global$0 = $6_1 + 32 | 0;\r\n  return;\r\n }\r\n \r\n function $46($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 4 | 0;\r\n }\r\n \r\n function $47($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = $52() | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $48() {\r\n  return 67564 | 0;\r\n }\r\n \r\n function $49($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $9_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $5_1 = $87(8 | 0) | 0;\r\n  $6_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  $7_1 = HEAP32[$6_1 >> 2] | 0;\r\n  HEAP32[($5_1 + 4 | 0) >> 2] = HEAP32[($6_1 + 4 | 0) >> 2] | 0;\r\n  HEAP32[$5_1 >> 2] = $7_1;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $5_1;\r\n  $9_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $9_1 | 0;\r\n }\r\n \r\n function $50($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $53($0_1 | 0, HEAP32[($4_1 + 8 | 0) >> 2] | 0 | 0);\r\n  global$0 = $4_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $51($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  HEAP8[($3_1 + 15 | 0) >> 0] = $0_1;\r\n  return (HEAPU8[($3_1 + 15 | 0) >> 0] | 0) & 1 | 0 | 0;\r\n }\r\n \r\n function $52() {\r\n  return 67520 | 0;\r\n }\r\n \r\n function $53($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $56($0_1 | 0, HEAP32[($4_1 + 8 | 0) >> 2] | 0 | 0) | 0;\r\n  global$0 = $4_1 + 16 | 0;\r\n  return;\r\n }\r\n \r\n function $54($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  return (HEAP32[((HEAP32[($3_1 + 12 | 0) >> 2] | 0) + 4 | 0) >> 2] | 0) >>> 0 > 8 >>> 0 & 1 | 0 | 0;\r\n }\r\n \r\n function $55($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  return HEAP32[((HEAP32[($3_1 + 12 | 0) >> 2] | 0) + 4 | 0) >> 2] | 0 | 0;\r\n }\r\n \r\n function $56($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0, $5_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $5_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n  HEAP32[$5_1 >> 2] = $72() | 0;\r\n  HEAP32[($5_1 + 4 | 0) >> 2] = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n  global$0 = $4_1 + 16 | 0;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $57($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $5_1 = 0, $6_1 = 0, $11_1 = 0;\r\n  $5_1 = global$0 - 48 | 0;\r\n  global$0 = $5_1;\r\n  HEAP32[($5_1 + 44 | 0) >> 2] = $0_1;\r\n  HEAP32[($5_1 + 40 | 0) >> 2] = $1_1;\r\n  HEAP32[($5_1 + 36 | 0) >> 2] = $2_1;\r\n  $6_1 = HEAP32[($5_1 + 40 | 0) >> 2] | 0;\r\n  $58($5_1 + 24 | 0 | 0) | 0;\r\n  HEAP32[($5_1 + 20 | 0) >> 2] = 0;\r\n  $11_1 = HEAP32[($5_1 + 36 | 0) >> 2] | 0;\r\n  HEAPF64[($5_1 + 8 | 0) >> 3] = +FUNCTION_TABLE[$11_1 | 0]($59() | 0, $55($6_1 | 0) | 0, $5_1 + 20 | 0, $60($5_1 + 24 | 0 | 0) | 0);\r\n  $61($5_1 + 4 | 0 | 0, HEAP32[($5_1 + 20 | 0) >> 2] | 0 | 0) | 0;\r\n  $62($0_1 | 0, +(+HEAPF64[($5_1 + 8 | 0) >> 3]));\r\n  $63($5_1 + 4 | 0 | 0) | 0;\r\n  global$0 = $5_1 + 48 | 0;\r\n  return;\r\n }\r\n \r\n function $58($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $64($4_1 | 0) | 0;\r\n  $65($3_1 + 8 | 0 | 0);\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $59() {\r\n  label$1 : {\r\n   if (!((((HEAPU8[(0 + 70844 | 0) >> 0] | 0) & 1 | 0) & 255 | 0 | 0) == (0 & 255 | 0 | 0) & 1 | 0)) {\r\n    break label$1\r\n   }\r\n   HEAP32[(0 + 70840 | 0) >> 2] = fimport$14($66(67570 | 0) | 0 | 0, $67(67570 | 0) | 0 | 0, 0 | 0) | 0;\r\n   HEAP8[(0 + 70844 | 0) >> 0] = 1;\r\n  }\r\n  return HEAP32[(0 + 70840 | 0) >> 2] | 0 | 0;\r\n }\r\n \r\n function $60($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $5_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $5_1 = $68(HEAP32[($3_1 + 12 | 0) >> 2] | 0 | 0) | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $61($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $4_1 = 0, $5_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $0_1;\r\n  HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n  $5_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n  HEAP32[$5_1 >> 2] = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $62($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = +$1_1;\r\n  var $4_1 = 0;\r\n  $4_1 = global$0 - 32 | 0;\r\n  global$0 = $4_1;\r\n  HEAP32[($4_1 + 28 | 0) >> 2] = $0_1;\r\n  HEAPF64[($4_1 + 16 | 0) >> 3] = $1_1;\r\n  HEAP32[($4_1 + 12 | 0) >> 2] = $69(+(+HEAPF64[($4_1 + 16 | 0) >> 3])) | 0;\r\n  $50($0_1 | 0, HEAP32[($4_1 + 12 | 0) >> 2] | 0 | 0);\r\n  global$0 = $4_1 + 32 | 0;\r\n  return;\r\n }\r\n \r\n function $63($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0, $11_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 8 | 0) >> 2] = $0_1;\r\n  $4_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $4_1;\r\n  label$1 : {\r\n   if (!((HEAP32[$4_1 >> 2] | 0 | 0) != (0 | 0) & 1 | 0)) {\r\n    break label$1\r\n   }\r\n   fimport$15(HEAP32[$4_1 >> 2] | 0 | 0);\r\n  }\r\n  $11_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $11_1 | 0;\r\n }\r\n \r\n function $64($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 0 | 0;\r\n }\r\n \r\n function $65($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return;\r\n }\r\n \r\n function $66($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 1 | 0;\r\n }\r\n \r\n function $67($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n  $4_1 = $70() | 0;\r\n  global$0 = $3_1 + 16 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $68($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  HEAP32[((global$0 - 16 | 0) + 12 | 0) >> 2] = $0_1;\r\n  return 0 | 0;\r\n }\r\n \r\n function $69($0_1) {\r\n  $0_1 = +$0_1;\r\n  var $12_1 = 0.0, $3_1 = 0, $9_1 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  HEAPF64[($3_1 + 8 | 0) >> 3] = $0_1;\r\n  $12_1 = +HEAPF64[($3_1 + 8 | 0) >> 3];\r\n  label$1 : {\r\n   label$2 : {\r\n    if (!($12_1 < 4294967296.0 & $12_1 >= 0.0 | 0)) {\r\n     break label$2\r\n    }\r\n    $9_1 = ~~$12_1 >>> 0;\r\n    break label$1;\r\n   }\r\n   $9_1 = 0;\r\n  }\r\n  return $9_1 | 0;\r\n }\r\n \r\n function $70() {\r\n  return 67572 | 0;\r\n }\r\n \r\n function $71() {\r\n  $5();\r\n  return;\r\n }\r\n \r\n function $72() {\r\n  return $76() | 0 | 0;\r\n }\r\n \r\n function $73($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $3_1 = 0, i64toi32_i32$0 = 0, $4_1 = 0, i64toi32_i32$1 = 0, $6_1 = 0, $5_1 = 0, $6$hi = 0;\r\n  label$1 : {\r\n   if (!$2_1) {\r\n    break label$1\r\n   }\r\n   HEAP8[$0_1 >> 0] = $1_1;\r\n   $3_1 = $0_1 + $2_1 | 0;\r\n   HEAP8[($3_1 + -1 | 0) >> 0] = $1_1;\r\n   if ($2_1 >>> 0 < 3 >>> 0) {\r\n    break label$1\r\n   }\r\n   HEAP8[($0_1 + 2 | 0) >> 0] = $1_1;\r\n   HEAP8[($0_1 + 1 | 0) >> 0] = $1_1;\r\n   HEAP8[($3_1 + -3 | 0) >> 0] = $1_1;\r\n   HEAP8[($3_1 + -2 | 0) >> 0] = $1_1;\r\n   if ($2_1 >>> 0 < 7 >>> 0) {\r\n    break label$1\r\n   }\r\n   HEAP8[($0_1 + 3 | 0) >> 0] = $1_1;\r\n   HEAP8[($3_1 + -4 | 0) >> 0] = $1_1;\r\n   if ($2_1 >>> 0 < 9 >>> 0) {\r\n    break label$1\r\n   }\r\n   $4_1 = (0 - $0_1 | 0) & 3 | 0;\r\n   $3_1 = $0_1 + $4_1 | 0;\r\n   $1_1 = Math_imul($1_1 & 255 | 0, 16843009);\r\n   HEAP32[$3_1 >> 2] = $1_1;\r\n   $4_1 = ($2_1 - $4_1 | 0) & -4 | 0;\r\n   $2_1 = $3_1 + $4_1 | 0;\r\n   HEAP32[($2_1 + -4 | 0) >> 2] = $1_1;\r\n   if ($4_1 >>> 0 < 9 >>> 0) {\r\n    break label$1\r\n   }\r\n   HEAP32[($3_1 + 8 | 0) >> 2] = $1_1;\r\n   HEAP32[($3_1 + 4 | 0) >> 2] = $1_1;\r\n   HEAP32[($2_1 + -8 | 0) >> 2] = $1_1;\r\n   HEAP32[($2_1 + -12 | 0) >> 2] = $1_1;\r\n   if ($4_1 >>> 0 < 25 >>> 0) {\r\n    break label$1\r\n   }\r\n   HEAP32[($3_1 + 24 | 0) >> 2] = $1_1;\r\n   HEAP32[($3_1 + 20 | 0) >> 2] = $1_1;\r\n   HEAP32[($3_1 + 16 | 0) >> 2] = $1_1;\r\n   HEAP32[($3_1 + 12 | 0) >> 2] = $1_1;\r\n   HEAP32[($2_1 + -16 | 0) >> 2] = $1_1;\r\n   HEAP32[($2_1 + -20 | 0) >> 2] = $1_1;\r\n   HEAP32[($2_1 + -24 | 0) >> 2] = $1_1;\r\n   HEAP32[($2_1 + -28 | 0) >> 2] = $1_1;\r\n   $5_1 = $3_1 & 4 | 0 | 24 | 0;\r\n   $2_1 = $4_1 - $5_1 | 0;\r\n   if ($2_1 >>> 0 < 32 >>> 0) {\r\n    break label$1\r\n   }\r\n   i64toi32_i32$0 = 0;\r\n   i64toi32_i32$1 = 1;\r\n   i64toi32_i32$1 = __wasm_i64_mul($1_1 | 0, i64toi32_i32$0 | 0, 1 | 0, i64toi32_i32$1 | 0) | 0;\r\n   i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;\r\n   $6_1 = i64toi32_i32$1;\r\n   $6$hi = i64toi32_i32$0;\r\n   $1_1 = $3_1 + $5_1 | 0;\r\n   label$2 : while (1) {\r\n    i64toi32_i32$0 = $6$hi;\r\n    i64toi32_i32$1 = $1_1;\r\n    HEAP32[($1_1 + 24 | 0) >> 2] = $6_1;\r\n    HEAP32[($1_1 + 28 | 0) >> 2] = i64toi32_i32$0;\r\n    i64toi32_i32$1 = $1_1;\r\n    HEAP32[($1_1 + 16 | 0) >> 2] = $6_1;\r\n    HEAP32[($1_1 + 20 | 0) >> 2] = i64toi32_i32$0;\r\n    i64toi32_i32$1 = $1_1;\r\n    HEAP32[($1_1 + 8 | 0) >> 2] = $6_1;\r\n    HEAP32[($1_1 + 12 | 0) >> 2] = i64toi32_i32$0;\r\n    i64toi32_i32$1 = $1_1;\r\n    HEAP32[$1_1 >> 2] = $6_1;\r\n    HEAP32[($1_1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n    $1_1 = $1_1 + 32 | 0;\r\n    $2_1 = $2_1 + -32 | 0;\r\n    if ($2_1 >>> 0 > 31 >>> 0) {\r\n     continue label$2\r\n    }\r\n    break label$2;\r\n   };\r\n  }\r\n  return $0_1 | 0;\r\n }\r\n \r\n function $74() {\r\n  return 42 | 0;\r\n }\r\n \r\n function $75() {\r\n  return $74() | 0 | 0;\r\n }\r\n \r\n function $76() {\r\n  return 70904 | 0;\r\n }\r\n \r\n function $77() {\r\n  HEAP32[(0 + 71e3 | 0) >> 2] = 70880;\r\n  HEAP32[(0 + 70928 | 0) >> 2] = $75() | 0;\r\n }\r\n \r\n function $78($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0, $5_1 = 0;\r\n  label$1 : {\r\n   if ($2_1 >>> 0 < 512 >>> 0) {\r\n    break label$1\r\n   }\r\n   fimport$16($0_1 | 0, $1_1 | 0, $2_1 | 0);\r\n   return $0_1 | 0;\r\n  }\r\n  $3_1 = $0_1 + $2_1 | 0;\r\n  label$2 : {\r\n   label$3 : {\r\n    if (($1_1 ^ $0_1 | 0) & 3 | 0) {\r\n     break label$3\r\n    }\r\n    label$4 : {\r\n     label$5 : {\r\n      if ($0_1 & 3 | 0) {\r\n       break label$5\r\n      }\r\n      $2_1 = $0_1;\r\n      break label$4;\r\n     }\r\n     label$6 : {\r\n      if ($2_1) {\r\n       break label$6\r\n      }\r\n      $2_1 = $0_1;\r\n      break label$4;\r\n     }\r\n     $2_1 = $0_1;\r\n     label$7 : while (1) {\r\n      HEAP8[$2_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;\r\n      $1_1 = $1_1 + 1 | 0;\r\n      $2_1 = $2_1 + 1 | 0;\r\n      if (!($2_1 & 3 | 0)) {\r\n       break label$4\r\n      }\r\n      if ($2_1 >>> 0 < $3_1 >>> 0) {\r\n       continue label$7\r\n      }\r\n      break label$7;\r\n     };\r\n    }\r\n    $4_1 = $3_1 & -4 | 0;\r\n    label$8 : {\r\n     if ($3_1 >>> 0 < 64 >>> 0) {\r\n      break label$8\r\n     }\r\n     $5_1 = $4_1 + -64 | 0;\r\n     if ($2_1 >>> 0 > $5_1 >>> 0) {\r\n      break label$8\r\n     }\r\n     label$9 : while (1) {\r\n      HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2] | 0;\r\n      HEAP32[($2_1 + 4 | 0) >> 2] = HEAP32[($1_1 + 4 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 8 | 0) >> 2] = HEAP32[($1_1 + 8 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 12 | 0) >> 2] = HEAP32[($1_1 + 12 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 16 | 0) >> 2] = HEAP32[($1_1 + 16 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 20 | 0) >> 2] = HEAP32[($1_1 + 20 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 24 | 0) >> 2] = HEAP32[($1_1 + 24 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 28 | 0) >> 2] = HEAP32[($1_1 + 28 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 32 | 0) >> 2] = HEAP32[($1_1 + 32 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 36 | 0) >> 2] = HEAP32[($1_1 + 36 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 40 | 0) >> 2] = HEAP32[($1_1 + 40 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 44 | 0) >> 2] = HEAP32[($1_1 + 44 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 48 | 0) >> 2] = HEAP32[($1_1 + 48 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 52 | 0) >> 2] = HEAP32[($1_1 + 52 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 56 | 0) >> 2] = HEAP32[($1_1 + 56 | 0) >> 2] | 0;\r\n      HEAP32[($2_1 + 60 | 0) >> 2] = HEAP32[($1_1 + 60 | 0) >> 2] | 0;\r\n      $1_1 = $1_1 + 64 | 0;\r\n      $2_1 = $2_1 + 64 | 0;\r\n      if ($2_1 >>> 0 <= $5_1 >>> 0) {\r\n       continue label$9\r\n      }\r\n      break label$9;\r\n     };\r\n    }\r\n    if ($2_1 >>> 0 >= $4_1 >>> 0) {\r\n     break label$2\r\n    }\r\n    label$10 : while (1) {\r\n     HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2] | 0;\r\n     $1_1 = $1_1 + 4 | 0;\r\n     $2_1 = $2_1 + 4 | 0;\r\n     if ($2_1 >>> 0 < $4_1 >>> 0) {\r\n      continue label$10\r\n     }\r\n     break label$2;\r\n    };\r\n   }\r\n   label$11 : {\r\n    if ($3_1 >>> 0 >= 4 >>> 0) {\r\n     break label$11\r\n    }\r\n    $2_1 = $0_1;\r\n    break label$2;\r\n   }\r\n   label$12 : {\r\n    $4_1 = $3_1 + -4 | 0;\r\n    if ($0_1 >>> 0 <= $4_1 >>> 0) {\r\n     break label$12\r\n    }\r\n    $2_1 = $0_1;\r\n    break label$2;\r\n   }\r\n   $2_1 = $0_1;\r\n   label$13 : while (1) {\r\n    HEAP8[$2_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;\r\n    HEAP8[($2_1 + 1 | 0) >> 0] = HEAPU8[($1_1 + 1 | 0) >> 0] | 0;\r\n    HEAP8[($2_1 + 2 | 0) >> 0] = HEAPU8[($1_1 + 2 | 0) >> 0] | 0;\r\n    HEAP8[($2_1 + 3 | 0) >> 0] = HEAPU8[($1_1 + 3 | 0) >> 0] | 0;\r\n    $1_1 = $1_1 + 4 | 0;\r\n    $2_1 = $2_1 + 4 | 0;\r\n    if ($2_1 >>> 0 <= $4_1 >>> 0) {\r\n     continue label$13\r\n    }\r\n    break label$13;\r\n   };\r\n  }\r\n  label$14 : {\r\n   if ($2_1 >>> 0 >= $3_1 >>> 0) {\r\n    break label$14\r\n   }\r\n   label$15 : while (1) {\r\n    HEAP8[$2_1 >> 0] = HEAPU8[$1_1 >> 0] | 0;\r\n    $1_1 = $1_1 + 1 | 0;\r\n    $2_1 = $2_1 + 1 | 0;\r\n    if (($2_1 | 0) != ($3_1 | 0)) {\r\n     continue label$15\r\n    }\r\n    break label$15;\r\n   };\r\n  }\r\n  return $0_1 | 0;\r\n }\r\n \r\n function $79($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $1_1 = 0, $2_1 = 0;\r\n  label$1 : {\r\n   $1_1 = ($80($0_1 | 0) | 0) + 1 | 0;\r\n   $2_1 = $84($1_1 | 0) | 0;\r\n   if ($2_1) {\r\n    break label$1\r\n   }\r\n   return 0 | 0;\r\n  }\r\n  return $78($2_1 | 0, $0_1 | 0, $1_1 | 0) | 0 | 0;\r\n }\r\n \r\n function $80($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $1_1 = 0, $2_1 = 0, $3_1 = 0;\r\n  $1_1 = $0_1;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (!($1_1 & 3 | 0)) {\r\n     break label$2\r\n    }\r\n    label$3 : {\r\n     if (HEAPU8[$1_1 >> 0] | 0) {\r\n      break label$3\r\n     }\r\n     return $1_1 - $1_1 | 0 | 0;\r\n    }\r\n    $1_1 = $0_1;\r\n    label$4 : while (1) {\r\n     $1_1 = $1_1 + 1 | 0;\r\n     if (!($1_1 & 3 | 0)) {\r\n      break label$2\r\n     }\r\n     if (HEAPU8[$1_1 >> 0] | 0) {\r\n      continue label$4\r\n     }\r\n     break label$1;\r\n    };\r\n   }\r\n   label$5 : while (1) {\r\n    $2_1 = $1_1;\r\n    $1_1 = $1_1 + 4 | 0;\r\n    $3_1 = HEAP32[$2_1 >> 2] | 0;\r\n    if (((16843008 - $3_1 | 0 | $3_1 | 0) & -2139062144 | 0 | 0) == (-2139062144 | 0)) {\r\n     continue label$5\r\n    }\r\n    break label$5;\r\n   };\r\n   label$6 : while (1) {\r\n    $1_1 = $2_1;\r\n    $2_1 = $1_1 + 1 | 0;\r\n    if (HEAPU8[$1_1 >> 0] | 0) {\r\n     continue label$6\r\n    }\r\n    break label$6;\r\n   };\r\n  }\r\n  return $1_1 - $0_1 | 0 | 0;\r\n }\r\n \r\n function $81() {\r\n  return __wasm_memory_size() << 16 | 0 | 0;\r\n }\r\n \r\n function $82() {\r\n  return 71036 | 0;\r\n }\r\n \r\n function $83($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $1_1 = 0, $2_1 = 0;\r\n  $1_1 = HEAP32[(0 + 70568 | 0) >> 2] | 0;\r\n  $2_1 = ($0_1 + 7 | 0) & -8 | 0;\r\n  $0_1 = $1_1 + $2_1 | 0;\r\n  label$1 : {\r\n   label$2 : {\r\n    label$3 : {\r\n     if (!$2_1) {\r\n      break label$3\r\n     }\r\n     if ($0_1 >>> 0 <= $1_1 >>> 0) {\r\n      break label$2\r\n     }\r\n    }\r\n    if ($0_1 >>> 0 <= ($81() | 0) >>> 0) {\r\n     break label$1\r\n    }\r\n    if (fimport$17($0_1 | 0) | 0) {\r\n     break label$1\r\n    }\r\n   }\r\n   HEAP32[($82() | 0) >> 2] = 48;\r\n   return -1 | 0;\r\n  }\r\n  HEAP32[(0 + 70568 | 0) >> 2] = $0_1;\r\n  return $1_1 | 0;\r\n }\r\n \r\n function $84($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $5_1 = 0, $4_1 = 0, $7_1 = 0, $8_1 = 0, $3_1 = 0, $2_1 = 0, $6_1 = 0, $10_1 = 0, $11_1 = 0, i64toi32_i32$0 = 0, i64toi32_i32$1 = 0, i64toi32_i32$2 = 0, $1_1 = 0, $9_1 = 0, $79_1 = 0, $183 = 0, $774 = 0, $776 = 0;\r\n  $1_1 = global$0 - 16 | 0;\r\n  global$0 = $1_1;\r\n  label$1 : {\r\n   label$2 : {\r\n    label$3 : {\r\n     label$4 : {\r\n      label$5 : {\r\n       label$6 : {\r\n        label$7 : {\r\n         label$8 : {\r\n          label$9 : {\r\n           label$10 : {\r\n            label$11 : {\r\n             if ($0_1 >>> 0 > 244 >>> 0) {\r\n              break label$11\r\n             }\r\n             label$12 : {\r\n              $2_1 = HEAP32[(0 + 71040 | 0) >> 2] | 0;\r\n              $3_1 = $0_1 >>> 0 < 11 >>> 0 ? 16 : ($0_1 + 11 | 0) & 504 | 0;\r\n              $4_1 = $3_1 >>> 3 | 0;\r\n              $0_1 = $2_1 >>> $4_1 | 0;\r\n              if (!($0_1 & 3 | 0)) {\r\n               break label$12\r\n              }\r\n              label$13 : {\r\n               label$14 : {\r\n                $3_1 = (($0_1 ^ -1 | 0) & 1 | 0) + $4_1 | 0;\r\n                $4_1 = $3_1 << 3 | 0;\r\n                $0_1 = $4_1 + 71080 | 0;\r\n                $4_1 = HEAP32[($4_1 + 71088 | 0) >> 2] | 0;\r\n                $5_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n                if (($0_1 | 0) != ($5_1 | 0)) {\r\n                 break label$14\r\n                }\r\n                HEAP32[(0 + 71040 | 0) >> 2] = $2_1 & (__wasm_rotl_i32(-2 | 0, $3_1 | 0) | 0) | 0;\r\n                break label$13;\r\n               }\r\n               HEAP32[($5_1 + 12 | 0) >> 2] = $0_1;\r\n               HEAP32[($0_1 + 8 | 0) >> 2] = $5_1;\r\n              }\r\n              $0_1 = $4_1 + 8 | 0;\r\n              $3_1 = $3_1 << 3 | 0;\r\n              HEAP32[($4_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n              $4_1 = $4_1 + $3_1 | 0;\r\n              HEAP32[($4_1 + 4 | 0) >> 2] = HEAP32[($4_1 + 4 | 0) >> 2] | 0 | 1 | 0;\r\n              break label$1;\r\n             }\r\n             $6_1 = HEAP32[(0 + 71048 | 0) >> 2] | 0;\r\n             if ($3_1 >>> 0 <= $6_1 >>> 0) {\r\n              break label$10\r\n             }\r\n             label$15 : {\r\n              if (!$0_1) {\r\n               break label$15\r\n              }\r\n              label$16 : {\r\n               label$17 : {\r\n                $79_1 = $0_1 << $4_1 | 0;\r\n                $0_1 = 2 << $4_1 | 0;\r\n                $4_1 = __wasm_ctz_i32($79_1 & ($0_1 | (0 - $0_1 | 0) | 0) | 0 | 0) | 0;\r\n                $0_1 = $4_1 << 3 | 0;\r\n                $5_1 = $0_1 + 71080 | 0;\r\n                $0_1 = HEAP32[($0_1 + 71088 | 0) >> 2] | 0;\r\n                $7_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n                if (($5_1 | 0) != ($7_1 | 0)) {\r\n                 break label$17\r\n                }\r\n                $2_1 = $2_1 & (__wasm_rotl_i32(-2 | 0, $4_1 | 0) | 0) | 0;\r\n                HEAP32[(0 + 71040 | 0) >> 2] = $2_1;\r\n                break label$16;\r\n               }\r\n               HEAP32[($7_1 + 12 | 0) >> 2] = $5_1;\r\n               HEAP32[($5_1 + 8 | 0) >> 2] = $7_1;\r\n              }\r\n              HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n              $7_1 = $0_1 + $3_1 | 0;\r\n              $4_1 = $4_1 << 3 | 0;\r\n              $3_1 = $4_1 - $3_1 | 0;\r\n              HEAP32[($7_1 + 4 | 0) >> 2] = $3_1 | 1 | 0;\r\n              HEAP32[($0_1 + $4_1 | 0) >> 2] = $3_1;\r\n              label$18 : {\r\n               if (!$6_1) {\r\n                break label$18\r\n               }\r\n               $5_1 = ($6_1 & -8 | 0) + 71080 | 0;\r\n               $4_1 = HEAP32[(0 + 71060 | 0) >> 2] | 0;\r\n               label$19 : {\r\n                label$20 : {\r\n                 $8_1 = 1 << ($6_1 >>> 3 | 0) | 0;\r\n                 if ($2_1 & $8_1 | 0) {\r\n                  break label$20\r\n                 }\r\n                 HEAP32[(0 + 71040 | 0) >> 2] = $2_1 | $8_1 | 0;\r\n                 $8_1 = $5_1;\r\n                 break label$19;\r\n                }\r\n                $8_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;\r\n               }\r\n               HEAP32[($5_1 + 8 | 0) >> 2] = $4_1;\r\n               HEAP32[($8_1 + 12 | 0) >> 2] = $4_1;\r\n               HEAP32[($4_1 + 12 | 0) >> 2] = $5_1;\r\n               HEAP32[($4_1 + 8 | 0) >> 2] = $8_1;\r\n              }\r\n              $0_1 = $0_1 + 8 | 0;\r\n              HEAP32[(0 + 71060 | 0) >> 2] = $7_1;\r\n              HEAP32[(0 + 71048 | 0) >> 2] = $3_1;\r\n              break label$1;\r\n             }\r\n             $9_1 = HEAP32[(0 + 71044 | 0) >> 2] | 0;\r\n             if (!$9_1) {\r\n              break label$10\r\n             }\r\n             $7_1 = HEAP32[(((__wasm_ctz_i32($9_1 | 0) | 0) << 2 | 0) + 71344 | 0) >> 2] | 0;\r\n             $4_1 = ((HEAP32[($7_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;\r\n             $5_1 = $7_1;\r\n             label$21 : {\r\n              label$22 : while (1) {\r\n               label$23 : {\r\n                $0_1 = HEAP32[($5_1 + 16 | 0) >> 2] | 0;\r\n                if ($0_1) {\r\n                 break label$23\r\n                }\r\n                $0_1 = HEAP32[($5_1 + 20 | 0) >> 2] | 0;\r\n                if (!$0_1) {\r\n                 break label$21\r\n                }\r\n               }\r\n               $5_1 = ((HEAP32[($0_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;\r\n               $183 = $5_1;\r\n               $5_1 = $5_1 >>> 0 < $4_1 >>> 0;\r\n               $4_1 = $5_1 ? $183 : $4_1;\r\n               $7_1 = $5_1 ? $0_1 : $7_1;\r\n               $5_1 = $0_1;\r\n               continue label$22;\r\n              };\r\n             }\r\n             $10_1 = HEAP32[($7_1 + 24 | 0) >> 2] | 0;\r\n             label$24 : {\r\n              $0_1 = HEAP32[($7_1 + 12 | 0) >> 2] | 0;\r\n              if (($0_1 | 0) == ($7_1 | 0)) {\r\n               break label$24\r\n              }\r\n              $5_1 = HEAP32[($7_1 + 8 | 0) >> 2] | 0;\r\n              HEAP32[($5_1 + 12 | 0) >> 2] = $0_1;\r\n              HEAP32[($0_1 + 8 | 0) >> 2] = $5_1;\r\n              break label$2;\r\n             }\r\n             label$25 : {\r\n              label$26 : {\r\n               $5_1 = HEAP32[($7_1 + 20 | 0) >> 2] | 0;\r\n               if (!$5_1) {\r\n                break label$26\r\n               }\r\n               $8_1 = $7_1 + 20 | 0;\r\n               break label$25;\r\n              }\r\n              $5_1 = HEAP32[($7_1 + 16 | 0) >> 2] | 0;\r\n              if (!$5_1) {\r\n               break label$9\r\n              }\r\n              $8_1 = $7_1 + 16 | 0;\r\n             }\r\n             label$27 : while (1) {\r\n              $11_1 = $8_1;\r\n              $0_1 = $5_1;\r\n              $8_1 = $0_1 + 20 | 0;\r\n              $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;\r\n              if ($5_1) {\r\n               continue label$27\r\n              }\r\n              $8_1 = $0_1 + 16 | 0;\r\n              $5_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;\r\n              if ($5_1) {\r\n               continue label$27\r\n              }\r\n              break label$27;\r\n             };\r\n             HEAP32[$11_1 >> 2] = 0;\r\n             break label$2;\r\n            }\r\n            $3_1 = -1;\r\n            if ($0_1 >>> 0 > -65 >>> 0) {\r\n             break label$10\r\n            }\r\n            $4_1 = $0_1 + 11 | 0;\r\n            $3_1 = $4_1 & -8 | 0;\r\n            $10_1 = HEAP32[(0 + 71044 | 0) >> 2] | 0;\r\n            if (!$10_1) {\r\n             break label$10\r\n            }\r\n            $6_1 = 31;\r\n            label$28 : {\r\n             if ($0_1 >>> 0 > 16777204 >>> 0) {\r\n              break label$28\r\n             }\r\n             $0_1 = Math_clz32($4_1 >>> 8 | 0);\r\n             $6_1 = ((($3_1 >>> (38 - $0_1 | 0) | 0) & 1 | 0) - ($0_1 << 1 | 0) | 0) + 62 | 0;\r\n            }\r\n            $4_1 = 0 - $3_1 | 0;\r\n            label$29 : {\r\n             label$30 : {\r\n              label$31 : {\r\n               label$32 : {\r\n                $5_1 = HEAP32[(($6_1 << 2 | 0) + 71344 | 0) >> 2] | 0;\r\n                if ($5_1) {\r\n                 break label$32\r\n                }\r\n                $0_1 = 0;\r\n                $8_1 = 0;\r\n                break label$31;\r\n               }\r\n               $0_1 = 0;\r\n               $7_1 = $3_1 << (($6_1 | 0) == (31 | 0) ? 0 : 25 - ($6_1 >>> 1 | 0) | 0) | 0;\r\n               $8_1 = 0;\r\n               label$33 : while (1) {\r\n                label$34 : {\r\n                 $2_1 = ((HEAP32[($5_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;\r\n                 if ($2_1 >>> 0 >= $4_1 >>> 0) {\r\n                  break label$34\r\n                 }\r\n                 $4_1 = $2_1;\r\n                 $8_1 = $5_1;\r\n                 if ($4_1) {\r\n                  break label$34\r\n                 }\r\n                 $4_1 = 0;\r\n                 $8_1 = $5_1;\r\n                 $0_1 = $5_1;\r\n                 break label$30;\r\n                }\r\n                $2_1 = HEAP32[($5_1 + 20 | 0) >> 2] | 0;\r\n                $11_1 = HEAP32[(($5_1 + (($7_1 >>> 29 | 0) & 4 | 0) | 0) + 16 | 0) >> 2] | 0;\r\n                $0_1 = $2_1 ? (($2_1 | 0) == ($11_1 | 0) ? $0_1 : $2_1) : $0_1;\r\n                $7_1 = $7_1 << 1 | 0;\r\n                $5_1 = $11_1;\r\n                if ($5_1) {\r\n                 continue label$33\r\n                }\r\n                break label$33;\r\n               };\r\n              }\r\n              label$35 : {\r\n               if ($0_1 | $8_1 | 0) {\r\n                break label$35\r\n               }\r\n               $8_1 = 0;\r\n               $0_1 = 2 << $6_1 | 0;\r\n               $0_1 = ($0_1 | (0 - $0_1 | 0) | 0) & $10_1 | 0;\r\n               if (!$0_1) {\r\n                break label$10\r\n               }\r\n               $0_1 = HEAP32[(((__wasm_ctz_i32($0_1 | 0) | 0) << 2 | 0) + 71344 | 0) >> 2] | 0;\r\n              }\r\n              if (!$0_1) {\r\n               break label$29\r\n              }\r\n             }\r\n             label$36 : while (1) {\r\n              $2_1 = ((HEAP32[($0_1 + 4 | 0) >> 2] | 0) & -8 | 0) - $3_1 | 0;\r\n              $7_1 = $2_1 >>> 0 < $4_1 >>> 0;\r\n              label$37 : {\r\n               $5_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;\r\n               if ($5_1) {\r\n                break label$37\r\n               }\r\n               $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;\r\n              }\r\n              $4_1 = $7_1 ? $2_1 : $4_1;\r\n              $8_1 = $7_1 ? $0_1 : $8_1;\r\n              $0_1 = $5_1;\r\n              if ($0_1) {\r\n               continue label$36\r\n              }\r\n              break label$36;\r\n             };\r\n            }\r\n            if (!$8_1) {\r\n             break label$10\r\n            }\r\n            if ($4_1 >>> 0 >= ((HEAP32[(0 + 71048 | 0) >> 2] | 0) - $3_1 | 0) >>> 0) {\r\n             break label$10\r\n            }\r\n            $11_1 = HEAP32[($8_1 + 24 | 0) >> 2] | 0;\r\n            label$38 : {\r\n             $0_1 = HEAP32[($8_1 + 12 | 0) >> 2] | 0;\r\n             if (($0_1 | 0) == ($8_1 | 0)) {\r\n              break label$38\r\n             }\r\n             $5_1 = HEAP32[($8_1 + 8 | 0) >> 2] | 0;\r\n             HEAP32[($5_1 + 12 | 0) >> 2] = $0_1;\r\n             HEAP32[($0_1 + 8 | 0) >> 2] = $5_1;\r\n             break label$3;\r\n            }\r\n            label$39 : {\r\n             label$40 : {\r\n              $5_1 = HEAP32[($8_1 + 20 | 0) >> 2] | 0;\r\n              if (!$5_1) {\r\n               break label$40\r\n              }\r\n              $7_1 = $8_1 + 20 | 0;\r\n              break label$39;\r\n             }\r\n             $5_1 = HEAP32[($8_1 + 16 | 0) >> 2] | 0;\r\n             if (!$5_1) {\r\n              break label$8\r\n             }\r\n             $7_1 = $8_1 + 16 | 0;\r\n            }\r\n            label$41 : while (1) {\r\n             $2_1 = $7_1;\r\n             $0_1 = $5_1;\r\n             $7_1 = $0_1 + 20 | 0;\r\n             $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;\r\n             if ($5_1) {\r\n              continue label$41\r\n             }\r\n             $7_1 = $0_1 + 16 | 0;\r\n             $5_1 = HEAP32[($0_1 + 16 | 0) >> 2] | 0;\r\n             if ($5_1) {\r\n              continue label$41\r\n             }\r\n             break label$41;\r\n            };\r\n            HEAP32[$2_1 >> 2] = 0;\r\n            break label$3;\r\n           }\r\n           label$42 : {\r\n            $0_1 = HEAP32[(0 + 71048 | 0) >> 2] | 0;\r\n            if ($0_1 >>> 0 < $3_1 >>> 0) {\r\n             break label$42\r\n            }\r\n            $4_1 = HEAP32[(0 + 71060 | 0) >> 2] | 0;\r\n            label$43 : {\r\n             label$44 : {\r\n              $5_1 = $0_1 - $3_1 | 0;\r\n              if ($5_1 >>> 0 < 16 >>> 0) {\r\n               break label$44\r\n              }\r\n              $7_1 = $4_1 + $3_1 | 0;\r\n              HEAP32[($7_1 + 4 | 0) >> 2] = $5_1 | 1 | 0;\r\n              HEAP32[($4_1 + $0_1 | 0) >> 2] = $5_1;\r\n              HEAP32[($4_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n              break label$43;\r\n             }\r\n             HEAP32[($4_1 + 4 | 0) >> 2] = $0_1 | 3 | 0;\r\n             $0_1 = $4_1 + $0_1 | 0;\r\n             HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 1 | 0;\r\n             $7_1 = 0;\r\n             $5_1 = 0;\r\n            }\r\n            HEAP32[(0 + 71048 | 0) >> 2] = $5_1;\r\n            HEAP32[(0 + 71060 | 0) >> 2] = $7_1;\r\n            $0_1 = $4_1 + 8 | 0;\r\n            break label$1;\r\n           }\r\n           label$45 : {\r\n            $7_1 = HEAP32[(0 + 71052 | 0) >> 2] | 0;\r\n            if ($7_1 >>> 0 <= $3_1 >>> 0) {\r\n             break label$45\r\n            }\r\n            $4_1 = $7_1 - $3_1 | 0;\r\n            HEAP32[(0 + 71052 | 0) >> 2] = $4_1;\r\n            $0_1 = HEAP32[(0 + 71064 | 0) >> 2] | 0;\r\n            $5_1 = $0_1 + $3_1 | 0;\r\n            HEAP32[(0 + 71064 | 0) >> 2] = $5_1;\r\n            HEAP32[($5_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;\r\n            HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n            $0_1 = $0_1 + 8 | 0;\r\n            break label$1;\r\n           }\r\n           label$46 : {\r\n            label$47 : {\r\n             if (!(HEAP32[(0 + 71512 | 0) >> 2] | 0)) {\r\n              break label$47\r\n             }\r\n             $4_1 = HEAP32[(0 + 71520 | 0) >> 2] | 0;\r\n             break label$46;\r\n            }\r\n            i64toi32_i32$1 = 0;\r\n            i64toi32_i32$0 = -1;\r\n            HEAP32[(i64toi32_i32$1 + 71524 | 0) >> 2] = -1;\r\n            HEAP32[(i64toi32_i32$1 + 71528 | 0) >> 2] = i64toi32_i32$0;\r\n            i64toi32_i32$1 = 0;\r\n            i64toi32_i32$0 = 4096;\r\n            HEAP32[(i64toi32_i32$1 + 71516 | 0) >> 2] = 4096;\r\n            HEAP32[(i64toi32_i32$1 + 71520 | 0) >> 2] = i64toi32_i32$0;\r\n            HEAP32[(0 + 71512 | 0) >> 2] = (($1_1 + 12 | 0) & -16 | 0) ^ 1431655768 | 0;\r\n            HEAP32[(0 + 71532 | 0) >> 2] = 0;\r\n            HEAP32[(0 + 71484 | 0) >> 2] = 0;\r\n            $4_1 = 4096;\r\n           }\r\n           $0_1 = 0;\r\n           $6_1 = $3_1 + 47 | 0;\r\n           $2_1 = $4_1 + $6_1 | 0;\r\n           $11_1 = 0 - $4_1 | 0;\r\n           $8_1 = $2_1 & $11_1 | 0;\r\n           if ($8_1 >>> 0 <= $3_1 >>> 0) {\r\n            break label$1\r\n           }\r\n           $0_1 = 0;\r\n           label$48 : {\r\n            $4_1 = HEAP32[(0 + 71480 | 0) >> 2] | 0;\r\n            if (!$4_1) {\r\n             break label$48\r\n            }\r\n            $5_1 = HEAP32[(0 + 71472 | 0) >> 2] | 0;\r\n            $10_1 = $5_1 + $8_1 | 0;\r\n            if ($10_1 >>> 0 <= $5_1 >>> 0) {\r\n             break label$1\r\n            }\r\n            if ($10_1 >>> 0 > $4_1 >>> 0) {\r\n             break label$1\r\n            }\r\n           }\r\n           label$49 : {\r\n            label$50 : {\r\n             if ((HEAPU8[(0 + 71484 | 0) >> 0] | 0) & 4 | 0) {\r\n              break label$50\r\n             }\r\n             label$51 : {\r\n              label$52 : {\r\n               label$53 : {\r\n                label$54 : {\r\n                 label$55 : {\r\n                  $4_1 = HEAP32[(0 + 71064 | 0) >> 2] | 0;\r\n                  if (!$4_1) {\r\n                   break label$55\r\n                  }\r\n                  $0_1 = 71488;\r\n                  label$56 : while (1) {\r\n                   label$57 : {\r\n                    $5_1 = HEAP32[$0_1 >> 2] | 0;\r\n                    if ($4_1 >>> 0 < $5_1 >>> 0) {\r\n                     break label$57\r\n                    }\r\n                    if ($4_1 >>> 0 < ($5_1 + (HEAP32[($0_1 + 4 | 0) >> 2] | 0) | 0) >>> 0) {\r\n                     break label$54\r\n                    }\r\n                   }\r\n                   $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n                   if ($0_1) {\r\n                    continue label$56\r\n                   }\r\n                   break label$56;\r\n                  };\r\n                 }\r\n                 $7_1 = $83(0 | 0) | 0;\r\n                 if (($7_1 | 0) == (-1 | 0)) {\r\n                  break label$51\r\n                 }\r\n                 $2_1 = $8_1;\r\n                 label$58 : {\r\n                  $0_1 = HEAP32[(0 + 71516 | 0) >> 2] | 0;\r\n                  $4_1 = $0_1 + -1 | 0;\r\n                  if (!($4_1 & $7_1 | 0)) {\r\n                   break label$58\r\n                  }\r\n                  $2_1 = ($8_1 - $7_1 | 0) + (($4_1 + $7_1 | 0) & (0 - $0_1 | 0) | 0) | 0;\r\n                 }\r\n                 if ($2_1 >>> 0 <= $3_1 >>> 0) {\r\n                  break label$51\r\n                 }\r\n                 label$59 : {\r\n                  $0_1 = HEAP32[(0 + 71480 | 0) >> 2] | 0;\r\n                  if (!$0_1) {\r\n                   break label$59\r\n                  }\r\n                  $4_1 = HEAP32[(0 + 71472 | 0) >> 2] | 0;\r\n                  $5_1 = $4_1 + $2_1 | 0;\r\n                  if ($5_1 >>> 0 <= $4_1 >>> 0) {\r\n                   break label$51\r\n                  }\r\n                  if ($5_1 >>> 0 > $0_1 >>> 0) {\r\n                   break label$51\r\n                  }\r\n                 }\r\n                 $0_1 = $83($2_1 | 0) | 0;\r\n                 if (($0_1 | 0) != ($7_1 | 0)) {\r\n                  break label$53\r\n                 }\r\n                 break label$49;\r\n                }\r\n                $2_1 = ($2_1 - $7_1 | 0) & $11_1 | 0;\r\n                $7_1 = $83($2_1 | 0) | 0;\r\n                if (($7_1 | 0) == ((HEAP32[$0_1 >> 2] | 0) + (HEAP32[($0_1 + 4 | 0) >> 2] | 0) | 0 | 0)) {\r\n                 break label$52\r\n                }\r\n                $0_1 = $7_1;\r\n               }\r\n               if (($0_1 | 0) == (-1 | 0)) {\r\n                break label$51\r\n               }\r\n               label$60 : {\r\n                if ($2_1 >>> 0 < ($3_1 + 48 | 0) >>> 0) {\r\n                 break label$60\r\n                }\r\n                $7_1 = $0_1;\r\n                break label$49;\r\n               }\r\n               $4_1 = HEAP32[(0 + 71520 | 0) >> 2] | 0;\r\n               $4_1 = (($6_1 - $2_1 | 0) + $4_1 | 0) & (0 - $4_1 | 0) | 0;\r\n               if (($83($4_1 | 0) | 0 | 0) == (-1 | 0)) {\r\n                break label$51\r\n               }\r\n               $2_1 = $4_1 + $2_1 | 0;\r\n               $7_1 = $0_1;\r\n               break label$49;\r\n              }\r\n              if (($7_1 | 0) != (-1 | 0)) {\r\n               break label$49\r\n              }\r\n             }\r\n             HEAP32[(0 + 71484 | 0) >> 2] = HEAP32[(0 + 71484 | 0) >> 2] | 0 | 4 | 0;\r\n            }\r\n            $7_1 = $83($8_1 | 0) | 0;\r\n            $0_1 = $83(0 | 0) | 0;\r\n            if (($7_1 | 0) == (-1 | 0)) {\r\n             break label$5\r\n            }\r\n            if (($0_1 | 0) == (-1 | 0)) {\r\n             break label$5\r\n            }\r\n            if ($7_1 >>> 0 >= $0_1 >>> 0) {\r\n             break label$5\r\n            }\r\n            $2_1 = $0_1 - $7_1 | 0;\r\n            if ($2_1 >>> 0 <= ($3_1 + 40 | 0) >>> 0) {\r\n             break label$5\r\n            }\r\n           }\r\n           $0_1 = (HEAP32[(0 + 71472 | 0) >> 2] | 0) + $2_1 | 0;\r\n           HEAP32[(0 + 71472 | 0) >> 2] = $0_1;\r\n           label$61 : {\r\n            if ($0_1 >>> 0 <= (HEAP32[(0 + 71476 | 0) >> 2] | 0) >>> 0) {\r\n             break label$61\r\n            }\r\n            HEAP32[(0 + 71476 | 0) >> 2] = $0_1;\r\n           }\r\n           label$62 : {\r\n            label$63 : {\r\n             $4_1 = HEAP32[(0 + 71064 | 0) >> 2] | 0;\r\n             if (!$4_1) {\r\n              break label$63\r\n             }\r\n             $0_1 = 71488;\r\n             label$64 : while (1) {\r\n              $5_1 = HEAP32[$0_1 >> 2] | 0;\r\n              $8_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;\r\n              if (($7_1 | 0) == ($5_1 + $8_1 | 0 | 0)) {\r\n               break label$62\r\n              }\r\n              $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n              if ($0_1) {\r\n               continue label$64\r\n              }\r\n              break label$7;\r\n             };\r\n            }\r\n            label$65 : {\r\n             label$66 : {\r\n              $0_1 = HEAP32[(0 + 71056 | 0) >> 2] | 0;\r\n              if (!$0_1) {\r\n               break label$66\r\n              }\r\n              if ($7_1 >>> 0 >= $0_1 >>> 0) {\r\n               break label$65\r\n              }\r\n             }\r\n             HEAP32[(0 + 71056 | 0) >> 2] = $7_1;\r\n            }\r\n            $0_1 = 0;\r\n            HEAP32[(0 + 71492 | 0) >> 2] = $2_1;\r\n            HEAP32[(0 + 71488 | 0) >> 2] = $7_1;\r\n            HEAP32[(0 + 71072 | 0) >> 2] = -1;\r\n            HEAP32[(0 + 71076 | 0) >> 2] = HEAP32[(0 + 71512 | 0) >> 2] | 0;\r\n            HEAP32[(0 + 71500 | 0) >> 2] = 0;\r\n            label$67 : while (1) {\r\n             $4_1 = $0_1 << 3 | 0;\r\n             $5_1 = $4_1 + 71080 | 0;\r\n             HEAP32[($4_1 + 71088 | 0) >> 2] = $5_1;\r\n             HEAP32[($4_1 + 71092 | 0) >> 2] = $5_1;\r\n             $0_1 = $0_1 + 1 | 0;\r\n             if (($0_1 | 0) != (32 | 0)) {\r\n              continue label$67\r\n             }\r\n             break label$67;\r\n            };\r\n            $0_1 = $2_1 + -40 | 0;\r\n            $4_1 = (-8 - $7_1 | 0) & 7 | 0;\r\n            $5_1 = $0_1 - $4_1 | 0;\r\n            HEAP32[(0 + 71052 | 0) >> 2] = $5_1;\r\n            $4_1 = $7_1 + $4_1 | 0;\r\n            HEAP32[(0 + 71064 | 0) >> 2] = $4_1;\r\n            HEAP32[($4_1 + 4 | 0) >> 2] = $5_1 | 1 | 0;\r\n            HEAP32[(($7_1 + $0_1 | 0) + 4 | 0) >> 2] = 40;\r\n            HEAP32[(0 + 71068 | 0) >> 2] = HEAP32[(0 + 71528 | 0) >> 2] | 0;\r\n            break label$6;\r\n           }\r\n           if ($4_1 >>> 0 >= $7_1 >>> 0) {\r\n            break label$7\r\n           }\r\n           if ($4_1 >>> 0 < $5_1 >>> 0) {\r\n            break label$7\r\n           }\r\n           if ((HEAP32[($0_1 + 12 | 0) >> 2] | 0) & 8 | 0) {\r\n            break label$7\r\n           }\r\n           HEAP32[($0_1 + 4 | 0) >> 2] = $8_1 + $2_1 | 0;\r\n           $0_1 = (-8 - $4_1 | 0) & 7 | 0;\r\n           $5_1 = $4_1 + $0_1 | 0;\r\n           HEAP32[(0 + 71064 | 0) >> 2] = $5_1;\r\n           $7_1 = (HEAP32[(0 + 71052 | 0) >> 2] | 0) + $2_1 | 0;\r\n           $0_1 = $7_1 - $0_1 | 0;\r\n           HEAP32[(0 + 71052 | 0) >> 2] = $0_1;\r\n           HEAP32[($5_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n           HEAP32[(($4_1 + $7_1 | 0) + 4 | 0) >> 2] = 40;\r\n           HEAP32[(0 + 71068 | 0) >> 2] = HEAP32[(0 + 71528 | 0) >> 2] | 0;\r\n           break label$6;\r\n          }\r\n          $0_1 = 0;\r\n          break label$2;\r\n         }\r\n         $0_1 = 0;\r\n         break label$3;\r\n        }\r\n        label$68 : {\r\n         if ($7_1 >>> 0 >= (HEAP32[(0 + 71056 | 0) >> 2] | 0) >>> 0) {\r\n          break label$68\r\n         }\r\n         HEAP32[(0 + 71056 | 0) >> 2] = $7_1;\r\n        }\r\n        $5_1 = $7_1 + $2_1 | 0;\r\n        $0_1 = 71488;\r\n        label$69 : {\r\n         label$70 : {\r\n          label$71 : while (1) {\r\n           $8_1 = HEAP32[$0_1 >> 2] | 0;\r\n           if (($8_1 | 0) == ($5_1 | 0)) {\r\n            break label$70\r\n           }\r\n           $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n           if ($0_1) {\r\n            continue label$71\r\n           }\r\n           break label$69;\r\n          };\r\n         }\r\n         if (!((HEAPU8[($0_1 + 12 | 0) >> 0] | 0) & 8 | 0)) {\r\n          break label$4\r\n         }\r\n        }\r\n        $0_1 = 71488;\r\n        label$72 : {\r\n         label$73 : while (1) {\r\n          label$74 : {\r\n           $5_1 = HEAP32[$0_1 >> 2] | 0;\r\n           if ($4_1 >>> 0 < $5_1 >>> 0) {\r\n            break label$74\r\n           }\r\n           $5_1 = $5_1 + (HEAP32[($0_1 + 4 | 0) >> 2] | 0) | 0;\r\n           if ($4_1 >>> 0 < $5_1 >>> 0) {\r\n            break label$72\r\n           }\r\n          }\r\n          $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n          continue label$73;\r\n         };\r\n        }\r\n        $0_1 = $2_1 + -40 | 0;\r\n        $8_1 = (-8 - $7_1 | 0) & 7 | 0;\r\n        $11_1 = $0_1 - $8_1 | 0;\r\n        HEAP32[(0 + 71052 | 0) >> 2] = $11_1;\r\n        $8_1 = $7_1 + $8_1 | 0;\r\n        HEAP32[(0 + 71064 | 0) >> 2] = $8_1;\r\n        HEAP32[($8_1 + 4 | 0) >> 2] = $11_1 | 1 | 0;\r\n        HEAP32[(($7_1 + $0_1 | 0) + 4 | 0) >> 2] = 40;\r\n        HEAP32[(0 + 71068 | 0) >> 2] = HEAP32[(0 + 71528 | 0) >> 2] | 0;\r\n        $0_1 = ($5_1 + ((39 - $5_1 | 0) & 7 | 0) | 0) + -47 | 0;\r\n        $8_1 = $0_1 >>> 0 < ($4_1 + 16 | 0) >>> 0 ? $4_1 : $0_1;\r\n        HEAP32[($8_1 + 4 | 0) >> 2] = 27;\r\n        i64toi32_i32$2 = 0;\r\n        i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 71496 | 0) >> 2] | 0;\r\n        i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 71500 | 0) >> 2] | 0;\r\n        $774 = i64toi32_i32$0;\r\n        i64toi32_i32$0 = $8_1 + 16 | 0;\r\n        HEAP32[i64toi32_i32$0 >> 2] = $774;\r\n        HEAP32[(i64toi32_i32$0 + 4 | 0) >> 2] = i64toi32_i32$1;\r\n        i64toi32_i32$2 = 0;\r\n        i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 71488 | 0) >> 2] | 0;\r\n        i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 71492 | 0) >> 2] | 0;\r\n        $776 = i64toi32_i32$1;\r\n        i64toi32_i32$1 = $8_1;\r\n        HEAP32[($8_1 + 8 | 0) >> 2] = $776;\r\n        HEAP32[($8_1 + 12 | 0) >> 2] = i64toi32_i32$0;\r\n        HEAP32[(0 + 71496 | 0) >> 2] = $8_1 + 8 | 0;\r\n        HEAP32[(0 + 71492 | 0) >> 2] = $2_1;\r\n        HEAP32[(0 + 71488 | 0) >> 2] = $7_1;\r\n        HEAP32[(0 + 71500 | 0) >> 2] = 0;\r\n        $0_1 = $8_1 + 24 | 0;\r\n        label$75 : while (1) {\r\n         HEAP32[($0_1 + 4 | 0) >> 2] = 7;\r\n         $7_1 = $0_1 + 8 | 0;\r\n         $0_1 = $0_1 + 4 | 0;\r\n         if ($7_1 >>> 0 < $5_1 >>> 0) {\r\n          continue label$75\r\n         }\r\n         break label$75;\r\n        };\r\n        if (($8_1 | 0) == ($4_1 | 0)) {\r\n         break label$6\r\n        }\r\n        HEAP32[($8_1 + 4 | 0) >> 2] = (HEAP32[($8_1 + 4 | 0) >> 2] | 0) & -2 | 0;\r\n        $7_1 = $8_1 - $4_1 | 0;\r\n        HEAP32[($4_1 + 4 | 0) >> 2] = $7_1 | 1 | 0;\r\n        HEAP32[$8_1 >> 2] = $7_1;\r\n        label$76 : {\r\n         label$77 : {\r\n          if ($7_1 >>> 0 > 255 >>> 0) {\r\n           break label$77\r\n          }\r\n          $0_1 = ($7_1 & -8 | 0) + 71080 | 0;\r\n          label$78 : {\r\n           label$79 : {\r\n            $5_1 = HEAP32[(0 + 71040 | 0) >> 2] | 0;\r\n            $7_1 = 1 << ($7_1 >>> 3 | 0) | 0;\r\n            if ($5_1 & $7_1 | 0) {\r\n             break label$79\r\n            }\r\n            HEAP32[(0 + 71040 | 0) >> 2] = $5_1 | $7_1 | 0;\r\n            $5_1 = $0_1;\r\n            break label$78;\r\n           }\r\n           $5_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n          }\r\n          HEAP32[($0_1 + 8 | 0) >> 2] = $4_1;\r\n          HEAP32[($5_1 + 12 | 0) >> 2] = $4_1;\r\n          $7_1 = 12;\r\n          $8_1 = 8;\r\n          break label$76;\r\n         }\r\n         $0_1 = 31;\r\n         label$80 : {\r\n          if ($7_1 >>> 0 > 16777215 >>> 0) {\r\n           break label$80\r\n          }\r\n          $0_1 = Math_clz32($7_1 >>> 8 | 0);\r\n          $0_1 = ((($7_1 >>> (38 - $0_1 | 0) | 0) & 1 | 0) - ($0_1 << 1 | 0) | 0) + 62 | 0;\r\n         }\r\n         HEAP32[($4_1 + 28 | 0) >> 2] = $0_1;\r\n         i64toi32_i32$1 = $4_1;\r\n         i64toi32_i32$0 = 0;\r\n         HEAP32[($4_1 + 16 | 0) >> 2] = 0;\r\n         HEAP32[($4_1 + 20 | 0) >> 2] = i64toi32_i32$0;\r\n         $5_1 = ($0_1 << 2 | 0) + 71344 | 0;\r\n         label$81 : {\r\n          label$82 : {\r\n           label$83 : {\r\n            $8_1 = HEAP32[(0 + 71044 | 0) >> 2] | 0;\r\n            $2_1 = 1 << $0_1 | 0;\r\n            if ($8_1 & $2_1 | 0) {\r\n             break label$83\r\n            }\r\n            HEAP32[(0 + 71044 | 0) >> 2] = $8_1 | $2_1 | 0;\r\n            HEAP32[$5_1 >> 2] = $4_1;\r\n            HEAP32[($4_1 + 24 | 0) >> 2] = $5_1;\r\n            break label$82;\r\n           }\r\n           $0_1 = $7_1 << (($0_1 | 0) == (31 | 0) ? 0 : 25 - ($0_1 >>> 1 | 0) | 0) | 0;\r\n           $8_1 = HEAP32[$5_1 >> 2] | 0;\r\n           label$84 : while (1) {\r\n            $5_1 = $8_1;\r\n            if (((HEAP32[($5_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($7_1 | 0)) {\r\n             break label$81\r\n            }\r\n            $8_1 = $0_1 >>> 29 | 0;\r\n            $0_1 = $0_1 << 1 | 0;\r\n            $2_1 = $5_1 + ($8_1 & 4 | 0) | 0;\r\n            $8_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;\r\n            if ($8_1) {\r\n             continue label$84\r\n            }\r\n            break label$84;\r\n           };\r\n           HEAP32[($2_1 + 16 | 0) >> 2] = $4_1;\r\n           HEAP32[($4_1 + 24 | 0) >> 2] = $5_1;\r\n          }\r\n          $7_1 = 8;\r\n          $8_1 = 12;\r\n          $5_1 = $4_1;\r\n          $0_1 = $4_1;\r\n          break label$76;\r\n         }\r\n         $0_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;\r\n         HEAP32[($0_1 + 12 | 0) >> 2] = $4_1;\r\n         HEAP32[($5_1 + 8 | 0) >> 2] = $4_1;\r\n         HEAP32[($4_1 + 8 | 0) >> 2] = $0_1;\r\n         $0_1 = 0;\r\n         $7_1 = 24;\r\n         $8_1 = 12;\r\n        }\r\n        HEAP32[($4_1 + $8_1 | 0) >> 2] = $5_1;\r\n        HEAP32[($4_1 + $7_1 | 0) >> 2] = $0_1;\r\n       }\r\n       $0_1 = HEAP32[(0 + 71052 | 0) >> 2] | 0;\r\n       if ($0_1 >>> 0 <= $3_1 >>> 0) {\r\n        break label$5\r\n       }\r\n       $4_1 = $0_1 - $3_1 | 0;\r\n       HEAP32[(0 + 71052 | 0) >> 2] = $4_1;\r\n       $0_1 = HEAP32[(0 + 71064 | 0) >> 2] | 0;\r\n       $5_1 = $0_1 + $3_1 | 0;\r\n       HEAP32[(0 + 71064 | 0) >> 2] = $5_1;\r\n       HEAP32[($5_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;\r\n       HEAP32[($0_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n       $0_1 = $0_1 + 8 | 0;\r\n       break label$1;\r\n      }\r\n      HEAP32[($82() | 0) >> 2] = 48;\r\n      $0_1 = 0;\r\n      break label$1;\r\n     }\r\n     HEAP32[$0_1 >> 2] = $7_1;\r\n     HEAP32[($0_1 + 4 | 0) >> 2] = (HEAP32[($0_1 + 4 | 0) >> 2] | 0) + $2_1 | 0;\r\n     $0_1 = $85($7_1 | 0, $8_1 | 0, $3_1 | 0) | 0;\r\n     break label$1;\r\n    }\r\n    label$85 : {\r\n     if (!$11_1) {\r\n      break label$85\r\n     }\r\n     label$86 : {\r\n      label$87 : {\r\n       $7_1 = HEAP32[($8_1 + 28 | 0) >> 2] | 0;\r\n       $5_1 = ($7_1 << 2 | 0) + 71344 | 0;\r\n       if (($8_1 | 0) != (HEAP32[$5_1 >> 2] | 0 | 0)) {\r\n        break label$87\r\n       }\r\n       HEAP32[$5_1 >> 2] = $0_1;\r\n       if ($0_1) {\r\n        break label$86\r\n       }\r\n       $10_1 = $10_1 & (__wasm_rotl_i32(-2 | 0, $7_1 | 0) | 0) | 0;\r\n       HEAP32[(0 + 71044 | 0) >> 2] = $10_1;\r\n       break label$85;\r\n      }\r\n      label$88 : {\r\n       label$89 : {\r\n        if ((HEAP32[($11_1 + 16 | 0) >> 2] | 0 | 0) != ($8_1 | 0)) {\r\n         break label$89\r\n        }\r\n        HEAP32[($11_1 + 16 | 0) >> 2] = $0_1;\r\n        break label$88;\r\n       }\r\n       HEAP32[($11_1 + 20 | 0) >> 2] = $0_1;\r\n      }\r\n      if (!$0_1) {\r\n       break label$85\r\n      }\r\n     }\r\n     HEAP32[($0_1 + 24 | 0) >> 2] = $11_1;\r\n     label$90 : {\r\n      $5_1 = HEAP32[($8_1 + 16 | 0) >> 2] | 0;\r\n      if (!$5_1) {\r\n       break label$90\r\n      }\r\n      HEAP32[($0_1 + 16 | 0) >> 2] = $5_1;\r\n      HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;\r\n     }\r\n     $5_1 = HEAP32[($8_1 + 20 | 0) >> 2] | 0;\r\n     if (!$5_1) {\r\n      break label$85\r\n     }\r\n     HEAP32[($0_1 + 20 | 0) >> 2] = $5_1;\r\n     HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;\r\n    }\r\n    label$91 : {\r\n     label$92 : {\r\n      if ($4_1 >>> 0 > 15 >>> 0) {\r\n       break label$92\r\n      }\r\n      $0_1 = $4_1 + $3_1 | 0;\r\n      HEAP32[($8_1 + 4 | 0) >> 2] = $0_1 | 3 | 0;\r\n      $0_1 = $8_1 + $0_1 | 0;\r\n      HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 1 | 0;\r\n      break label$91;\r\n     }\r\n     HEAP32[($8_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n     $7_1 = $8_1 + $3_1 | 0;\r\n     HEAP32[($7_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;\r\n     HEAP32[($7_1 + $4_1 | 0) >> 2] = $4_1;\r\n     label$93 : {\r\n      if ($4_1 >>> 0 > 255 >>> 0) {\r\n       break label$93\r\n      }\r\n      $0_1 = ($4_1 & -8 | 0) + 71080 | 0;\r\n      label$94 : {\r\n       label$95 : {\r\n        $3_1 = HEAP32[(0 + 71040 | 0) >> 2] | 0;\r\n        $4_1 = 1 << ($4_1 >>> 3 | 0) | 0;\r\n        if ($3_1 & $4_1 | 0) {\r\n         break label$95\r\n        }\r\n        HEAP32[(0 + 71040 | 0) >> 2] = $3_1 | $4_1 | 0;\r\n        $4_1 = $0_1;\r\n        break label$94;\r\n       }\r\n       $4_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n      }\r\n      HEAP32[($0_1 + 8 | 0) >> 2] = $7_1;\r\n      HEAP32[($4_1 + 12 | 0) >> 2] = $7_1;\r\n      HEAP32[($7_1 + 12 | 0) >> 2] = $0_1;\r\n      HEAP32[($7_1 + 8 | 0) >> 2] = $4_1;\r\n      break label$91;\r\n     }\r\n     $0_1 = 31;\r\n     label$96 : {\r\n      if ($4_1 >>> 0 > 16777215 >>> 0) {\r\n       break label$96\r\n      }\r\n      $0_1 = Math_clz32($4_1 >>> 8 | 0);\r\n      $0_1 = ((($4_1 >>> (38 - $0_1 | 0) | 0) & 1 | 0) - ($0_1 << 1 | 0) | 0) + 62 | 0;\r\n     }\r\n     HEAP32[($7_1 + 28 | 0) >> 2] = $0_1;\r\n     i64toi32_i32$1 = $7_1;\r\n     i64toi32_i32$0 = 0;\r\n     HEAP32[($7_1 + 16 | 0) >> 2] = 0;\r\n     HEAP32[($7_1 + 20 | 0) >> 2] = i64toi32_i32$0;\r\n     $3_1 = ($0_1 << 2 | 0) + 71344 | 0;\r\n     label$97 : {\r\n      label$98 : {\r\n       label$99 : {\r\n        $5_1 = 1 << $0_1 | 0;\r\n        if ($10_1 & $5_1 | 0) {\r\n         break label$99\r\n        }\r\n        HEAP32[(0 + 71044 | 0) >> 2] = $10_1 | $5_1 | 0;\r\n        HEAP32[$3_1 >> 2] = $7_1;\r\n        HEAP32[($7_1 + 24 | 0) >> 2] = $3_1;\r\n        break label$98;\r\n       }\r\n       $0_1 = $4_1 << (($0_1 | 0) == (31 | 0) ? 0 : 25 - ($0_1 >>> 1 | 0) | 0) | 0;\r\n       $5_1 = HEAP32[$3_1 >> 2] | 0;\r\n       label$100 : while (1) {\r\n        $3_1 = $5_1;\r\n        if (((HEAP32[($5_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($4_1 | 0)) {\r\n         break label$97\r\n        }\r\n        $5_1 = $0_1 >>> 29 | 0;\r\n        $0_1 = $0_1 << 1 | 0;\r\n        $2_1 = $3_1 + ($5_1 & 4 | 0) | 0;\r\n        $5_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;\r\n        if ($5_1) {\r\n         continue label$100\r\n        }\r\n        break label$100;\r\n       };\r\n       HEAP32[($2_1 + 16 | 0) >> 2] = $7_1;\r\n       HEAP32[($7_1 + 24 | 0) >> 2] = $3_1;\r\n      }\r\n      HEAP32[($7_1 + 12 | 0) >> 2] = $7_1;\r\n      HEAP32[($7_1 + 8 | 0) >> 2] = $7_1;\r\n      break label$91;\r\n     }\r\n     $0_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n     HEAP32[($0_1 + 12 | 0) >> 2] = $7_1;\r\n     HEAP32[($3_1 + 8 | 0) >> 2] = $7_1;\r\n     HEAP32[($7_1 + 24 | 0) >> 2] = 0;\r\n     HEAP32[($7_1 + 12 | 0) >> 2] = $3_1;\r\n     HEAP32[($7_1 + 8 | 0) >> 2] = $0_1;\r\n    }\r\n    $0_1 = $8_1 + 8 | 0;\r\n    break label$1;\r\n   }\r\n   label$101 : {\r\n    if (!$10_1) {\r\n     break label$101\r\n    }\r\n    label$102 : {\r\n     label$103 : {\r\n      $8_1 = HEAP32[($7_1 + 28 | 0) >> 2] | 0;\r\n      $5_1 = ($8_1 << 2 | 0) + 71344 | 0;\r\n      if (($7_1 | 0) != (HEAP32[$5_1 >> 2] | 0 | 0)) {\r\n       break label$103\r\n      }\r\n      HEAP32[$5_1 >> 2] = $0_1;\r\n      if ($0_1) {\r\n       break label$102\r\n      }\r\n      HEAP32[(0 + 71044 | 0) >> 2] = $9_1 & (__wasm_rotl_i32(-2 | 0, $8_1 | 0) | 0) | 0;\r\n      break label$101;\r\n     }\r\n     label$104 : {\r\n      label$105 : {\r\n       if ((HEAP32[($10_1 + 16 | 0) >> 2] | 0 | 0) != ($7_1 | 0)) {\r\n        break label$105\r\n       }\r\n       HEAP32[($10_1 + 16 | 0) >> 2] = $0_1;\r\n       break label$104;\r\n      }\r\n      HEAP32[($10_1 + 20 | 0) >> 2] = $0_1;\r\n     }\r\n     if (!$0_1) {\r\n      break label$101\r\n     }\r\n    }\r\n    HEAP32[($0_1 + 24 | 0) >> 2] = $10_1;\r\n    label$106 : {\r\n     $5_1 = HEAP32[($7_1 + 16 | 0) >> 2] | 0;\r\n     if (!$5_1) {\r\n      break label$106\r\n     }\r\n     HEAP32[($0_1 + 16 | 0) >> 2] = $5_1;\r\n     HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;\r\n    }\r\n    $5_1 = HEAP32[($7_1 + 20 | 0) >> 2] | 0;\r\n    if (!$5_1) {\r\n     break label$101\r\n    }\r\n    HEAP32[($0_1 + 20 | 0) >> 2] = $5_1;\r\n    HEAP32[($5_1 + 24 | 0) >> 2] = $0_1;\r\n   }\r\n   label$107 : {\r\n    label$108 : {\r\n     if ($4_1 >>> 0 > 15 >>> 0) {\r\n      break label$108\r\n     }\r\n     $0_1 = $4_1 + $3_1 | 0;\r\n     HEAP32[($7_1 + 4 | 0) >> 2] = $0_1 | 3 | 0;\r\n     $0_1 = $7_1 + $0_1 | 0;\r\n     HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 1 | 0;\r\n     break label$107;\r\n    }\r\n    HEAP32[($7_1 + 4 | 0) >> 2] = $3_1 | 3 | 0;\r\n    $3_1 = $7_1 + $3_1 | 0;\r\n    HEAP32[($3_1 + 4 | 0) >> 2] = $4_1 | 1 | 0;\r\n    HEAP32[($3_1 + $4_1 | 0) >> 2] = $4_1;\r\n    label$109 : {\r\n     if (!$6_1) {\r\n      break label$109\r\n     }\r\n     $5_1 = ($6_1 & -8 | 0) + 71080 | 0;\r\n     $0_1 = HEAP32[(0 + 71060 | 0) >> 2] | 0;\r\n     label$110 : {\r\n      label$111 : {\r\n       $8_1 = 1 << ($6_1 >>> 3 | 0) | 0;\r\n       if ($8_1 & $2_1 | 0) {\r\n        break label$111\r\n       }\r\n       HEAP32[(0 + 71040 | 0) >> 2] = $8_1 | $2_1 | 0;\r\n       $8_1 = $5_1;\r\n       break label$110;\r\n      }\r\n      $8_1 = HEAP32[($5_1 + 8 | 0) >> 2] | 0;\r\n     }\r\n     HEAP32[($5_1 + 8 | 0) >> 2] = $0_1;\r\n     HEAP32[($8_1 + 12 | 0) >> 2] = $0_1;\r\n     HEAP32[($0_1 + 12 | 0) >> 2] = $5_1;\r\n     HEAP32[($0_1 + 8 | 0) >> 2] = $8_1;\r\n    }\r\n    HEAP32[(0 + 71060 | 0) >> 2] = $3_1;\r\n    HEAP32[(0 + 71048 | 0) >> 2] = $4_1;\r\n   }\r\n   $0_1 = $7_1 + 8 | 0;\r\n  }\r\n  global$0 = $1_1 + 16 | 0;\r\n  return $0_1 | 0;\r\n }\r\n \r\n function $85($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $4_1 = 0, $5_1 = 0, $7_1 = 0, $8_1 = 0, $3_1 = 0, $6_1 = 0, $9_1 = 0;\r\n  $3_1 = $0_1 + ((-8 - $0_1 | 0) & 7 | 0) | 0;\r\n  HEAP32[($3_1 + 4 | 0) >> 2] = $2_1 | 3 | 0;\r\n  $4_1 = $1_1 + ((-8 - $1_1 | 0) & 7 | 0) | 0;\r\n  $5_1 = $3_1 + $2_1 | 0;\r\n  $0_1 = $4_1 - $5_1 | 0;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (($4_1 | 0) != (HEAP32[(0 + 71064 | 0) >> 2] | 0 | 0)) {\r\n     break label$2\r\n    }\r\n    HEAP32[(0 + 71064 | 0) >> 2] = $5_1;\r\n    $2_1 = (HEAP32[(0 + 71052 | 0) >> 2] | 0) + $0_1 | 0;\r\n    HEAP32[(0 + 71052 | 0) >> 2] = $2_1;\r\n    HEAP32[($5_1 + 4 | 0) >> 2] = $2_1 | 1 | 0;\r\n    break label$1;\r\n   }\r\n   label$3 : {\r\n    if (($4_1 | 0) != (HEAP32[(0 + 71060 | 0) >> 2] | 0 | 0)) {\r\n     break label$3\r\n    }\r\n    HEAP32[(0 + 71060 | 0) >> 2] = $5_1;\r\n    $2_1 = (HEAP32[(0 + 71048 | 0) >> 2] | 0) + $0_1 | 0;\r\n    HEAP32[(0 + 71048 | 0) >> 2] = $2_1;\r\n    HEAP32[($5_1 + 4 | 0) >> 2] = $2_1 | 1 | 0;\r\n    HEAP32[($5_1 + $2_1 | 0) >> 2] = $2_1;\r\n    break label$1;\r\n   }\r\n   label$4 : {\r\n    $1_1 = HEAP32[($4_1 + 4 | 0) >> 2] | 0;\r\n    if (($1_1 & 3 | 0 | 0) != (1 | 0)) {\r\n     break label$4\r\n    }\r\n    $6_1 = $1_1 & -8 | 0;\r\n    $2_1 = HEAP32[($4_1 + 12 | 0) >> 2] | 0;\r\n    label$5 : {\r\n     label$6 : {\r\n      if ($1_1 >>> 0 > 255 >>> 0) {\r\n       break label$6\r\n      }\r\n      label$7 : {\r\n       $7_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n       if (($2_1 | 0) != ($7_1 | 0)) {\r\n        break label$7\r\n       }\r\n       HEAP32[(0 + 71040 | 0) >> 2] = (HEAP32[(0 + 71040 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $1_1 >>> 3 | 0 | 0) | 0) | 0;\r\n       break label$5;\r\n      }\r\n      HEAP32[($7_1 + 12 | 0) >> 2] = $2_1;\r\n      HEAP32[($2_1 + 8 | 0) >> 2] = $7_1;\r\n      break label$5;\r\n     }\r\n     $8_1 = HEAP32[($4_1 + 24 | 0) >> 2] | 0;\r\n     label$8 : {\r\n      label$9 : {\r\n       if (($2_1 | 0) == ($4_1 | 0)) {\r\n        break label$9\r\n       }\r\n       $1_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n       HEAP32[($1_1 + 12 | 0) >> 2] = $2_1;\r\n       HEAP32[($2_1 + 8 | 0) >> 2] = $1_1;\r\n       break label$8;\r\n      }\r\n      label$10 : {\r\n       label$11 : {\r\n        label$12 : {\r\n         $1_1 = HEAP32[($4_1 + 20 | 0) >> 2] | 0;\r\n         if (!$1_1) {\r\n          break label$12\r\n         }\r\n         $7_1 = $4_1 + 20 | 0;\r\n         break label$11;\r\n        }\r\n        $1_1 = HEAP32[($4_1 + 16 | 0) >> 2] | 0;\r\n        if (!$1_1) {\r\n         break label$10\r\n        }\r\n        $7_1 = $4_1 + 16 | 0;\r\n       }\r\n       label$13 : while (1) {\r\n        $9_1 = $7_1;\r\n        $2_1 = $1_1;\r\n        $7_1 = $2_1 + 20 | 0;\r\n        $1_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;\r\n        if ($1_1) {\r\n         continue label$13\r\n        }\r\n        $7_1 = $2_1 + 16 | 0;\r\n        $1_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;\r\n        if ($1_1) {\r\n         continue label$13\r\n        }\r\n        break label$13;\r\n       };\r\n       HEAP32[$9_1 >> 2] = 0;\r\n       break label$8;\r\n      }\r\n      $2_1 = 0;\r\n     }\r\n     if (!$8_1) {\r\n      break label$5\r\n     }\r\n     label$14 : {\r\n      label$15 : {\r\n       $7_1 = HEAP32[($4_1 + 28 | 0) >> 2] | 0;\r\n       $1_1 = ($7_1 << 2 | 0) + 71344 | 0;\r\n       if (($4_1 | 0) != (HEAP32[$1_1 >> 2] | 0 | 0)) {\r\n        break label$15\r\n       }\r\n       HEAP32[$1_1 >> 2] = $2_1;\r\n       if ($2_1) {\r\n        break label$14\r\n       }\r\n       HEAP32[(0 + 71044 | 0) >> 2] = (HEAP32[(0 + 71044 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $7_1 | 0) | 0) | 0;\r\n       break label$5;\r\n      }\r\n      label$16 : {\r\n       label$17 : {\r\n        if ((HEAP32[($8_1 + 16 | 0) >> 2] | 0 | 0) != ($4_1 | 0)) {\r\n         break label$17\r\n        }\r\n        HEAP32[($8_1 + 16 | 0) >> 2] = $2_1;\r\n        break label$16;\r\n       }\r\n       HEAP32[($8_1 + 20 | 0) >> 2] = $2_1;\r\n      }\r\n      if (!$2_1) {\r\n       break label$5\r\n      }\r\n     }\r\n     HEAP32[($2_1 + 24 | 0) >> 2] = $8_1;\r\n     label$18 : {\r\n      $1_1 = HEAP32[($4_1 + 16 | 0) >> 2] | 0;\r\n      if (!$1_1) {\r\n       break label$18\r\n      }\r\n      HEAP32[($2_1 + 16 | 0) >> 2] = $1_1;\r\n      HEAP32[($1_1 + 24 | 0) >> 2] = $2_1;\r\n     }\r\n     $1_1 = HEAP32[($4_1 + 20 | 0) >> 2] | 0;\r\n     if (!$1_1) {\r\n      break label$5\r\n     }\r\n     HEAP32[($2_1 + 20 | 0) >> 2] = $1_1;\r\n     HEAP32[($1_1 + 24 | 0) >> 2] = $2_1;\r\n    }\r\n    $0_1 = $6_1 + $0_1 | 0;\r\n    $4_1 = $4_1 + $6_1 | 0;\r\n    $1_1 = HEAP32[($4_1 + 4 | 0) >> 2] | 0;\r\n   }\r\n   HEAP32[($4_1 + 4 | 0) >> 2] = $1_1 & -2 | 0;\r\n   HEAP32[($5_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n   HEAP32[($5_1 + $0_1 | 0) >> 2] = $0_1;\r\n   label$19 : {\r\n    if ($0_1 >>> 0 > 255 >>> 0) {\r\n     break label$19\r\n    }\r\n    $2_1 = ($0_1 & -8 | 0) + 71080 | 0;\r\n    label$20 : {\r\n     label$21 : {\r\n      $1_1 = HEAP32[(0 + 71040 | 0) >> 2] | 0;\r\n      $0_1 = 1 << ($0_1 >>> 3 | 0) | 0;\r\n      if ($1_1 & $0_1 | 0) {\r\n       break label$21\r\n      }\r\n      HEAP32[(0 + 71040 | 0) >> 2] = $1_1 | $0_1 | 0;\r\n      $0_1 = $2_1;\r\n      break label$20;\r\n     }\r\n     $0_1 = HEAP32[($2_1 + 8 | 0) >> 2] | 0;\r\n    }\r\n    HEAP32[($2_1 + 8 | 0) >> 2] = $5_1;\r\n    HEAP32[($0_1 + 12 | 0) >> 2] = $5_1;\r\n    HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;\r\n    HEAP32[($5_1 + 8 | 0) >> 2] = $0_1;\r\n    break label$1;\r\n   }\r\n   $2_1 = 31;\r\n   label$22 : {\r\n    if ($0_1 >>> 0 > 16777215 >>> 0) {\r\n     break label$22\r\n    }\r\n    $2_1 = Math_clz32($0_1 >>> 8 | 0);\r\n    $2_1 = ((($0_1 >>> (38 - $2_1 | 0) | 0) & 1 | 0) - ($2_1 << 1 | 0) | 0) + 62 | 0;\r\n   }\r\n   HEAP32[($5_1 + 28 | 0) >> 2] = $2_1;\r\n   HEAP32[($5_1 + 16 | 0) >> 2] = 0;\r\n   HEAP32[($5_1 + 20 | 0) >> 2] = 0;\r\n   $1_1 = ($2_1 << 2 | 0) + 71344 | 0;\r\n   label$23 : {\r\n    label$24 : {\r\n     label$25 : {\r\n      $7_1 = HEAP32[(0 + 71044 | 0) >> 2] | 0;\r\n      $4_1 = 1 << $2_1 | 0;\r\n      if ($7_1 & $4_1 | 0) {\r\n       break label$25\r\n      }\r\n      HEAP32[(0 + 71044 | 0) >> 2] = $7_1 | $4_1 | 0;\r\n      HEAP32[$1_1 >> 2] = $5_1;\r\n      HEAP32[($5_1 + 24 | 0) >> 2] = $1_1;\r\n      break label$24;\r\n     }\r\n     $2_1 = $0_1 << (($2_1 | 0) == (31 | 0) ? 0 : 25 - ($2_1 >>> 1 | 0) | 0) | 0;\r\n     $7_1 = HEAP32[$1_1 >> 2] | 0;\r\n     label$26 : while (1) {\r\n      $1_1 = $7_1;\r\n      if (((HEAP32[($1_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($0_1 | 0)) {\r\n       break label$23\r\n      }\r\n      $7_1 = $2_1 >>> 29 | 0;\r\n      $2_1 = $2_1 << 1 | 0;\r\n      $4_1 = $1_1 + ($7_1 & 4 | 0) | 0;\r\n      $7_1 = HEAP32[($4_1 + 16 | 0) >> 2] | 0;\r\n      if ($7_1) {\r\n       continue label$26\r\n      }\r\n      break label$26;\r\n     };\r\n     HEAP32[($4_1 + 16 | 0) >> 2] = $5_1;\r\n     HEAP32[($5_1 + 24 | 0) >> 2] = $1_1;\r\n    }\r\n    HEAP32[($5_1 + 12 | 0) >> 2] = $5_1;\r\n    HEAP32[($5_1 + 8 | 0) >> 2] = $5_1;\r\n    break label$1;\r\n   }\r\n   $2_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;\r\n   HEAP32[($2_1 + 12 | 0) >> 2] = $5_1;\r\n   HEAP32[($1_1 + 8 | 0) >> 2] = $5_1;\r\n   HEAP32[($5_1 + 24 | 0) >> 2] = 0;\r\n   HEAP32[($5_1 + 12 | 0) >> 2] = $1_1;\r\n   HEAP32[($5_1 + 8 | 0) >> 2] = $2_1;\r\n  }\r\n  return $3_1 + 8 | 0 | 0;\r\n }\r\n \r\n function $86($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $2_1 = 0, $4_1 = 0, $1_1 = 0, $5_1 = 0, $3_1 = 0, $6_1 = 0, $7_1 = 0;\r\n  label$1 : {\r\n   if (!$0_1) {\r\n    break label$1\r\n   }\r\n   $1_1 = $0_1 + -8 | 0;\r\n   $2_1 = HEAP32[($0_1 + -4 | 0) >> 2] | 0;\r\n   $0_1 = $2_1 & -8 | 0;\r\n   $3_1 = $1_1 + $0_1 | 0;\r\n   label$2 : {\r\n    if ($2_1 & 1 | 0) {\r\n     break label$2\r\n    }\r\n    if (!($2_1 & 2 | 0)) {\r\n     break label$1\r\n    }\r\n    $4_1 = HEAP32[$1_1 >> 2] | 0;\r\n    $1_1 = $1_1 - $4_1 | 0;\r\n    if ($1_1 >>> 0 < (HEAP32[(0 + 71056 | 0) >> 2] | 0) >>> 0) {\r\n     break label$1\r\n    }\r\n    $0_1 = $4_1 + $0_1 | 0;\r\n    label$3 : {\r\n     label$4 : {\r\n      label$5 : {\r\n       label$6 : {\r\n        if (($1_1 | 0) == (HEAP32[(0 + 71060 | 0) >> 2] | 0 | 0)) {\r\n         break label$6\r\n        }\r\n        $2_1 = HEAP32[($1_1 + 12 | 0) >> 2] | 0;\r\n        label$7 : {\r\n         if ($4_1 >>> 0 > 255 >>> 0) {\r\n          break label$7\r\n         }\r\n         $5_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;\r\n         if (($2_1 | 0) != ($5_1 | 0)) {\r\n          break label$5\r\n         }\r\n         HEAP32[(0 + 71040 | 0) >> 2] = (HEAP32[(0 + 71040 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $4_1 >>> 3 | 0 | 0) | 0) | 0;\r\n         break label$2;\r\n        }\r\n        $6_1 = HEAP32[($1_1 + 24 | 0) >> 2] | 0;\r\n        label$8 : {\r\n         if (($2_1 | 0) == ($1_1 | 0)) {\r\n          break label$8\r\n         }\r\n         $4_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;\r\n         HEAP32[($4_1 + 12 | 0) >> 2] = $2_1;\r\n         HEAP32[($2_1 + 8 | 0) >> 2] = $4_1;\r\n         break label$3;\r\n        }\r\n        label$9 : {\r\n         label$10 : {\r\n          $4_1 = HEAP32[($1_1 + 20 | 0) >> 2] | 0;\r\n          if (!$4_1) {\r\n           break label$10\r\n          }\r\n          $5_1 = $1_1 + 20 | 0;\r\n          break label$9;\r\n         }\r\n         $4_1 = HEAP32[($1_1 + 16 | 0) >> 2] | 0;\r\n         if (!$4_1) {\r\n          break label$4\r\n         }\r\n         $5_1 = $1_1 + 16 | 0;\r\n        }\r\n        label$11 : while (1) {\r\n         $7_1 = $5_1;\r\n         $2_1 = $4_1;\r\n         $5_1 = $2_1 + 20 | 0;\r\n         $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;\r\n         if ($4_1) {\r\n          continue label$11\r\n         }\r\n         $5_1 = $2_1 + 16 | 0;\r\n         $4_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;\r\n         if ($4_1) {\r\n          continue label$11\r\n         }\r\n         break label$11;\r\n        };\r\n        HEAP32[$7_1 >> 2] = 0;\r\n        break label$3;\r\n       }\r\n       $2_1 = HEAP32[($3_1 + 4 | 0) >> 2] | 0;\r\n       if (($2_1 & 3 | 0 | 0) != (3 | 0)) {\r\n        break label$2\r\n       }\r\n       HEAP32[(0 + 71048 | 0) >> 2] = $0_1;\r\n       HEAP32[($3_1 + 4 | 0) >> 2] = $2_1 & -2 | 0;\r\n       HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n       HEAP32[$3_1 >> 2] = $0_1;\r\n       return;\r\n      }\r\n      HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;\r\n      HEAP32[($2_1 + 8 | 0) >> 2] = $5_1;\r\n      break label$2;\r\n     }\r\n     $2_1 = 0;\r\n    }\r\n    if (!$6_1) {\r\n     break label$2\r\n    }\r\n    label$12 : {\r\n     label$13 : {\r\n      $5_1 = HEAP32[($1_1 + 28 | 0) >> 2] | 0;\r\n      $4_1 = ($5_1 << 2 | 0) + 71344 | 0;\r\n      if (($1_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {\r\n       break label$13\r\n      }\r\n      HEAP32[$4_1 >> 2] = $2_1;\r\n      if ($2_1) {\r\n       break label$12\r\n      }\r\n      HEAP32[(0 + 71044 | 0) >> 2] = (HEAP32[(0 + 71044 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $5_1 | 0) | 0) | 0;\r\n      break label$2;\r\n     }\r\n     label$14 : {\r\n      label$15 : {\r\n       if ((HEAP32[($6_1 + 16 | 0) >> 2] | 0 | 0) != ($1_1 | 0)) {\r\n        break label$15\r\n       }\r\n       HEAP32[($6_1 + 16 | 0) >> 2] = $2_1;\r\n       break label$14;\r\n      }\r\n      HEAP32[($6_1 + 20 | 0) >> 2] = $2_1;\r\n     }\r\n     if (!$2_1) {\r\n      break label$2\r\n     }\r\n    }\r\n    HEAP32[($2_1 + 24 | 0) >> 2] = $6_1;\r\n    label$16 : {\r\n     $4_1 = HEAP32[($1_1 + 16 | 0) >> 2] | 0;\r\n     if (!$4_1) {\r\n      break label$16\r\n     }\r\n     HEAP32[($2_1 + 16 | 0) >> 2] = $4_1;\r\n     HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;\r\n    }\r\n    $4_1 = HEAP32[($1_1 + 20 | 0) >> 2] | 0;\r\n    if (!$4_1) {\r\n     break label$2\r\n    }\r\n    HEAP32[($2_1 + 20 | 0) >> 2] = $4_1;\r\n    HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;\r\n   }\r\n   if ($1_1 >>> 0 >= $3_1 >>> 0) {\r\n    break label$1\r\n   }\r\n   $4_1 = HEAP32[($3_1 + 4 | 0) >> 2] | 0;\r\n   if (!($4_1 & 1 | 0)) {\r\n    break label$1\r\n   }\r\n   label$17 : {\r\n    label$18 : {\r\n     label$19 : {\r\n      label$20 : {\r\n       label$21 : {\r\n        if ($4_1 & 2 | 0) {\r\n         break label$21\r\n        }\r\n        label$22 : {\r\n         if (($3_1 | 0) != (HEAP32[(0 + 71064 | 0) >> 2] | 0 | 0)) {\r\n          break label$22\r\n         }\r\n         HEAP32[(0 + 71064 | 0) >> 2] = $1_1;\r\n         $0_1 = (HEAP32[(0 + 71052 | 0) >> 2] | 0) + $0_1 | 0;\r\n         HEAP32[(0 + 71052 | 0) >> 2] = $0_1;\r\n         HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n         if (($1_1 | 0) != (HEAP32[(0 + 71060 | 0) >> 2] | 0 | 0)) {\r\n          break label$1\r\n         }\r\n         HEAP32[(0 + 71048 | 0) >> 2] = 0;\r\n         HEAP32[(0 + 71060 | 0) >> 2] = 0;\r\n         return;\r\n        }\r\n        label$23 : {\r\n         if (($3_1 | 0) != (HEAP32[(0 + 71060 | 0) >> 2] | 0 | 0)) {\r\n          break label$23\r\n         }\r\n         HEAP32[(0 + 71060 | 0) >> 2] = $1_1;\r\n         $0_1 = (HEAP32[(0 + 71048 | 0) >> 2] | 0) + $0_1 | 0;\r\n         HEAP32[(0 + 71048 | 0) >> 2] = $0_1;\r\n         HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n         HEAP32[($1_1 + $0_1 | 0) >> 2] = $0_1;\r\n         return;\r\n        }\r\n        $0_1 = ($4_1 & -8 | 0) + $0_1 | 0;\r\n        $2_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n        label$24 : {\r\n         if ($4_1 >>> 0 > 255 >>> 0) {\r\n          break label$24\r\n         }\r\n         label$25 : {\r\n          $5_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n          if (($2_1 | 0) != ($5_1 | 0)) {\r\n           break label$25\r\n          }\r\n          HEAP32[(0 + 71040 | 0) >> 2] = (HEAP32[(0 + 71040 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $4_1 >>> 3 | 0 | 0) | 0) | 0;\r\n          break label$18;\r\n         }\r\n         HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;\r\n         HEAP32[($2_1 + 8 | 0) >> 2] = $5_1;\r\n         break label$18;\r\n        }\r\n        $6_1 = HEAP32[($3_1 + 24 | 0) >> 2] | 0;\r\n        label$26 : {\r\n         if (($2_1 | 0) == ($3_1 | 0)) {\r\n          break label$26\r\n         }\r\n         $4_1 = HEAP32[($3_1 + 8 | 0) >> 2] | 0;\r\n         HEAP32[($4_1 + 12 | 0) >> 2] = $2_1;\r\n         HEAP32[($2_1 + 8 | 0) >> 2] = $4_1;\r\n         break label$19;\r\n        }\r\n        label$27 : {\r\n         label$28 : {\r\n          $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;\r\n          if (!$4_1) {\r\n           break label$28\r\n          }\r\n          $5_1 = $3_1 + 20 | 0;\r\n          break label$27;\r\n         }\r\n         $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;\r\n         if (!$4_1) {\r\n          break label$20\r\n         }\r\n         $5_1 = $3_1 + 16 | 0;\r\n        }\r\n        label$29 : while (1) {\r\n         $7_1 = $5_1;\r\n         $2_1 = $4_1;\r\n         $5_1 = $2_1 + 20 | 0;\r\n         $4_1 = HEAP32[($2_1 + 20 | 0) >> 2] | 0;\r\n         if ($4_1) {\r\n          continue label$29\r\n         }\r\n         $5_1 = $2_1 + 16 | 0;\r\n         $4_1 = HEAP32[($2_1 + 16 | 0) >> 2] | 0;\r\n         if ($4_1) {\r\n          continue label$29\r\n         }\r\n         break label$29;\r\n        };\r\n        HEAP32[$7_1 >> 2] = 0;\r\n        break label$19;\r\n       }\r\n       HEAP32[($3_1 + 4 | 0) >> 2] = $4_1 & -2 | 0;\r\n       HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n       HEAP32[($1_1 + $0_1 | 0) >> 2] = $0_1;\r\n       break label$17;\r\n      }\r\n      $2_1 = 0;\r\n     }\r\n     if (!$6_1) {\r\n      break label$18\r\n     }\r\n     label$30 : {\r\n      label$31 : {\r\n       $5_1 = HEAP32[($3_1 + 28 | 0) >> 2] | 0;\r\n       $4_1 = ($5_1 << 2 | 0) + 71344 | 0;\r\n       if (($3_1 | 0) != (HEAP32[$4_1 >> 2] | 0 | 0)) {\r\n        break label$31\r\n       }\r\n       HEAP32[$4_1 >> 2] = $2_1;\r\n       if ($2_1) {\r\n        break label$30\r\n       }\r\n       HEAP32[(0 + 71044 | 0) >> 2] = (HEAP32[(0 + 71044 | 0) >> 2] | 0) & (__wasm_rotl_i32(-2 | 0, $5_1 | 0) | 0) | 0;\r\n       break label$18;\r\n      }\r\n      label$32 : {\r\n       label$33 : {\r\n        if ((HEAP32[($6_1 + 16 | 0) >> 2] | 0 | 0) != ($3_1 | 0)) {\r\n         break label$33\r\n        }\r\n        HEAP32[($6_1 + 16 | 0) >> 2] = $2_1;\r\n        break label$32;\r\n       }\r\n       HEAP32[($6_1 + 20 | 0) >> 2] = $2_1;\r\n      }\r\n      if (!$2_1) {\r\n       break label$18\r\n      }\r\n     }\r\n     HEAP32[($2_1 + 24 | 0) >> 2] = $6_1;\r\n     label$34 : {\r\n      $4_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;\r\n      if (!$4_1) {\r\n       break label$34\r\n      }\r\n      HEAP32[($2_1 + 16 | 0) >> 2] = $4_1;\r\n      HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;\r\n     }\r\n     $4_1 = HEAP32[($3_1 + 20 | 0) >> 2] | 0;\r\n     if (!$4_1) {\r\n      break label$18\r\n     }\r\n     HEAP32[($2_1 + 20 | 0) >> 2] = $4_1;\r\n     HEAP32[($4_1 + 24 | 0) >> 2] = $2_1;\r\n    }\r\n    HEAP32[($1_1 + 4 | 0) >> 2] = $0_1 | 1 | 0;\r\n    HEAP32[($1_1 + $0_1 | 0) >> 2] = $0_1;\r\n    if (($1_1 | 0) != (HEAP32[(0 + 71060 | 0) >> 2] | 0 | 0)) {\r\n     break label$17\r\n    }\r\n    HEAP32[(0 + 71048 | 0) >> 2] = $0_1;\r\n    return;\r\n   }\r\n   label$35 : {\r\n    if ($0_1 >>> 0 > 255 >>> 0) {\r\n     break label$35\r\n    }\r\n    $2_1 = ($0_1 & -8 | 0) + 71080 | 0;\r\n    label$36 : {\r\n     label$37 : {\r\n      $4_1 = HEAP32[(0 + 71040 | 0) >> 2] | 0;\r\n      $0_1 = 1 << ($0_1 >>> 3 | 0) | 0;\r\n      if ($4_1 & $0_1 | 0) {\r\n       break label$37\r\n      }\r\n      HEAP32[(0 + 71040 | 0) >> 2] = $4_1 | $0_1 | 0;\r\n      $0_1 = $2_1;\r\n      break label$36;\r\n     }\r\n     $0_1 = HEAP32[($2_1 + 8 | 0) >> 2] | 0;\r\n    }\r\n    HEAP32[($2_1 + 8 | 0) >> 2] = $1_1;\r\n    HEAP32[($0_1 + 12 | 0) >> 2] = $1_1;\r\n    HEAP32[($1_1 + 12 | 0) >> 2] = $2_1;\r\n    HEAP32[($1_1 + 8 | 0) >> 2] = $0_1;\r\n    return;\r\n   }\r\n   $2_1 = 31;\r\n   label$38 : {\r\n    if ($0_1 >>> 0 > 16777215 >>> 0) {\r\n     break label$38\r\n    }\r\n    $2_1 = Math_clz32($0_1 >>> 8 | 0);\r\n    $2_1 = ((($0_1 >>> (38 - $2_1 | 0) | 0) & 1 | 0) - ($2_1 << 1 | 0) | 0) + 62 | 0;\r\n   }\r\n   HEAP32[($1_1 + 28 | 0) >> 2] = $2_1;\r\n   HEAP32[($1_1 + 16 | 0) >> 2] = 0;\r\n   HEAP32[($1_1 + 20 | 0) >> 2] = 0;\r\n   $5_1 = ($2_1 << 2 | 0) + 71344 | 0;\r\n   label$39 : {\r\n    label$40 : {\r\n     label$41 : {\r\n      label$42 : {\r\n       $4_1 = HEAP32[(0 + 71044 | 0) >> 2] | 0;\r\n       $3_1 = 1 << $2_1 | 0;\r\n       if ($4_1 & $3_1 | 0) {\r\n        break label$42\r\n       }\r\n       HEAP32[(0 + 71044 | 0) >> 2] = $4_1 | $3_1 | 0;\r\n       HEAP32[$5_1 >> 2] = $1_1;\r\n       $0_1 = 8;\r\n       $2_1 = 24;\r\n       break label$41;\r\n      }\r\n      $2_1 = $0_1 << (($2_1 | 0) == (31 | 0) ? 0 : 25 - ($2_1 >>> 1 | 0) | 0) | 0;\r\n      $5_1 = HEAP32[$5_1 >> 2] | 0;\r\n      label$43 : while (1) {\r\n       $4_1 = $5_1;\r\n       if (((HEAP32[($4_1 + 4 | 0) >> 2] | 0) & -8 | 0 | 0) == ($0_1 | 0)) {\r\n        break label$40\r\n       }\r\n       $5_1 = $2_1 >>> 29 | 0;\r\n       $2_1 = $2_1 << 1 | 0;\r\n       $3_1 = $4_1 + ($5_1 & 4 | 0) | 0;\r\n       $5_1 = HEAP32[($3_1 + 16 | 0) >> 2] | 0;\r\n       if ($5_1) {\r\n        continue label$43\r\n       }\r\n       break label$43;\r\n      };\r\n      HEAP32[($3_1 + 16 | 0) >> 2] = $1_1;\r\n      $0_1 = 8;\r\n      $2_1 = 24;\r\n      $5_1 = $4_1;\r\n     }\r\n     $4_1 = $1_1;\r\n     $3_1 = $1_1;\r\n     break label$39;\r\n    }\r\n    $5_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n    HEAP32[($5_1 + 12 | 0) >> 2] = $1_1;\r\n    HEAP32[($4_1 + 8 | 0) >> 2] = $1_1;\r\n    $3_1 = 0;\r\n    $0_1 = 24;\r\n    $2_1 = 8;\r\n   }\r\n   HEAP32[($1_1 + $2_1 | 0) >> 2] = $5_1;\r\n   HEAP32[($1_1 + 12 | 0) >> 2] = $4_1;\r\n   HEAP32[($1_1 + $0_1 | 0) >> 2] = $3_1;\r\n   $1_1 = (HEAP32[(0 + 71072 | 0) >> 2] | 0) + -1 | 0;\r\n   HEAP32[(0 + 71072 | 0) >> 2] = $1_1 ? $1_1 : -1;\r\n  }\r\n }\r\n \r\n function $87($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  label$1 : {\r\n   $0_1 = $88($0_1 | 0) | 0;\r\n   if ($0_1) {\r\n    break label$1\r\n   }\r\n   $89();\r\n  }\r\n  return $0_1 | 0;\r\n }\r\n \r\n function $88($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $2_1 = 0, $1_1 = 0;\r\n  $1_1 = $0_1 >>> 0 > 1 >>> 0 ? $0_1 : 1;\r\n  label$1 : {\r\n   label$2 : while (1) {\r\n    $2_1 = $84($1_1 | 0) | 0;\r\n    if ($2_1) {\r\n     break label$1\r\n    }\r\n    $0_1 = $107() | 0;\r\n    if (!$0_1) {\r\n     break label$1\r\n    }\r\n    FUNCTION_TABLE[$0_1 | 0]();\r\n    continue label$2;\r\n   };\r\n  }\r\n  return $2_1 | 0;\r\n }\r\n \r\n function $89() {\r\n  $93();\r\n  wasm2js_trap();\r\n }\r\n \r\n function $90($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $86($0_1 | 0);\r\n }\r\n \r\n function $91($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $90($0_1 | 0);\r\n }\r\n \r\n function $92() {\r\n  fimport$18();\r\n  wasm2js_trap();\r\n }\r\n \r\n function $93() {\r\n  $92();\r\n  wasm2js_trap();\r\n }\r\n \r\n function $94($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  label$1 : {\r\n   if ($0_1) {\r\n    break label$1\r\n   }\r\n   return 0 | 0;\r\n  }\r\n  HEAP32[($82() | 0) >> 2] = $0_1;\r\n  return -1 | 0;\r\n }\r\n \r\n function $95($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return $0_1 | 0;\r\n }\r\n \r\n function $96($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return $94(fimport$19($95(HEAP32[($0_1 + 60 | 0) >> 2] | 0 | 0) | 0 | 0) | 0 | 0) | 0 | 0;\r\n }\r\n \r\n function $97($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $4_1 = 0, $3_1 = 0, $5_1 = 0, $8_1 = 0, $6_1 = 0, $7_1 = 0, $9_1 = 0;\r\n  $3_1 = global$0 - 32 | 0;\r\n  global$0 = $3_1;\r\n  $4_1 = HEAP32[($0_1 + 28 | 0) >> 2] | 0;\r\n  HEAP32[($3_1 + 16 | 0) >> 2] = $4_1;\r\n  $5_1 = HEAP32[($0_1 + 20 | 0) >> 2] | 0;\r\n  HEAP32[($3_1 + 28 | 0) >> 2] = $2_1;\r\n  HEAP32[($3_1 + 24 | 0) >> 2] = $1_1;\r\n  $1_1 = $5_1 - $4_1 | 0;\r\n  HEAP32[($3_1 + 20 | 0) >> 2] = $1_1;\r\n  $6_1 = $1_1 + $2_1 | 0;\r\n  $4_1 = $3_1 + 16 | 0;\r\n  $7_1 = 2;\r\n  label$1 : {\r\n   label$2 : {\r\n    label$3 : {\r\n     label$4 : {\r\n      label$5 : {\r\n       if (!($94(fimport$20(HEAP32[($0_1 + 60 | 0) >> 2] | 0 | 0, $3_1 + 16 | 0 | 0, 2 | 0, $3_1 + 12 | 0 | 0) | 0 | 0) | 0)) {\r\n        break label$5\r\n       }\r\n       $5_1 = $4_1;\r\n       break label$4;\r\n      }\r\n      label$6 : while (1) {\r\n       $1_1 = HEAP32[($3_1 + 12 | 0) >> 2] | 0;\r\n       if (($6_1 | 0) == ($1_1 | 0)) {\r\n        break label$3\r\n       }\r\n       label$7 : {\r\n        if (($1_1 | 0) > (-1 | 0)) {\r\n         break label$7\r\n        }\r\n        $5_1 = $4_1;\r\n        break label$2;\r\n       }\r\n       $8_1 = HEAP32[($4_1 + 4 | 0) >> 2] | 0;\r\n       $9_1 = $1_1 >>> 0 > $8_1 >>> 0;\r\n       $5_1 = $4_1 + ($9_1 << 3 | 0) | 0;\r\n       $8_1 = $1_1 - ($9_1 ? $8_1 : 0) | 0;\r\n       HEAP32[$5_1 >> 2] = (HEAP32[$5_1 >> 2] | 0) + $8_1 | 0;\r\n       $4_1 = $4_1 + ($9_1 ? 12 : 4) | 0;\r\n       HEAP32[$4_1 >> 2] = (HEAP32[$4_1 >> 2] | 0) - $8_1 | 0;\r\n       $6_1 = $6_1 - $1_1 | 0;\r\n       $4_1 = $5_1;\r\n       $7_1 = $7_1 - $9_1 | 0;\r\n       if (!($94(fimport$20(HEAP32[($0_1 + 60 | 0) >> 2] | 0 | 0, $4_1 | 0, $7_1 | 0, $3_1 + 12 | 0 | 0) | 0 | 0) | 0)) {\r\n        continue label$6\r\n       }\r\n       break label$6;\r\n      };\r\n     }\r\n     if (($6_1 | 0) != (-1 | 0)) {\r\n      break label$2\r\n     }\r\n    }\r\n    $1_1 = HEAP32[($0_1 + 44 | 0) >> 2] | 0;\r\n    HEAP32[($0_1 + 28 | 0) >> 2] = $1_1;\r\n    HEAP32[($0_1 + 20 | 0) >> 2] = $1_1;\r\n    HEAP32[($0_1 + 16 | 0) >> 2] = $1_1 + (HEAP32[($0_1 + 48 | 0) >> 2] | 0) | 0;\r\n    $1_1 = $2_1;\r\n    break label$1;\r\n   }\r\n   $1_1 = 0;\r\n   HEAP32[($0_1 + 28 | 0) >> 2] = 0;\r\n   HEAP32[($0_1 + 16 | 0) >> 2] = 0;\r\n   HEAP32[($0_1 + 20 | 0) >> 2] = 0;\r\n   HEAP32[$0_1 >> 2] = HEAP32[$0_1 >> 2] | 0 | 32 | 0;\r\n   if (($7_1 | 0) == (2 | 0)) {\r\n    break label$1\r\n   }\r\n   $1_1 = $2_1 - (HEAP32[($5_1 + 4 | 0) >> 2] | 0) | 0;\r\n  }\r\n  global$0 = $3_1 + 32 | 0;\r\n  return $1_1 | 0;\r\n }\r\n \r\n function $98($0_1, $1_1, $1$hi, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $1$hi = $1$hi | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var i64toi32_i32$0 = 0, i64toi32_i32$2 = 0, $3_1 = 0, i64toi32_i32$1 = 0, i64toi32_i32$3 = 0;\r\n  $3_1 = global$0 - 16 | 0;\r\n  global$0 = $3_1;\r\n  i64toi32_i32$0 = $1$hi;\r\n  $2_1 = $94($154($0_1 | 0, $1_1 | 0, i64toi32_i32$0 | 0, $2_1 & 255 | 0 | 0, $3_1 + 8 | 0 | 0) | 0 | 0) | 0;\r\n  i64toi32_i32$2 = $3_1;\r\n  i64toi32_i32$0 = HEAP32[(i64toi32_i32$2 + 8 | 0) >> 2] | 0;\r\n  i64toi32_i32$1 = HEAP32[(i64toi32_i32$2 + 12 | 0) >> 2] | 0;\r\n  $1_1 = i64toi32_i32$0;\r\n  $1$hi = i64toi32_i32$1;\r\n  global$0 = i64toi32_i32$2 + 16 | 0;\r\n  i64toi32_i32$1 = -1;\r\n  i64toi32_i32$0 = $1$hi;\r\n  i64toi32_i32$3 = $2_1 ? -1 : $1_1;\r\n  i64toi32_i32$2 = $2_1 ? i64toi32_i32$1 : i64toi32_i32$0;\r\n  i64toi32_i32$HIGH_BITS = i64toi32_i32$2;\r\n  return i64toi32_i32$3 | 0;\r\n }\r\n \r\n function $99($0_1, $1_1, $1$hi, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $1$hi = $1$hi | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var i64toi32_i32$0 = 0, i64toi32_i32$1 = 0;\r\n  i64toi32_i32$0 = $1$hi;\r\n  i64toi32_i32$0 = $98(HEAP32[($0_1 + 60 | 0) >> 2] | 0 | 0, $1_1 | 0, i64toi32_i32$0 | 0, $2_1 | 0) | 0;\r\n  i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;\r\n  i64toi32_i32$HIGH_BITS = i64toi32_i32$1;\r\n  return i64toi32_i32$0 | 0;\r\n }\r\n \r\n function $100($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n }\r\n \r\n function $101($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n }\r\n \r\n function $102() {\r\n  $100(71544 | 0);\r\n  return 71548 | 0;\r\n }\r\n \r\n function $103() {\r\n  $101(71544 | 0);\r\n }\r\n \r\n function $104($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return 1 | 0;\r\n }\r\n \r\n function $105($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n }\r\n \r\n function $106($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return HEAP32[$0_1 >> 2] | 0 | 0;\r\n }\r\n \r\n function $107() {\r\n  return $106(71556 | 0) | 0 | 0;\r\n }\r\n \r\n function $108($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $3_1 = 0, $2_1 = 0;\r\n  $2_1 = HEAPU8[$1_1 >> 0] | 0;\r\n  label$1 : {\r\n   $3_1 = HEAPU8[$0_1 >> 0] | 0;\r\n   if (!$3_1) {\r\n    break label$1\r\n   }\r\n   if (($3_1 | 0) != ($2_1 & 255 | 0 | 0)) {\r\n    break label$1\r\n   }\r\n   label$2 : while (1) {\r\n    $2_1 = HEAPU8[($1_1 + 1 | 0) >> 0] | 0;\r\n    $3_1 = HEAPU8[($0_1 + 1 | 0) >> 0] | 0;\r\n    if (!$3_1) {\r\n     break label$1\r\n    }\r\n    $1_1 = $1_1 + 1 | 0;\r\n    $0_1 = $0_1 + 1 | 0;\r\n    if (($3_1 | 0) == ($2_1 & 255 | 0 | 0)) {\r\n     continue label$2\r\n    }\r\n    break label$2;\r\n   };\r\n  }\r\n  return $3_1 - ($2_1 & 255 | 0) | 0 | 0;\r\n }\r\n \r\n function $109($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return $138($0_1 | 0) | 0 | 0;\r\n }\r\n \r\n function $110($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n }\r\n \r\n function $111($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n }\r\n \r\n function $112($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $91($109($0_1 | 0) | 0 | 0, 8 | 0);\r\n }\r\n \r\n function $113($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $91($109($0_1 | 0) | 0 | 0, 8 | 0);\r\n }\r\n \r\n function $114($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $91($109($0_1 | 0) | 0 | 0, 12 | 0);\r\n }\r\n \r\n function $115($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $91($109($0_1 | 0) | 0 | 0, 16 | 0);\r\n }\r\n \r\n function $116($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  return $117($0_1 | 0, $1_1 | 0, 0 | 0) | 0 | 0;\r\n }\r\n \r\n function $117($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  label$1 : {\r\n   if ($2_1) {\r\n    break label$1\r\n   }\r\n   return (HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 0) == (HEAP32[($1_1 + 4 | 0) >> 2] | 0 | 0) | 0;\r\n  }\r\n  label$2 : {\r\n   if (($0_1 | 0) != ($1_1 | 0)) {\r\n    break label$2\r\n   }\r\n   return 1 | 0;\r\n  }\r\n  return !($108($118($0_1 | 0) | 0 | 0, $118($1_1 | 0) | 0 | 0) | 0) | 0;\r\n }\r\n \r\n function $118($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return HEAP32[($0_1 + 4 | 0) >> 2] | 0 | 0;\r\n }\r\n \r\n function $119($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = global$0 - 64 | 0;\r\n  global$0 = $3_1;\r\n  $4_1 = 1;\r\n  label$1 : {\r\n   label$2 : {\r\n    if ($117($0_1 | 0, $1_1 | 0, 0 | 0) | 0) {\r\n     break label$2\r\n    }\r\n    $4_1 = 0;\r\n    if (!$1_1) {\r\n     break label$2\r\n    }\r\n    $4_1 = 0;\r\n    $1_1 = $120($1_1 | 0, 67612 | 0, 67660 | 0, 0 | 0) | 0;\r\n    if (!$1_1) {\r\n     break label$2\r\n    }\r\n    $4_1 = HEAP32[$2_1 >> 2] | 0;\r\n    if (!$4_1) {\r\n     break label$1\r\n    }\r\n    $73($3_1 + 8 | 0 | 0, 0 | 0, 56 | 0) | 0;\r\n    HEAP8[($3_1 + 59 | 0) >> 0] = 1;\r\n    HEAP32[($3_1 + 16 | 0) >> 2] = -1;\r\n    HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n    HEAP32[($3_1 + 4 | 0) >> 2] = $1_1;\r\n    HEAP32[($3_1 + 52 | 0) >> 2] = 1;\r\n    FUNCTION_TABLE[HEAP32[((HEAP32[$1_1 >> 2] | 0) + 28 | 0) >> 2] | 0 | 0]($1_1, $3_1 + 4 | 0, $4_1, 1);\r\n    label$3 : {\r\n     $4_1 = HEAP32[($3_1 + 28 | 0) >> 2] | 0;\r\n     if (($4_1 | 0) != (1 | 0)) {\r\n      break label$3\r\n     }\r\n     HEAP32[$2_1 >> 2] = HEAP32[($3_1 + 20 | 0) >> 2] | 0;\r\n    }\r\n    $4_1 = ($4_1 | 0) == (1 | 0);\r\n   }\r\n   global$0 = $3_1 + 64 | 0;\r\n   return $4_1 | 0;\r\n  }\r\n  fimport$21(66444 | 0, 65593 | 0, 473 | 0, 65658 | 0);\r\n  wasm2js_trap();\r\n }\r\n \r\n function $120($0_1, $1_1, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  var $4_1 = 0, $6_1 = 0, $5_1 = 0, $7_1 = 0;\r\n  $4_1 = global$0 - 16 | 0;\r\n  global$0 = $4_1;\r\n  $121($4_1 + 4 | 0 | 0, $0_1 | 0);\r\n  $5_1 = HEAP32[($4_1 + 8 | 0) >> 2] | 0;\r\n  $6_1 = $117($5_1 | 0, $2_1 | 0, 0 | 0) | 0;\r\n  $7_1 = HEAP32[($4_1 + 4 | 0) >> 2] | 0;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (!$6_1) {\r\n     break label$2\r\n    }\r\n    $6_1 = $122($0_1 | 0, $7_1 | 0, $1_1 | 0, $2_1 | 0, HEAP32[($4_1 + 12 | 0) >> 2] | 0 | 0, $3_1 | 0) | 0;\r\n    break label$1;\r\n   }\r\n   $6_1 = $123($0_1 | 0, $7_1 | 0, $2_1 | 0, $5_1 | 0, $3_1 | 0) | 0;\r\n   if ($6_1) {\r\n    break label$1\r\n   }\r\n   $6_1 = $124($0_1 | 0, $7_1 | 0, $1_1 | 0, $2_1 | 0, $5_1 | 0, $3_1 | 0) | 0;\r\n  }\r\n  global$0 = $4_1 + 16 | 0;\r\n  return $6_1 | 0;\r\n }\r\n \r\n function $121($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $2_1 = 0, $3_1 = 0;\r\n  $2_1 = HEAP32[$1_1 >> 2] | 0;\r\n  $3_1 = HEAP32[($2_1 + -8 | 0) >> 2] | 0;\r\n  HEAP32[($0_1 + 8 | 0) >> 2] = $3_1;\r\n  HEAP32[$0_1 >> 2] = $1_1 + $3_1 | 0;\r\n  HEAP32[($0_1 + 4 | 0) >> 2] = HEAP32[($2_1 + -4 | 0) >> 2] | 0;\r\n }\r\n \r\n function $122($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  $5_1 = $5_1 | 0;\r\n  var $6_1 = 0, i64toi32_i32$1 = 0, i64toi32_i32$0 = 0, $7_1 = 0;\r\n  $6_1 = global$0 - 64 | 0;\r\n  global$0 = $6_1;\r\n  $7_1 = 0;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (($5_1 | 0) < (0 | 0)) {\r\n     break label$2\r\n    }\r\n    $7_1 = ($4_1 | 0) == (0 - $5_1 | 0 | 0) ? $1_1 : 0;\r\n    break label$1;\r\n   }\r\n   if (($5_1 | 0) == (-2 | 0)) {\r\n    break label$1\r\n   }\r\n   $7_1 = $6_1 + 28 | 0;\r\n   i64toi32_i32$1 = $7_1;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[i64toi32_i32$1 >> 2] = 0;\r\n   HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n   i64toi32_i32$1 = $6_1 + 36 | 0;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[i64toi32_i32$1 >> 2] = 0;\r\n   HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n   i64toi32_i32$1 = $6_1 + 44 | 0;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[i64toi32_i32$1 >> 2] = 0;\r\n   HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n   i64toi32_i32$1 = $6_1;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[($6_1 + 20 | 0) >> 2] = 0;\r\n   HEAP32[($6_1 + 24 | 0) >> 2] = i64toi32_i32$0;\r\n   HEAP32[($6_1 + 16 | 0) >> 2] = $5_1;\r\n   HEAP32[($6_1 + 12 | 0) >> 2] = $2_1;\r\n   HEAP32[($6_1 + 8 | 0) >> 2] = $0_1;\r\n   HEAP32[($6_1 + 4 | 0) >> 2] = $3_1;\r\n   HEAP32[($6_1 + 60 | 0) >> 2] = 0;\r\n   i64toi32_i32$1 = $6_1;\r\n   i64toi32_i32$0 = 16777216;\r\n   HEAP32[($6_1 + 52 | 0) >> 2] = 1;\r\n   HEAP32[($6_1 + 56 | 0) >> 2] = i64toi32_i32$0;\r\n   FUNCTION_TABLE[HEAP32[((HEAP32[$3_1 >> 2] | 0) + 20 | 0) >> 2] | 0 | 0]($3_1, $6_1 + 4 | 0, $1_1, $1_1, 1, 0);\r\n   $7_1 = (HEAP32[$7_1 >> 2] | 0 | 0) == (1 | 0) ? $1_1 : 0;\r\n  }\r\n  global$0 = $6_1 + 64 | 0;\r\n  return $7_1 | 0;\r\n }\r\n \r\n function $123($0_1, $1_1, $2_1, $3_1, $4_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  var $5_1 = 0, i64toi32_i32$1 = 0, i64toi32_i32$0 = 0, $6_1 = 0;\r\n  $5_1 = global$0 - 64 | 0;\r\n  global$0 = $5_1;\r\n  $6_1 = 0;\r\n  label$1 : {\r\n   if (($4_1 | 0) < (0 | 0)) {\r\n    break label$1\r\n   }\r\n   $0_1 = $0_1 - $4_1 | 0;\r\n   if (($0_1 | 0) < ($1_1 | 0)) {\r\n    break label$1\r\n   }\r\n   $6_1 = $5_1 + 28 | 0;\r\n   i64toi32_i32$1 = $6_1;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[i64toi32_i32$1 >> 2] = 0;\r\n   HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n   i64toi32_i32$1 = $5_1 + 36 | 0;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[i64toi32_i32$1 >> 2] = 0;\r\n   HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n   i64toi32_i32$1 = $5_1 + 44 | 0;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[i64toi32_i32$1 >> 2] = 0;\r\n   HEAP32[(i64toi32_i32$1 + 4 | 0) >> 2] = i64toi32_i32$0;\r\n   i64toi32_i32$1 = $5_1;\r\n   i64toi32_i32$0 = 0;\r\n   HEAP32[($5_1 + 20 | 0) >> 2] = 0;\r\n   HEAP32[($5_1 + 24 | 0) >> 2] = i64toi32_i32$0;\r\n   HEAP32[($5_1 + 16 | 0) >> 2] = $4_1;\r\n   HEAP32[($5_1 + 12 | 0) >> 2] = $2_1;\r\n   HEAP32[($5_1 + 4 | 0) >> 2] = $3_1;\r\n   HEAP32[($5_1 + 60 | 0) >> 2] = 0;\r\n   i64toi32_i32$1 = $5_1;\r\n   i64toi32_i32$0 = 16777216;\r\n   HEAP32[($5_1 + 52 | 0) >> 2] = 1;\r\n   HEAP32[($5_1 + 56 | 0) >> 2] = i64toi32_i32$0;\r\n   HEAP32[($5_1 + 8 | 0) >> 2] = $0_1;\r\n   FUNCTION_TABLE[HEAP32[((HEAP32[$3_1 >> 2] | 0) + 20 | 0) >> 2] | 0 | 0]($3_1, $5_1 + 4 | 0, $1_1, $1_1, 1, 0);\r\n   $6_1 = HEAP32[$6_1 >> 2] | 0 ? $0_1 : 0;\r\n  }\r\n  global$0 = $5_1 + 64 | 0;\r\n  return $6_1 | 0;\r\n }\r\n \r\n function $124($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  $5_1 = $5_1 | 0;\r\n  var $6_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0, wasm2js_i32$3 = 0, wasm2js_i32$4 = 0, wasm2js_i32$5 = 0, wasm2js_i32$6 = 0, wasm2js_i32$7 = 0, wasm2js_i32$8 = 0;\r\n  $6_1 = global$0 - 64 | 0;\r\n  global$0 = $6_1;\r\n  HEAP32[($6_1 + 16 | 0) >> 2] = $5_1;\r\n  HEAP32[($6_1 + 12 | 0) >> 2] = $2_1;\r\n  HEAP32[($6_1 + 8 | 0) >> 2] = $0_1;\r\n  HEAP32[($6_1 + 4 | 0) >> 2] = $3_1;\r\n  $5_1 = 0;\r\n  $73($6_1 + 20 | 0 | 0, 0 | 0, 39 | 0) | 0;\r\n  HEAP32[($6_1 + 60 | 0) >> 2] = 0;\r\n  HEAP8[($6_1 + 59 | 0) >> 0] = 1;\r\n  FUNCTION_TABLE[HEAP32[((HEAP32[$4_1 >> 2] | 0) + 24 | 0) >> 2] | 0 | 0]($4_1, $6_1 + 4 | 0, $1_1, 1, 0);\r\n  label$1 : {\r\n   label$2 : {\r\n    switch (HEAP32[($6_1 + 40 | 0) >> 2] | 0 | 0) {\r\n    case 0:\r\n     $5_1 = (wasm2js_i32$0 = (wasm2js_i32$3 = (wasm2js_i32$6 = HEAP32[($6_1 + 24 | 0) >> 2] | 0, wasm2js_i32$7 = 0, wasm2js_i32$8 = (HEAP32[($6_1 + 36 | 0) >> 2] | 0 | 0) == (1 | 0), wasm2js_i32$8 ? wasm2js_i32$6 : wasm2js_i32$7), wasm2js_i32$4 = 0, wasm2js_i32$5 = (HEAP32[($6_1 + 32 | 0) >> 2] | 0 | 0) == (1 | 0), wasm2js_i32$5 ? wasm2js_i32$3 : wasm2js_i32$4), wasm2js_i32$1 = 0, wasm2js_i32$2 = (HEAP32[($6_1 + 44 | 0) >> 2] | 0 | 0) == (1 | 0), wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);\r\n     break label$1;\r\n    case 1:\r\n     break label$2;\r\n    default:\r\n     break label$1;\r\n    };\r\n   }\r\n   label$4 : {\r\n    if ((HEAP32[($6_1 + 28 | 0) >> 2] | 0 | 0) == (1 | 0)) {\r\n     break label$4\r\n    }\r\n    if (HEAP32[($6_1 + 44 | 0) >> 2] | 0) {\r\n     break label$1\r\n    }\r\n    if ((HEAP32[($6_1 + 32 | 0) >> 2] | 0 | 0) != (1 | 0)) {\r\n     break label$1\r\n    }\r\n    if ((HEAP32[($6_1 + 36 | 0) >> 2] | 0 | 0) != (1 | 0)) {\r\n     break label$1\r\n    }\r\n   }\r\n   $5_1 = HEAP32[($6_1 + 20 | 0) >> 2] | 0;\r\n  }\r\n  global$0 = $6_1 + 64 | 0;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $125($0_1, $1_1, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  var $4_1 = 0;\r\n  label$1 : {\r\n   $4_1 = HEAP32[($1_1 + 36 | 0) >> 2] | 0;\r\n   if ($4_1) {\r\n    break label$1\r\n   }\r\n   HEAP32[($1_1 + 24 | 0) >> 2] = $3_1;\r\n   HEAP32[($1_1 + 16 | 0) >> 2] = $2_1;\r\n   HEAP32[($1_1 + 36 | 0) >> 2] = 1;\r\n   HEAP32[($1_1 + 20 | 0) >> 2] = HEAP32[($1_1 + 56 | 0) >> 2] | 0;\r\n   return;\r\n  }\r\n  label$2 : {\r\n   label$3 : {\r\n    if ((HEAP32[($1_1 + 20 | 0) >> 2] | 0 | 0) != (HEAP32[($1_1 + 56 | 0) >> 2] | 0 | 0)) {\r\n     break label$3\r\n    }\r\n    if ((HEAP32[($1_1 + 16 | 0) >> 2] | 0 | 0) != ($2_1 | 0)) {\r\n     break label$3\r\n    }\r\n    if ((HEAP32[($1_1 + 24 | 0) >> 2] | 0 | 0) != (2 | 0)) {\r\n     break label$2\r\n    }\r\n    HEAP32[($1_1 + 24 | 0) >> 2] = $3_1;\r\n    return;\r\n   }\r\n   HEAP8[($1_1 + 54 | 0) >> 0] = 1;\r\n   HEAP32[($1_1 + 24 | 0) >> 2] = 2;\r\n   HEAP32[($1_1 + 36 | 0) >> 2] = $4_1 + 1 | 0;\r\n  }\r\n }\r\n \r\n function $126($0_1, $1_1, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  label$1 : {\r\n   if (!($117($0_1 | 0, HEAP32[($1_1 + 8 | 0) >> 2] | 0 | 0, 0 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $125($1_1 | 0, $1_1 | 0, $2_1 | 0, $3_1 | 0);\r\n  }\r\n }\r\n \r\n function $127($0_1, $1_1, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  label$1 : {\r\n   if (!($117($0_1 | 0, HEAP32[($1_1 + 8 | 0) >> 2] | 0 | 0, 0 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $125($1_1 | 0, $1_1 | 0, $2_1 | 0, $3_1 | 0);\r\n   return;\r\n  }\r\n  $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n  FUNCTION_TABLE[HEAP32[((HEAP32[$0_1 >> 2] | 0) + 28 | 0) >> 2] | 0 | 0]($0_1, $1_1, $2_1, $3_1);\r\n }\r\n \r\n function $128($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $3_1 = 0, $4_1 = 0;\r\n  $3_1 = 1;\r\n  label$1 : {\r\n   label$2 : {\r\n    if ((HEAPU8[($0_1 + 8 | 0) >> 0] | 0) & 24 | 0) {\r\n     break label$2\r\n    }\r\n    $3_1 = 0;\r\n    if (!$1_1) {\r\n     break label$1\r\n    }\r\n    $4_1 = $120($1_1 | 0, 67612 | 0, 67708 | 0, 0 | 0) | 0;\r\n    if (!$4_1) {\r\n     break label$1\r\n    }\r\n    $3_1 = ((HEAPU8[($4_1 + 8 | 0) >> 0] | 0) & 24 | 0 | 0) != (0 | 0);\r\n   }\r\n   $3_1 = $117($0_1 | 0, $1_1 | 0, $3_1 | 0) | 0;\r\n  }\r\n  return $3_1 | 0;\r\n }\r\n \r\n function $129($0_1, $1_1, $2_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  var $4_1 = 0, $3_1 = 0, $5_1 = 0, $6_1 = 0, wasm2js_i32$0 = 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = 0;\r\n  $3_1 = global$0 - 64 | 0;\r\n  global$0 = $3_1;\r\n  label$1 : {\r\n   label$2 : {\r\n    if (!($117($1_1 | 0, 67976 | 0, 0 | 0) | 0)) {\r\n     break label$2\r\n    }\r\n    HEAP32[$2_1 >> 2] = 0;\r\n    $4_1 = 1;\r\n    break label$1;\r\n   }\r\n   label$3 : {\r\n    if (!($128($0_1 | 0, $1_1 | 0, $1_1 | 0) | 0)) {\r\n     break label$3\r\n    }\r\n    $4_1 = 1;\r\n    $1_1 = HEAP32[$2_1 >> 2] | 0;\r\n    if (!$1_1) {\r\n     break label$1\r\n    }\r\n    HEAP32[$2_1 >> 2] = HEAP32[$1_1 >> 2] | 0;\r\n    break label$1;\r\n   }\r\n   label$4 : {\r\n    if (!$1_1) {\r\n     break label$4\r\n    }\r\n    $4_1 = 0;\r\n    $1_1 = $120($1_1 | 0, 67612 | 0, 67756 | 0, 0 | 0) | 0;\r\n    if (!$1_1) {\r\n     break label$1\r\n    }\r\n    label$5 : {\r\n     $5_1 = HEAP32[$2_1 >> 2] | 0;\r\n     if (!$5_1) {\r\n      break label$5\r\n     }\r\n     HEAP32[$2_1 >> 2] = HEAP32[$5_1 >> 2] | 0;\r\n    }\r\n    $5_1 = HEAP32[($1_1 + 8 | 0) >> 2] | 0;\r\n    $6_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n    if (($5_1 & ($6_1 ^ -1 | 0) | 0) & 7 | 0) {\r\n     break label$1\r\n    }\r\n    if ((($5_1 ^ -1 | 0) & $6_1 | 0) & 96 | 0) {\r\n     break label$1\r\n    }\r\n    $4_1 = 1;\r\n    if ($117(HEAP32[($0_1 + 12 | 0) >> 2] | 0 | 0, HEAP32[($1_1 + 12 | 0) >> 2] | 0 | 0, 0 | 0) | 0) {\r\n     break label$1\r\n    }\r\n    label$6 : {\r\n     if (!($117(HEAP32[($0_1 + 12 | 0) >> 2] | 0 | 0, 67964 | 0, 0 | 0) | 0)) {\r\n      break label$6\r\n     }\r\n     $1_1 = HEAP32[($1_1 + 12 | 0) >> 2] | 0;\r\n     if (!$1_1) {\r\n      break label$1\r\n     }\r\n     $4_1 = !($120($1_1 | 0, 67612 | 0, 67808 | 0, 0 | 0) | 0);\r\n     break label$1;\r\n    }\r\n    $5_1 = HEAP32[($0_1 + 12 | 0) >> 2] | 0;\r\n    if (!$5_1) {\r\n     break label$4\r\n    }\r\n    $4_1 = 0;\r\n    label$7 : {\r\n     $6_1 = $120($5_1 | 0, 67612 | 0, 67756 | 0, 0 | 0) | 0;\r\n     if (!$6_1) {\r\n      break label$7\r\n     }\r\n     if (!((HEAPU8[($0_1 + 8 | 0) >> 0] | 0) & 1 | 0)) {\r\n      break label$1\r\n     }\r\n     $4_1 = $130($6_1 | 0, HEAP32[($1_1 + 12 | 0) >> 2] | 0 | 0) | 0;\r\n     break label$1;\r\n    }\r\n    $4_1 = 0;\r\n    label$8 : {\r\n     $6_1 = $120($5_1 | 0, 67612 | 0, 67868 | 0, 0 | 0) | 0;\r\n     if (!$6_1) {\r\n      break label$8\r\n     }\r\n     if (!((HEAPU8[($0_1 + 8 | 0) >> 0] | 0) & 1 | 0)) {\r\n      break label$1\r\n     }\r\n     $4_1 = $131($6_1 | 0, HEAP32[($1_1 + 12 | 0) >> 2] | 0 | 0) | 0;\r\n     break label$1;\r\n    }\r\n    $4_1 = 0;\r\n    $0_1 = $120($5_1 | 0, 67612 | 0, 67660 | 0, 0 | 0) | 0;\r\n    if (!$0_1) {\r\n     break label$1\r\n    }\r\n    $1_1 = HEAP32[($1_1 + 12 | 0) >> 2] | 0;\r\n    if (!$1_1) {\r\n     break label$1\r\n    }\r\n    $4_1 = 0;\r\n    $1_1 = $120($1_1 | 0, 67612 | 0, 67660 | 0, 0 | 0) | 0;\r\n    if (!$1_1) {\r\n     break label$1\r\n    }\r\n    $4_1 = HEAP32[$2_1 >> 2] | 0;\r\n    $73($3_1 + 8 | 0 | 0, 0 | 0, 56 | 0) | 0;\r\n    HEAP8[($3_1 + 59 | 0) >> 0] = ($4_1 | 0) != (0 | 0);\r\n    HEAP32[($3_1 + 16 | 0) >> 2] = -1;\r\n    HEAP32[($3_1 + 12 | 0) >> 2] = $0_1;\r\n    HEAP32[($3_1 + 4 | 0) >> 2] = $1_1;\r\n    HEAP32[($3_1 + 52 | 0) >> 2] = 1;\r\n    FUNCTION_TABLE[HEAP32[((HEAP32[$1_1 >> 2] | 0) + 28 | 0) >> 2] | 0 | 0]($1_1, $3_1 + 4 | 0, $4_1, 1);\r\n    label$9 : {\r\n     $1_1 = HEAP32[($3_1 + 28 | 0) >> 2] | 0;\r\n     if (($1_1 | 0) != (1 | 0)) {\r\n      break label$9\r\n     }\r\n     HEAP32[$2_1 >> 2] = (wasm2js_i32$0 = HEAP32[($3_1 + 20 | 0) >> 2] | 0, wasm2js_i32$1 = 0, wasm2js_i32$2 = $4_1, wasm2js_i32$2 ? wasm2js_i32$0 : wasm2js_i32$1);\r\n    }\r\n    $4_1 = ($1_1 | 0) == (1 | 0);\r\n    break label$1;\r\n   }\r\n   $4_1 = 0;\r\n  }\r\n  global$0 = $3_1 + 64 | 0;\r\n  return $4_1 | 0;\r\n }\r\n \r\n function $130($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $2_1 = 0, $3_1 = 0;\r\n  label$1 : {\r\n   label$2 : while (1) {\r\n    label$3 : {\r\n     if ($1_1) {\r\n      break label$3\r\n     }\r\n     return 0 | 0;\r\n    }\r\n    $2_1 = 0;\r\n    $1_1 = $120($1_1 | 0, 67612 | 0, 67756 | 0, 0 | 0) | 0;\r\n    if (!$1_1) {\r\n     break label$1\r\n    }\r\n    if ((HEAP32[($1_1 + 8 | 0) >> 2] | 0) & ((HEAP32[($0_1 + 8 | 0) >> 2] | 0) ^ -1 | 0) | 0) {\r\n     break label$1\r\n    }\r\n    label$4 : {\r\n     if (!($117(HEAP32[($0_1 + 12 | 0) >> 2] | 0 | 0, HEAP32[($1_1 + 12 | 0) >> 2] | 0 | 0, 0 | 0) | 0)) {\r\n      break label$4\r\n     }\r\n     return 1 | 0;\r\n    }\r\n    if (!((HEAPU8[($0_1 + 8 | 0) >> 0] | 0) & 1 | 0)) {\r\n     break label$1\r\n    }\r\n    $3_1 = HEAP32[($0_1 + 12 | 0) >> 2] | 0;\r\n    if (!$3_1) {\r\n     break label$1\r\n    }\r\n    label$5 : {\r\n     $0_1 = $120($3_1 | 0, 67612 | 0, 67756 | 0, 0 | 0) | 0;\r\n     if (!$0_1) {\r\n      break label$5\r\n     }\r\n     $1_1 = HEAP32[($1_1 + 12 | 0) >> 2] | 0;\r\n     continue label$2;\r\n    }\r\n    break label$2;\r\n   };\r\n   $2_1 = 0;\r\n   $0_1 = $120($3_1 | 0, 67612 | 0, 67868 | 0, 0 | 0) | 0;\r\n   if (!$0_1) {\r\n    break label$1\r\n   }\r\n   $2_1 = $131($0_1 | 0, HEAP32[($1_1 + 12 | 0) >> 2] | 0 | 0) | 0;\r\n  }\r\n  return $2_1 | 0;\r\n }\r\n \r\n function $131($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  var $2_1 = 0;\r\n  $2_1 = 0;\r\n  label$1 : {\r\n   if (!$1_1) {\r\n    break label$1\r\n   }\r\n   $1_1 = $120($1_1 | 0, 67612 | 0, 67868 | 0, 0 | 0) | 0;\r\n   if (!$1_1) {\r\n    break label$1\r\n   }\r\n   if ((HEAP32[($1_1 + 8 | 0) >> 2] | 0) & ((HEAP32[($0_1 + 8 | 0) >> 2] | 0) ^ -1 | 0) | 0) {\r\n    break label$1\r\n   }\r\n   $2_1 = 0;\r\n   if (!($117(HEAP32[($0_1 + 12 | 0) >> 2] | 0 | 0, HEAP32[($1_1 + 12 | 0) >> 2] | 0 | 0, 0 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $2_1 = $117(HEAP32[($0_1 + 16 | 0) >> 2] | 0 | 0, HEAP32[($1_1 + 16 | 0) >> 2] | 0 | 0, 0 | 0) | 0;\r\n  }\r\n  return $2_1 | 0;\r\n }\r\n \r\n function $132($0_1, $1_1, $2_1, $3_1, $4_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  HEAP8[($1_1 + 53 | 0) >> 0] = 1;\r\n  label$1 : {\r\n   if (($3_1 | 0) != (HEAP32[($1_1 + 4 | 0) >> 2] | 0 | 0)) {\r\n    break label$1\r\n   }\r\n   HEAP8[($1_1 + 52 | 0) >> 0] = 1;\r\n   label$2 : {\r\n    label$3 : {\r\n     $3_1 = HEAP32[($1_1 + 16 | 0) >> 2] | 0;\r\n     if ($3_1) {\r\n      break label$3\r\n     }\r\n     HEAP32[($1_1 + 36 | 0) >> 2] = 1;\r\n     HEAP32[($1_1 + 24 | 0) >> 2] = $4_1;\r\n     HEAP32[($1_1 + 16 | 0) >> 2] = $2_1;\r\n     if (($4_1 | 0) != (1 | 0)) {\r\n      break label$1\r\n     }\r\n     if ((HEAP32[($1_1 + 48 | 0) >> 2] | 0 | 0) == (1 | 0)) {\r\n      break label$2\r\n     }\r\n     break label$1;\r\n    }\r\n    label$4 : {\r\n     if (($3_1 | 0) != ($2_1 | 0)) {\r\n      break label$4\r\n     }\r\n     label$5 : {\r\n      $3_1 = HEAP32[($1_1 + 24 | 0) >> 2] | 0;\r\n      if (($3_1 | 0) != (2 | 0)) {\r\n       break label$5\r\n      }\r\n      HEAP32[($1_1 + 24 | 0) >> 2] = $4_1;\r\n      $3_1 = $4_1;\r\n     }\r\n     if ((HEAP32[($1_1 + 48 | 0) >> 2] | 0 | 0) != (1 | 0)) {\r\n      break label$1\r\n     }\r\n     if (($3_1 | 0) == (1 | 0)) {\r\n      break label$2\r\n     }\r\n     break label$1;\r\n    }\r\n    HEAP32[($1_1 + 36 | 0) >> 2] = (HEAP32[($1_1 + 36 | 0) >> 2] | 0) + 1 | 0;\r\n   }\r\n   HEAP8[($1_1 + 54 | 0) >> 0] = 1;\r\n  }\r\n }\r\n \r\n function $133($0_1, $1_1, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  label$1 : {\r\n   if (($2_1 | 0) != (HEAP32[($1_1 + 4 | 0) >> 2] | 0 | 0)) {\r\n    break label$1\r\n   }\r\n   if ((HEAP32[($1_1 + 28 | 0) >> 2] | 0 | 0) == (1 | 0)) {\r\n    break label$1\r\n   }\r\n   HEAP32[($1_1 + 28 | 0) >> 2] = $3_1;\r\n  }\r\n }\r\n \r\n function $134($0_1, $1_1, $2_1, $3_1, $4_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  label$1 : {\r\n   if (!($117($0_1 | 0, HEAP32[($1_1 + 8 | 0) >> 2] | 0 | 0, $4_1 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $133($1_1 | 0, $1_1 | 0, $2_1 | 0, $3_1 | 0);\r\n   return;\r\n  }\r\n  label$2 : {\r\n   label$3 : {\r\n    if (!($117($0_1 | 0, HEAP32[$1_1 >> 2] | 0 | 0, $4_1 | 0) | 0)) {\r\n     break label$3\r\n    }\r\n    label$4 : {\r\n     label$5 : {\r\n      if (($2_1 | 0) == (HEAP32[($1_1 + 16 | 0) >> 2] | 0 | 0)) {\r\n       break label$5\r\n      }\r\n      if (($2_1 | 0) != (HEAP32[($1_1 + 20 | 0) >> 2] | 0 | 0)) {\r\n       break label$4\r\n      }\r\n     }\r\n     if (($3_1 | 0) != (1 | 0)) {\r\n      break label$2\r\n     }\r\n     HEAP32[($1_1 + 32 | 0) >> 2] = 1;\r\n     return;\r\n    }\r\n    HEAP32[($1_1 + 32 | 0) >> 2] = $3_1;\r\n    label$6 : {\r\n     if ((HEAP32[($1_1 + 44 | 0) >> 2] | 0 | 0) == (4 | 0)) {\r\n      break label$6\r\n     }\r\n     HEAP16[($1_1 + 52 | 0) >> 1] = 0;\r\n     $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n     FUNCTION_TABLE[HEAP32[((HEAP32[$0_1 >> 2] | 0) + 20 | 0) >> 2] | 0 | 0]($0_1, $1_1, $2_1, $2_1, 1, $4_1);\r\n     label$7 : {\r\n      if ((HEAPU8[($1_1 + 53 | 0) >> 0] | 0 | 0) != (1 | 0)) {\r\n       break label$7\r\n      }\r\n      HEAP32[($1_1 + 44 | 0) >> 2] = 3;\r\n      if (!(HEAPU8[($1_1 + 52 | 0) >> 0] | 0)) {\r\n       break label$6\r\n      }\r\n      break label$2;\r\n     }\r\n     HEAP32[($1_1 + 44 | 0) >> 2] = 4;\r\n    }\r\n    HEAP32[($1_1 + 20 | 0) >> 2] = $2_1;\r\n    HEAP32[($1_1 + 40 | 0) >> 2] = (HEAP32[($1_1 + 40 | 0) >> 2] | 0) + 1 | 0;\r\n    if ((HEAP32[($1_1 + 36 | 0) >> 2] | 0 | 0) != (1 | 0)) {\r\n     break label$2\r\n    }\r\n    if ((HEAP32[($1_1 + 24 | 0) >> 2] | 0 | 0) != (2 | 0)) {\r\n     break label$2\r\n    }\r\n    HEAP8[($1_1 + 54 | 0) >> 0] = 1;\r\n    return;\r\n   }\r\n   $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n   FUNCTION_TABLE[HEAP32[((HEAP32[$0_1 >> 2] | 0) + 24 | 0) >> 2] | 0 | 0]($0_1, $1_1, $2_1, $3_1, $4_1);\r\n  }\r\n }\r\n \r\n function $135($0_1, $1_1, $2_1, $3_1, $4_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  label$1 : {\r\n   if (!($117($0_1 | 0, HEAP32[($1_1 + 8 | 0) >> 2] | 0 | 0, $4_1 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $133($1_1 | 0, $1_1 | 0, $2_1 | 0, $3_1 | 0);\r\n   return;\r\n  }\r\n  label$2 : {\r\n   if (!($117($0_1 | 0, HEAP32[$1_1 >> 2] | 0 | 0, $4_1 | 0) | 0)) {\r\n    break label$2\r\n   }\r\n   label$3 : {\r\n    label$4 : {\r\n     if (($2_1 | 0) == (HEAP32[($1_1 + 16 | 0) >> 2] | 0 | 0)) {\r\n      break label$4\r\n     }\r\n     if (($2_1 | 0) != (HEAP32[($1_1 + 20 | 0) >> 2] | 0 | 0)) {\r\n      break label$3\r\n     }\r\n    }\r\n    if (($3_1 | 0) != (1 | 0)) {\r\n     break label$2\r\n    }\r\n    HEAP32[($1_1 + 32 | 0) >> 2] = 1;\r\n    return;\r\n   }\r\n   HEAP32[($1_1 + 20 | 0) >> 2] = $2_1;\r\n   HEAP32[($1_1 + 32 | 0) >> 2] = $3_1;\r\n   HEAP32[($1_1 + 40 | 0) >> 2] = (HEAP32[($1_1 + 40 | 0) >> 2] | 0) + 1 | 0;\r\n   label$5 : {\r\n    if ((HEAP32[($1_1 + 36 | 0) >> 2] | 0 | 0) != (1 | 0)) {\r\n     break label$5\r\n    }\r\n    if ((HEAP32[($1_1 + 24 | 0) >> 2] | 0 | 0) != (2 | 0)) {\r\n     break label$5\r\n    }\r\n    HEAP8[($1_1 + 54 | 0) >> 0] = 1;\r\n   }\r\n   HEAP32[($1_1 + 44 | 0) >> 2] = 4;\r\n  }\r\n }\r\n \r\n function $136($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  $5_1 = $5_1 | 0;\r\n  label$1 : {\r\n   if (!($117($0_1 | 0, HEAP32[($1_1 + 8 | 0) >> 2] | 0 | 0, $5_1 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $132($1_1 | 0, $1_1 | 0, $2_1 | 0, $3_1 | 0, $4_1 | 0);\r\n   return;\r\n  }\r\n  $0_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n  FUNCTION_TABLE[HEAP32[((HEAP32[$0_1 >> 2] | 0) + 20 | 0) >> 2] | 0 | 0]($0_1, $1_1, $2_1, $3_1, $4_1, $5_1);\r\n }\r\n \r\n function $137($0_1, $1_1, $2_1, $3_1, $4_1, $5_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  $5_1 = $5_1 | 0;\r\n  label$1 : {\r\n   if (!($117($0_1 | 0, HEAP32[($1_1 + 8 | 0) >> 2] | 0 | 0, $5_1 | 0) | 0)) {\r\n    break label$1\r\n   }\r\n   $132($1_1 | 0, $1_1 | 0, $2_1 | 0, $3_1 | 0, $4_1 | 0);\r\n  }\r\n }\r\n \r\n function $138($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return $0_1 | 0;\r\n }\r\n \r\n function $139($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  global$1 = $0_1;\r\n }\r\n \r\n function $141() {\r\n  global$3 = 65536;\r\n  global$2 = (0 + 15 | 0) & -16 | 0;\r\n }\r\n \r\n function $142() {\r\n  return global$0 - global$2 | 0 | 0;\r\n }\r\n \r\n function $143() {\r\n  return global$3 | 0;\r\n }\r\n \r\n function $144() {\r\n  return global$2 | 0;\r\n }\r\n \r\n function $145($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $1_1 = 0, i64toi32_i32$1 = 0, $2_1 = 0, i64toi32_i32$0 = 0, $3_1 = 0;\r\n  label$1 : {\r\n   if ($0_1) {\r\n    break label$1\r\n   }\r\n   $1_1 = 0;\r\n   label$2 : {\r\n    if (!(HEAP32[(0 + 71552 | 0) >> 2] | 0)) {\r\n     break label$2\r\n    }\r\n    $1_1 = $145(HEAP32[(0 + 71552 | 0) >> 2] | 0 | 0) | 0;\r\n   }\r\n   label$3 : {\r\n    if (!(HEAP32[(0 + 70720 | 0) >> 2] | 0)) {\r\n     break label$3\r\n    }\r\n    $1_1 = $145(HEAP32[(0 + 70720 | 0) >> 2] | 0 | 0) | 0 | $1_1 | 0;\r\n   }\r\n   label$4 : {\r\n    $0_1 = HEAP32[($102() | 0) >> 2] | 0;\r\n    if (!$0_1) {\r\n     break label$4\r\n    }\r\n    label$5 : while (1) {\r\n     label$6 : {\r\n      label$7 : {\r\n       if ((HEAP32[($0_1 + 76 | 0) >> 2] | 0 | 0) >= (0 | 0)) {\r\n        break label$7\r\n       }\r\n       $2_1 = 1;\r\n       break label$6;\r\n      }\r\n      $2_1 = !($104($0_1 | 0) | 0);\r\n     }\r\n     label$8 : {\r\n      if ((HEAP32[($0_1 + 20 | 0) >> 2] | 0 | 0) == (HEAP32[($0_1 + 28 | 0) >> 2] | 0 | 0)) {\r\n       break label$8\r\n      }\r\n      $1_1 = $145($0_1 | 0) | 0 | $1_1 | 0;\r\n     }\r\n     label$9 : {\r\n      if ($2_1) {\r\n       break label$9\r\n      }\r\n      $105($0_1 | 0);\r\n     }\r\n     $0_1 = HEAP32[($0_1 + 56 | 0) >> 2] | 0;\r\n     if ($0_1) {\r\n      continue label$5\r\n     }\r\n     break label$5;\r\n    };\r\n   }\r\n   $103();\r\n   return $1_1 | 0;\r\n  }\r\n  label$10 : {\r\n   label$11 : {\r\n    if ((HEAP32[($0_1 + 76 | 0) >> 2] | 0 | 0) >= (0 | 0)) {\r\n     break label$11\r\n    }\r\n    $2_1 = 1;\r\n    break label$10;\r\n   }\r\n   $2_1 = !($104($0_1 | 0) | 0);\r\n  }\r\n  label$12 : {\r\n   label$13 : {\r\n    label$14 : {\r\n     if ((HEAP32[($0_1 + 20 | 0) >> 2] | 0 | 0) == (HEAP32[($0_1 + 28 | 0) >> 2] | 0 | 0)) {\r\n      break label$14\r\n     }\r\n     FUNCTION_TABLE[HEAP32[($0_1 + 36 | 0) >> 2] | 0 | 0]($0_1, 0, 0) | 0;\r\n     if (HEAP32[($0_1 + 20 | 0) >> 2] | 0) {\r\n      break label$14\r\n     }\r\n     $1_1 = -1;\r\n     if (!$2_1) {\r\n      break label$13\r\n     }\r\n     break label$12;\r\n    }\r\n    label$15 : {\r\n     $1_1 = HEAP32[($0_1 + 4 | 0) >> 2] | 0;\r\n     $3_1 = HEAP32[($0_1 + 8 | 0) >> 2] | 0;\r\n     if (($1_1 | 0) == ($3_1 | 0)) {\r\n      break label$15\r\n     }\r\n     i64toi32_i32$1 = $1_1 - $3_1 | 0;\r\n     i64toi32_i32$0 = i64toi32_i32$1 >> 31 | 0;\r\n     i64toi32_i32$0 = FUNCTION_TABLE[HEAP32[($0_1 + 40 | 0) >> 2] | 0 | 0]($0_1, i64toi32_i32$1, i64toi32_i32$0, 1) | 0;\r\n     i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;\r\n    }\r\n    $1_1 = 0;\r\n    HEAP32[($0_1 + 28 | 0) >> 2] = 0;\r\n    i64toi32_i32$0 = $0_1;\r\n    i64toi32_i32$1 = 0;\r\n    HEAP32[($0_1 + 16 | 0) >> 2] = 0;\r\n    HEAP32[($0_1 + 20 | 0) >> 2] = i64toi32_i32$1;\r\n    i64toi32_i32$0 = $0_1;\r\n    i64toi32_i32$1 = 0;\r\n    HEAP32[($0_1 + 4 | 0) >> 2] = 0;\r\n    HEAP32[($0_1 + 8 | 0) >> 2] = i64toi32_i32$1;\r\n    if ($2_1) {\r\n     break label$12\r\n    }\r\n   }\r\n   $105($0_1 | 0);\r\n  }\r\n  return $1_1 | 0;\r\n }\r\n \r\n function $146($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  global$0 = $0_1;\r\n }\r\n \r\n function $147($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  var $1_1 = 0;\r\n  $1_1 = (global$0 - $0_1 | 0) & -16 | 0;\r\n  global$0 = $1_1;\r\n  return $1_1 | 0;\r\n }\r\n \r\n function $148() {\r\n  return global$0 | 0;\r\n }\r\n \r\n function $149($0_1, $1_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  return (HEAPU16[((($0_1 >>> 0 > 153 >>> 0 ? 0 : $0_1) << 1 | 0) + 70256 | 0) >> 1] | 0) + 68336 | 0 | 0;\r\n }\r\n \r\n function $150($0_1) {\r\n  $0_1 = $0_1 | 0;\r\n  return $149($0_1 | 0, $0_1 | 0) | 0 | 0;\r\n }\r\n \r\n function $151($0_1, $1_1, $2_1, $2$hi, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $2$hi = $2$hi | 0;\r\n  $3_1 = $3_1 | 0;\r\n  var i64toi32_i32$0 = 0, i64toi32_i32$1 = 0;\r\n  i64toi32_i32$0 = $2$hi;\r\n  i64toi32_i32$0 = FUNCTION_TABLE[$0_1 | 0]($1_1, $2_1, i64toi32_i32$0, $3_1) | 0;\r\n  i64toi32_i32$1 = i64toi32_i32$HIGH_BITS;\r\n  i64toi32_i32$HIGH_BITS = i64toi32_i32$1;\r\n  return i64toi32_i32$0 | 0;\r\n }\r\n \r\n function $152($0_1, $1_1, $2_1, $3_1, $4_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $4_1 = $4_1 | 0;\r\n  var i64toi32_i32$2 = 0, i64toi32_i32$4 = 0, i64toi32_i32$0 = 0, i64toi32_i32$1 = 0, i64toi32_i32$3 = 0, $17_1 = 0, $18_1 = 0, $6_1 = 0, $7_1 = 0, $9_1 = 0, $9$hi = 0, $12$hi = 0, $5_1 = 0, $5$hi = 0;\r\n  $6_1 = $0_1;\r\n  $7_1 = $1_1;\r\n  i64toi32_i32$0 = 0;\r\n  $9_1 = $2_1;\r\n  $9$hi = i64toi32_i32$0;\r\n  i64toi32_i32$0 = 0;\r\n  i64toi32_i32$2 = $3_1;\r\n  i64toi32_i32$1 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;\r\n   $17_1 = 0;\r\n  } else {\r\n   i64toi32_i32$1 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$2 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$0 << i64toi32_i32$4 | 0) | 0;\r\n   $17_1 = i64toi32_i32$2 << i64toi32_i32$4 | 0;\r\n  }\r\n  $12$hi = i64toi32_i32$1;\r\n  i64toi32_i32$1 = $9$hi;\r\n  i64toi32_i32$0 = $9_1;\r\n  i64toi32_i32$2 = $12$hi;\r\n  i64toi32_i32$3 = $17_1;\r\n  i64toi32_i32$2 = i64toi32_i32$1 | i64toi32_i32$2 | 0;\r\n  i64toi32_i32$2 = $151($6_1 | 0, $7_1 | 0, i64toi32_i32$0 | i64toi32_i32$3 | 0 | 0, i64toi32_i32$2 | 0, $4_1 | 0) | 0;\r\n  i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;\r\n  $5_1 = i64toi32_i32$2;\r\n  $5$hi = i64toi32_i32$0;\r\n  i64toi32_i32$1 = i64toi32_i32$2;\r\n  i64toi32_i32$2 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$2 = 0;\r\n   $18_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n  } else {\r\n   i64toi32_i32$2 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n   $18_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$1 >>> i64toi32_i32$4 | 0) | 0;\r\n  }\r\n  $139($18_1 | 0);\r\n  i64toi32_i32$2 = $5$hi;\r\n  return $5_1 | 0;\r\n }\r\n \r\n function $153($0_1, $1_1, $2_1, $3_1, $3$hi, $4_1, $4$hi) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  $3$hi = $3$hi | 0;\r\n  $4_1 = $4_1 | 0;\r\n  $4$hi = $4$hi | 0;\r\n  var i64toi32_i32$4 = 0, i64toi32_i32$1 = 0, i64toi32_i32$0 = 0, i64toi32_i32$3 = 0, i64toi32_i32$2 = 0, $18_1 = 0, $19_1 = 0, $5_1 = 0, $6_1 = 0, $7_1 = 0, $9_1 = 0, $12_1 = 0, $14_1 = 0;\r\n  $5_1 = $0_1;\r\n  $6_1 = $1_1;\r\n  $7_1 = $2_1;\r\n  i64toi32_i32$0 = $3$hi;\r\n  $9_1 = $3_1;\r\n  i64toi32_i32$2 = $3_1;\r\n  i64toi32_i32$1 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$1 = 0;\r\n   $18_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n  } else {\r\n   i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n   $18_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;\r\n  }\r\n  $12_1 = $18_1;\r\n  i64toi32_i32$1 = $4$hi;\r\n  $14_1 = $4_1;\r\n  i64toi32_i32$0 = $4_1;\r\n  i64toi32_i32$2 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$2 = 0;\r\n   $19_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;\r\n  } else {\r\n   i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;\r\n   $19_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;\r\n  }\r\n  fimport$22($5_1 | 0, $6_1 | 0, $7_1 | 0, $9_1 | 0, $12_1 | 0, $14_1 | 0, $19_1 | 0);\r\n }\r\n \r\n function $154($0_1, $1_1, $1$hi, $2_1, $3_1) {\r\n  $0_1 = $0_1 | 0;\r\n  $1_1 = $1_1 | 0;\r\n  $1$hi = $1$hi | 0;\r\n  $2_1 = $2_1 | 0;\r\n  $3_1 = $3_1 | 0;\r\n  var i64toi32_i32$4 = 0, i64toi32_i32$0 = 0, i64toi32_i32$1 = 0, i64toi32_i32$3 = 0, $12_1 = 0, $4_1 = 0, $6_1 = 0, i64toi32_i32$2 = 0;\r\n  $4_1 = $0_1;\r\n  i64toi32_i32$0 = $1$hi;\r\n  $6_1 = $1_1;\r\n  i64toi32_i32$2 = $1_1;\r\n  i64toi32_i32$1 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$1 = 0;\r\n   $12_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n  } else {\r\n   i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n   $12_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;\r\n  }\r\n  return fimport$23($4_1 | 0, $6_1 | 0, $12_1 | 0, $2_1 | 0, $3_1 | 0) | 0 | 0;\r\n }\r\n \r\n function _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE(var$0, var$0$hi, var$1, var$1$hi) {\r\n  var$0 = var$0 | 0;\r\n  var$0$hi = var$0$hi | 0;\r\n  var$1 = var$1 | 0;\r\n  var$1$hi = var$1$hi | 0;\r\n  var i64toi32_i32$4 = 0, i64toi32_i32$0 = 0, i64toi32_i32$1 = 0, var$2 = 0, i64toi32_i32$2 = 0, i64toi32_i32$3 = 0, var$3 = 0, var$4 = 0, var$5 = 0, $21_1 = 0, $22_1 = 0, var$6 = 0, $24_1 = 0, $17_1 = 0, $18_1 = 0, $23_1 = 0, $29_1 = 0, $45_1 = 0, $56$hi = 0, $62$hi = 0;\r\n  i64toi32_i32$0 = var$1$hi;\r\n  var$2 = var$1;\r\n  var$4 = var$2 >>> 16 | 0;\r\n  i64toi32_i32$0 = var$0$hi;\r\n  var$3 = var$0;\r\n  var$5 = var$3 >>> 16 | 0;\r\n  $17_1 = Math_imul(var$4, var$5);\r\n  $18_1 = var$2;\r\n  i64toi32_i32$2 = var$3;\r\n  i64toi32_i32$1 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$1 = 0;\r\n   $21_1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n  } else {\r\n   i64toi32_i32$1 = i64toi32_i32$0 >>> i64toi32_i32$4 | 0;\r\n   $21_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$0 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$2 >>> i64toi32_i32$4 | 0) | 0;\r\n  }\r\n  $23_1 = $17_1 + Math_imul($18_1, $21_1) | 0;\r\n  i64toi32_i32$1 = var$1$hi;\r\n  i64toi32_i32$0 = var$1;\r\n  i64toi32_i32$2 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$2 = 0;\r\n   $22_1 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;\r\n  } else {\r\n   i64toi32_i32$2 = i64toi32_i32$1 >>> i64toi32_i32$4 | 0;\r\n   $22_1 = (((1 << i64toi32_i32$4 | 0) - 1 | 0) & i64toi32_i32$1 | 0) << (32 - i64toi32_i32$4 | 0) | 0 | (i64toi32_i32$0 >>> i64toi32_i32$4 | 0) | 0;\r\n  }\r\n  $29_1 = $23_1 + Math_imul($22_1, var$3) | 0;\r\n  var$2 = var$2 & 65535 | 0;\r\n  var$3 = var$3 & 65535 | 0;\r\n  var$6 = Math_imul(var$2, var$3);\r\n  var$2 = (var$6 >>> 16 | 0) + Math_imul(var$2, var$5) | 0;\r\n  $45_1 = $29_1 + (var$2 >>> 16 | 0) | 0;\r\n  var$2 = (var$2 & 65535 | 0) + Math_imul(var$4, var$3) | 0;\r\n  i64toi32_i32$2 = 0;\r\n  i64toi32_i32$1 = $45_1 + (var$2 >>> 16 | 0) | 0;\r\n  i64toi32_i32$0 = 0;\r\n  i64toi32_i32$3 = 32;\r\n  i64toi32_i32$4 = i64toi32_i32$3 & 31 | 0;\r\n  if (32 >>> 0 <= (i64toi32_i32$3 & 63 | 0) >>> 0) {\r\n   i64toi32_i32$0 = i64toi32_i32$1 << i64toi32_i32$4 | 0;\r\n   $24_1 = 0;\r\n  } else {\r\n   i64toi32_i32$0 = ((1 << i64toi32_i32$4 | 0) - 1 | 0) & (i64toi32_i32$1 >>> (32 - i64toi32_i32$4 | 0) | 0) | 0 | (i64toi32_i32$2 << i64toi32_i32$4 | 0) | 0;\r\n   $24_1 = i64toi32_i32$1 << i64toi32_i32$4 | 0;\r\n  }\r\n  $56$hi = i64toi32_i32$0;\r\n  i64toi32_i32$0 = 0;\r\n  $62$hi = i64toi32_i32$0;\r\n  i64toi32_i32$0 = $56$hi;\r\n  i64toi32_i32$2 = $24_1;\r\n  i64toi32_i32$1 = $62$hi;\r\n  i64toi32_i32$3 = var$2 << 16 | 0 | (var$6 & 65535 | 0) | 0;\r\n  i64toi32_i32$1 = i64toi32_i32$0 | i64toi32_i32$1 | 0;\r\n  i64toi32_i32$2 = i64toi32_i32$2 | i64toi32_i32$3 | 0;\r\n  i64toi32_i32$HIGH_BITS = i64toi32_i32$1;\r\n  return i64toi32_i32$2 | 0;\r\n }\r\n \r\n function __wasm_ctz_i32(var$0) {\r\n  var$0 = var$0 | 0;\r\n  if (var$0) {\r\n   return 31 - Math_clz32((var$0 + -1 | 0) ^ var$0 | 0) | 0 | 0\r\n  }\r\n  return 32 | 0;\r\n }\r\n \r\n function __wasm_i64_mul(var$0, var$0$hi, var$1, var$1$hi) {\r\n  var$0 = var$0 | 0;\r\n  var$0$hi = var$0$hi | 0;\r\n  var$1 = var$1 | 0;\r\n  var$1$hi = var$1$hi | 0;\r\n  var i64toi32_i32$0 = 0, i64toi32_i32$1 = 0;\r\n  i64toi32_i32$0 = var$0$hi;\r\n  i64toi32_i32$0 = var$1$hi;\r\n  i64toi32_i32$0 = var$0$hi;\r\n  i64toi32_i32$1 = var$1$hi;\r\n  i64toi32_i32$1 = _ZN17compiler_builtins3int3mul3Mul3mul17h070e9a1c69faec5bE(var$0 | 0, i64toi32_i32$0 | 0, var$1 | 0, i64toi32_i32$1 | 0) | 0;\r\n  i64toi32_i32$0 = i64toi32_i32$HIGH_BITS;\r\n  i64toi32_i32$HIGH_BITS = i64toi32_i32$0;\r\n  return i64toi32_i32$1 | 0;\r\n }\r\n \r\n function __wasm_rotl_i32(var$0, var$1) {\r\n  var$0 = var$0 | 0;\r\n  var$1 = var$1 | 0;\r\n  var var$2 = 0;\r\n  var$2 = var$1 & 31 | 0;\r\n  var$1 = (0 - var$1 | 0) & 31 | 0;\r\n  return ((-1 >>> var$2 | 0) & var$0 | 0) << var$2 | 0 | (((-1 << var$1 | 0) & var$0 | 0) >>> var$1 | 0) | 0 | 0;\r\n }\r\n \r\n // EMSCRIPTEN_END_FUNCS\r\n;\r\n bufferView = HEAPU8;\r\n initActiveSegments(imports);\r\n var FUNCTION_TABLE = Table([null, $3, $7, $10, $13, $21, $23, $25, $33, $38, $45, fimport$13, $96, $97, $99, $109, $112, $110, $111, $116, $113, $119, $137, $135, $126, $114, $136, $134, $127, $115, $129]);\r\n function __wasm_memory_size() {\r\n  return buffer.byteLength / 65536 | 0;\r\n }\r\n \r\n return {\r\n  \"memory\": Object.create(Object.prototype, {\r\n   \"grow\": {\r\n    \r\n   }, \r\n   \"buffer\": {\r\n    \"get\": function () {\r\n     return buffer;\r\n    }\r\n    \r\n   }\r\n  }), \r\n  \"__wasm_call_ctors\": $0, \r\n  \"__getTypeName\": $1, \r\n  \"__indirect_function_table\": FUNCTION_TABLE, \r\n  \"fflush\": $145, \r\n  \"malloc\": $84, \r\n  \"strerror\": $150, \r\n  \"free\": $86, \r\n  \"emscripten_stack_init\": $141, \r\n  \"emscripten_stack_get_free\": $142, \r\n  \"emscripten_stack_get_base\": $143, \r\n  \"emscripten_stack_get_end\": $144, \r\n  \"_emscripten_stack_restore\": $146, \r\n  \"_emscripten_stack_alloc\": $147, \r\n  \"emscripten_stack_get_current\": $148, \r\n  \"__start_em_asm\": {\r\n   get value() {\r\n    return global$4;\r\n   }, \r\n   set value(_global$4) {\r\n    global$4 = _global$4;\r\n   }\r\n  }, \r\n  \"__stop_em_asm\": {\r\n   get value() {\r\n    return global$5;\r\n   }, \r\n   set value(_global$5) {\r\n    global$5 = _global$5;\r\n   }\r\n  }, \r\n  \"dynCall_jiji\": $152\r\n };\r\n}\r\n\r\n  return asmFunc(info);\r\n}\r\n\r\n)(info);\r\n  },\r\n\r\n  instantiate: /** @suppress{checkTypes} */ function(binary, info) {\r\n    return {\r\n      then: function(ok) {\r\n        var module = new WebAssembly.Module(binary);\r\n        ok({\r\n          'instance': new WebAssembly.Instance(module, info)\r\n        });\r\n        // Emulate a simple WebAssembly.instantiate(..).then(()=>{}).catch(()=>{}) syntax.\r\n        return { catch: function() {} };\r\n      }\r\n    };\r\n  },\r\n\r\n  RuntimeError: Error,\r\n\r\n  isWasm2js: true,\r\n};\r\n// end include: wasm2js.js\r\nif (WebAssembly.isWasm2js) {\r\n  // We don't need to actually download a wasm binary, mark it as present but\r\n  // empty.\r\n  wasmBinary = [];\r\n}\r\n\r\nif (typeof WebAssembly != 'object') {\r\n  err('no native wasm support detected');\r\n}\r\n\r\n// Wasm globals\r\n\r\nvar wasmMemory;\r\n\r\n//========================================\r\n// Runtime essentials\r\n//========================================\r\n\r\n// whether we are quitting the application. no code should run after this.\r\n// set in exit() and abort()\r\nvar ABORT = false;\r\n\r\n// set by exit() and abort().  Passed to 'onExit' handler.\r\n// NOTE: This is also used as the process return code code in shell environments\r\n// but only when noExitRuntime is false.\r\nvar EXITSTATUS;\r\n\r\n// In STRICT mode, we only define assert() when ASSERTIONS is set.  i.e. we\r\n// don't define it at all in release modes.  This matches the behaviour of\r\n// MINIMAL_RUNTIME.\r\n// TODO(sbc): Make this the default even without STRICT enabled.\r\n/** @type {function(*, string=)} */\r\nfunction assert(condition, text) {\r\n  if (!condition) {\r\n    abort('Assertion failed' + (text ? ': ' + text : ''));\r\n  }\r\n}\r\n\r\n// We used to include malloc/free by default in the past. Show a helpful error in\r\n// builds with assertions.\r\n\r\n// Memory management\r\n\r\nvar HEAP,\r\n/** @type {!Int8Array} */\r\n  HEAP8,\r\n/** @type {!Uint8Array} */\r\n  HEAPU8,\r\n/** @type {!Int16Array} */\r\n  HEAP16,\r\n/** @type {!Uint16Array} */\r\n  HEAPU16,\r\n/** @type {!Int32Array} */\r\n  HEAP32,\r\n/** @type {!Uint32Array} */\r\n  HEAPU32,\r\n/** @type {!Float32Array} */\r\n  HEAPF32,\r\n/** @type {!Float64Array} */\r\n  HEAPF64;\r\n\r\n// include: runtime_shared.js\r\nfunction updateMemoryViews() {\r\n  var b = wasmMemory.buffer;\r\n  Module['HEAP8'] = HEAP8 = new Int8Array(b);\r\n  Module['HEAP16'] = HEAP16 = new Int16Array(b);\r\n  Module['HEAPU8'] = HEAPU8 = new Uint8Array(b);\r\n  Module['HEAPU16'] = HEAPU16 = new Uint16Array(b);\r\n  Module['HEAP32'] = HEAP32 = new Int32Array(b);\r\n  Module['HEAPU32'] = HEAPU32 = new Uint32Array(b);\r\n  Module['HEAPF32'] = HEAPF32 = new Float32Array(b);\r\n  Module['HEAPF64'] = HEAPF64 = new Float64Array(b);\r\n}\r\n\r\n// end include: runtime_shared.js\r\nassert(!Module['STACK_SIZE'], 'STACK_SIZE can no longer be set at runtime.  Use -sSTACK_SIZE at link time')\r\n\r\nassert(typeof Int32Array != 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray != undefined && Int32Array.prototype.set != undefined,\r\n       'JS engine does not provide full typed array support');\r\n\r\n// If memory is defined in wasm, the user can't provide it, or set INITIAL_MEMORY\r\nassert(!Module['wasmMemory'], 'Use of `wasmMemory` detected.  Use -sIMPORTED_MEMORY to define wasmMemory externally');\r\nassert(!Module['INITIAL_MEMORY'], 'Detected runtime INITIAL_MEMORY setting.  Use -sIMPORTED_MEMORY to define wasmMemory dynamically');\r\n\r\n// include: runtime_stack_check.js\r\n// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.\r\nfunction writeStackCookie() {\r\n  var max = _emscripten_stack_get_end();\r\n  assert((max & 3) == 0);\r\n  // If the stack ends at address zero we write our cookies 4 bytes into the\r\n  // stack.  This prevents interference with SAFE_HEAP and ASAN which also\r\n  // monitor writes to address zero.\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  // The stack grow downwards towards _emscripten_stack_get_end.\r\n  // We write cookies to the final two words in the stack and detect if they are\r\n  // ever overwritten.\r\n  HEAPU32[((max)>>2)] = 0x02135467;\r\n  HEAPU32[(((max)+(4))>>2)] = 0x89BACDFE;\r\n  // Also test the global address 0 for integrity.\r\n  HEAPU32[((0)>>2)] = 1668509029;\r\n}\r\n\r\nfunction checkStackCookie() {\r\n  if (ABORT) return;\r\n  var max = _emscripten_stack_get_end();\r\n  // See writeStackCookie().\r\n  if (max == 0) {\r\n    max += 4;\r\n  }\r\n  var cookie1 = HEAPU32[((max)>>2)];\r\n  var cookie2 = HEAPU32[(((max)+(4))>>2)];\r\n  if (cookie1 != 0x02135467 || cookie2 != 0x89BACDFE) {\r\n    abort(`Stack overflow! Stack cookie has been overwritten at ${ptrToString(max)}, expected hex dwords 0x89BACDFE and 0x2135467, but received ${ptrToString(cookie2)} ${ptrToString(cookie1)}`);\r\n  }\r\n  // Also test the global address 0 for integrity.\r\n  if (HEAPU32[((0)>>2)] != 0x63736d65 /* 'emsc' */) {\r\n    abort('Runtime error: The application has corrupted its heap memory area (address zero)!');\r\n  }\r\n}\r\n// end include: runtime_stack_check.js\r\nvar __ATPRERUN__  = []; // functions called before the runtime is initialized\r\nvar __ATINIT__    = []; // functions called during startup\r\nvar __ATEXIT__    = []; // functions called during shutdown\r\nvar __ATPOSTRUN__ = []; // functions called after the main() is called\r\n\r\nvar runtimeInitialized = false;\r\n\r\nfunction preRun() {\r\n  var preRuns = Module['preRun'];\r\n  if (preRuns) {\r\n    if (typeof preRuns == 'function') preRuns = [preRuns];\r\n    preRuns.forEach(addOnPreRun);\r\n  }\r\n  callRuntimeCallbacks(__ATPRERUN__);\r\n}\r\n\r\nfunction initRuntime() {\r\n  assert(!runtimeInitialized);\r\n  runtimeInitialized = true;\r\n\r\n  checkStackCookie();\r\n\r\n  \r\n  callRuntimeCallbacks(__ATINIT__);\r\n}\r\n\r\nfunction postRun() {\r\n  checkStackCookie();\r\n\r\n  var postRuns = Module['postRun'];\r\n  if (postRuns) {\r\n    if (typeof postRuns == 'function') postRuns = [postRuns];\r\n    postRuns.forEach(addOnPostRun);\r\n  }\r\n\r\n  callRuntimeCallbacks(__ATPOSTRUN__);\r\n}\r\n\r\nfunction addOnPreRun(cb) {\r\n  __ATPRERUN__.unshift(cb);\r\n}\r\n\r\nfunction addOnInit(cb) {\r\n  __ATINIT__.unshift(cb);\r\n}\r\n\r\nfunction addOnExit(cb) {\r\n}\r\n\r\nfunction addOnPostRun(cb) {\r\n  __ATPOSTRUN__.unshift(cb);\r\n}\r\n\r\n// include: runtime_math.js\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/fround\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/clz32\r\n\r\n// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc\r\n\r\nassert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\nassert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');\r\n// end include: runtime_math.js\r\n// A counter of dependencies for calling run(). If we need to\r\n// do asynchronous work before running, increment this and\r\n// decrement it. Incrementing must happen in a place like\r\n// Module.preRun (used by emcc to add file preloading).\r\n// Note that you can add dependencies in preRun, even though\r\n// it happens right before run - run will be postponed until\r\n// the dependencies are met.\r\nvar runDependencies = 0;\r\nvar runDependencyWatcher = null;\r\nvar dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled\r\nvar runDependencyTracking = {};\r\n\r\nfunction getUniqueRunDependency(id) {\r\n  var orig = id;\r\n  while (1) {\r\n    if (!runDependencyTracking[id]) return id;\r\n    id = orig + Math.random();\r\n  }\r\n}\r\n\r\nfunction addRunDependency(id) {\r\n  runDependencies++;\r\n\r\n  Module['monitorRunDependencies']?.(runDependencies);\r\n\r\n  if (id) {\r\n    assert(!runDependencyTracking[id]);\r\n    runDependencyTracking[id] = 1;\r\n    if (runDependencyWatcher === null && typeof setInterval != 'undefined') {\r\n      // Check for missing dependencies every few seconds\r\n      runDependencyWatcher = setInterval(() => {\r\n        if (ABORT) {\r\n          clearInterval(runDependencyWatcher);\r\n          runDependencyWatcher = null;\r\n          return;\r\n        }\r\n        var shown = false;\r\n        for (var dep in runDependencyTracking) {\r\n          if (!shown) {\r\n            shown = true;\r\n            err('still waiting on run dependencies:');\r\n          }\r\n          err(`dependency: ${dep}`);\r\n        }\r\n        if (shown) {\r\n          err('(end of list)');\r\n        }\r\n      }, 10000);\r\n    }\r\n  } else {\r\n    err('warning: run dependency added without ID');\r\n  }\r\n}\r\n\r\nfunction removeRunDependency(id) {\r\n  runDependencies--;\r\n\r\n  Module['monitorRunDependencies']?.(runDependencies);\r\n\r\n  if (id) {\r\n    assert(runDependencyTracking[id]);\r\n    delete runDependencyTracking[id];\r\n  } else {\r\n    err('warning: run dependency removed without ID');\r\n  }\r\n  if (runDependencies == 0) {\r\n    if (runDependencyWatcher !== null) {\r\n      clearInterval(runDependencyWatcher);\r\n      runDependencyWatcher = null;\r\n    }\r\n    if (dependenciesFulfilled) {\r\n      var callback = dependenciesFulfilled;\r\n      dependenciesFulfilled = null;\r\n      callback(); // can add another dependenciesFulfilled\r\n    }\r\n  }\r\n}\r\n\r\n/** @param {string|number=} what */\r\nfunction abort(what) {\r\n  Module['onAbort']?.(what);\r\n\r\n  what = 'Aborted(' + what + ')';\r\n  // TODO(sbc): Should we remove printing and leave it up to whoever\r\n  // catches the exception?\r\n  err(what);\r\n\r\n  ABORT = true;\r\n\r\n  // Use a wasm runtime error, because a JS error might be seen as a foreign\r\n  // exception, which means we'd run destructors on it. We need the error to\r\n  // simply make the program stop.\r\n  // FIXME This approach does not work in Wasm EH because it currently does not assume\r\n  // all RuntimeErrors are from traps; it decides whether a RuntimeError is from\r\n  // a trap or not based on a hidden field within the object. So at the moment\r\n  // we don't have a way of throwing a wasm trap from JS. TODO Make a JS API that\r\n  // allows this in the wasm spec.\r\n\r\n  // Suppress closure compiler warning here. Closure compiler's builtin extern\r\n  // definition for WebAssembly.RuntimeError claims it takes no arguments even\r\n  // though it can.\r\n  // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure gets fixed.\r\n  /** @suppress {checkTypes} */\r\n  var e = new WebAssembly.RuntimeError(what);\r\n\r\n  readyPromiseReject(e);\r\n  // Throw the error whether or not MODULARIZE is set because abort is used\r\n  // in code paths apart from instantiation where an exception is expected\r\n  // to be thrown when abort is called.\r\n  throw e;\r\n}\r\n\r\n// include: memoryprofiler.js\r\n// end include: memoryprofiler.js\r\n// show errors on likely calls to FS when it was not included\r\nvar FS = {\r\n  error() {\r\n    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with -sFORCE_FILESYSTEM');\r\n  },\r\n  init() { FS.error() },\r\n  createDataFile() { FS.error() },\r\n  createPreloadedFile() { FS.error() },\r\n  createLazyFile() { FS.error() },\r\n  open() { FS.error() },\r\n  mkdev() { FS.error() },\r\n  registerDevice() { FS.error() },\r\n  analyzePath() { FS.error() },\r\n\r\n  ErrnoError() { FS.error() },\r\n};\r\nModule['FS_createDataFile'] = FS.createDataFile;\r\nModule['FS_createPreloadedFile'] = FS.createPreloadedFile;\r\n\r\n// include: URIUtils.js\r\n// Prefix of data URIs emitted by SINGLE_FILE and related options.\r\nvar dataURIPrefix = 'data:application/octet-stream;base64,';\r\n\r\n/**\r\n * Indicates whether filename is a base64 data URI.\r\n * @noinline\r\n */\r\nvar isDataURI = (filename) => filename.startsWith(dataURIPrefix);\r\n\r\n/**\r\n * Indicates whether filename is delivered via file protocol (as opposed to http/https)\r\n * @noinline\r\n */\r\nvar isFileURI = (filename) => filename.startsWith('file://');\r\n// end include: URIUtils.js\r\nfunction createExportWrapper(name, nargs) {\r\n  return (...args) => {\r\n    assert(runtimeInitialized, `native function \\`${name}\\` called before runtime initialization`);\r\n    var f = wasmExports[name];\r\n    assert(f, `exported native function \\`${name}\\` not found`);\r\n    // Only assert for too many arguments. Too few can be valid since the missing arguments will be zero filled.\r\n    assert(args.length <= nargs, `native function \\`${name}\\` called with ${args.length} args but expects ${nargs}`);\r\n    return f(...args);\r\n  };\r\n}\r\n\r\n// include: runtime_exceptions.js\r\n// end include: runtime_exceptions.js\r\nfunction findWasmBinary() {\r\n  if (Module['locateFile']) {\r\n    var f = 'communication.wasm.wasm';\r\n    if (!isDataURI(f)) {\r\n      return locateFile(f);\r\n    }\r\n    return f;\r\n  }\r\n  // Use bundler-friendly `new URL(..., import.meta.url)` pattern; works in browsers too.\r\n  return new URL(/* asset import */ Object(function webpackMissingModule() { var e = new Error(\"Cannot find module 'communication.wasm.wasm'\"); e.code = 'MODULE_NOT_FOUND'; throw e; }()), __webpack_require__.b).href;\r\n}\r\n\r\nvar wasmBinaryFile;\r\n\r\nfunction getBinarySync(file) {\r\n  if (file == wasmBinaryFile && wasmBinary) {\r\n    return new Uint8Array(wasmBinary);\r\n  }\r\n  if (readBinary) {\r\n    return readBinary(file);\r\n  }\r\n  throw 'both async and sync fetching of the wasm failed';\r\n}\r\n\r\nfunction getBinaryPromise(binaryFile) {\r\n  // If we don't have the binary yet, load it asynchronously using readAsync.\r\n  if (!wasmBinary\r\n      ) {\r\n    // Fetch the binary using readAsync\r\n    return readAsync(binaryFile).then(\r\n      (response) => new Uint8Array(/** @type{!ArrayBuffer} */(response)),\r\n      // Fall back to getBinarySync if readAsync fails\r\n      () => getBinarySync(binaryFile)\r\n    );\r\n  }\r\n\r\n  // Otherwise, getBinarySync should be able to get it synchronously\r\n  return Promise.resolve().then(() => getBinarySync(binaryFile));\r\n}\r\n\r\nfunction instantiateArrayBuffer(binaryFile, imports, receiver) {\r\n  return getBinaryPromise(binaryFile).then((binary) => {\r\n    return WebAssembly.instantiate(binary, imports);\r\n  }).then(receiver, (reason) => {\r\n    err(`failed to asynchronously prepare wasm: ${reason}`);\r\n\r\n    // Warn on some common problems.\r\n    if (isFileURI(wasmBinaryFile)) {\r\n      err(`warning: Loading from a file URI (${wasmBinaryFile}) is not supported in most browsers. See https://emscripten.org/docs/getting_started/FAQ.html#how-do-i-run-a-local-webserver-for-testing-why-does-my-program-stall-in-downloading-or-preparing`);\r\n    }\r\n    abort(reason);\r\n  });\r\n}\r\n\r\nfunction instantiateAsync(binary, binaryFile, imports, callback) {\r\n  if (!binary &&\r\n      typeof WebAssembly.instantiateStreaming == 'function' &&\r\n      !isDataURI(binaryFile) &&\r\n      // Don't use streaming for file:// delivered objects in a webview, fetch them synchronously.\r\n      !isFileURI(binaryFile) &&\r\n      // Avoid instantiateStreaming() on Node.js environment for now, as while\r\n      // Node.js v18.1.0 implements it, it does not have a full fetch()\r\n      // implementation yet.\r\n      //\r\n      // Reference:\r\n      //   https://github.com/emscripten-core/emscripten/pull/16917\r\n      !ENVIRONMENT_IS_NODE &&\r\n      typeof fetch == 'function') {\r\n    return fetch(binaryFile, { credentials: 'same-origin' }).then((response) => {\r\n      // Suppress closure warning here since the upstream definition for\r\n      // instantiateStreaming only allows Promise<Repsponse> rather than\r\n      // an actual Response.\r\n      // TODO(https://github.com/google/closure-compiler/pull/3913): Remove if/when upstream closure is fixed.\r\n      /** @suppress {checkTypes} */\r\n      var result = WebAssembly.instantiateStreaming(response, imports);\r\n\r\n      return result.then(\r\n        callback,\r\n        function(reason) {\r\n          // We expect the most common failure cause to be a bad MIME type for the binary,\r\n          // in which case falling back to ArrayBuffer instantiation should work.\r\n          err(`wasm streaming compile failed: ${reason}`);\r\n          err('falling back to ArrayBuffer instantiation');\r\n          return instantiateArrayBuffer(binaryFile, imports, callback);\r\n        });\r\n    });\r\n  }\r\n  return instantiateArrayBuffer(binaryFile, imports, callback);\r\n}\r\n\r\nfunction getWasmImports() {\r\n  // prepare imports\r\n  return {\r\n    'env': wasmImports,\r\n    'wasi_snapshot_preview1': wasmImports,\r\n  }\r\n}\r\n\r\n// Create the wasm instance.\r\n// Receives the wasm imports, returns the exports.\r\nfunction createWasm() {\r\n  var info = getWasmImports();\r\n  // Load the wasm module and create an instance of using native support in the JS engine.\r\n  // handle a generated wasm instance, receiving its exports and\r\n  // performing other necessary setup\r\n  /** @param {WebAssembly.Module=} module*/\r\n  function receiveInstance(instance, module) {\r\n    wasmExports = instance.exports;\r\n\r\n    \r\n\r\n    wasmMemory = wasmExports['memory'];\r\n    \r\n    assert(wasmMemory, 'memory not found in wasm exports');\r\n    updateMemoryViews();\r\n\r\n    wasmTable = wasmExports['__indirect_function_table'];\r\n    \r\n    assert(wasmTable, 'table not found in wasm exports');\r\n\r\n    addOnInit(wasmExports['__wasm_call_ctors']);\r\n\r\n    removeRunDependency('wasm-instantiate');\r\n    return wasmExports;\r\n  }\r\n  // wait for the pthread pool (if any)\r\n  addRunDependency('wasm-instantiate');\r\n\r\n  // Prefer streaming instantiation if available.\r\n  // Async compilation can be confusing when an error on the page overwrites Module\r\n  // (for example, if the order of elements is wrong, and the one defining Module is\r\n  // later), so we save Module and check it later.\r\n  var trueModule = Module;\r\n  function receiveInstantiationResult(result) {\r\n    // 'result' is a ResultObject object which has both the module and instance.\r\n    // receiveInstance() will swap in the exports (to Module.asm) so they can be called\r\n    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');\r\n    trueModule = null;\r\n    // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.\r\n    // When the regression is fixed, can restore the above PTHREADS-enabled path.\r\n    receiveInstance(result['instance']);\r\n  }\r\n\r\n  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback\r\n  // to manually instantiate the Wasm module themselves. This allows pages to\r\n  // run the instantiation parallel to any other async startup actions they are\r\n  // performing.\r\n  // Also pthreads and wasm workers initialize the wasm instance through this\r\n  // path.\r\n  if (Module['instantiateWasm']) {\r\n    try {\r\n      return Module['instantiateWasm'](info, receiveInstance);\r\n    } catch(e) {\r\n      err(`Module.instantiateWasm callback failed with error: ${e}`);\r\n        // If instantiation fails, reject the module ready promise.\r\n        readyPromiseReject(e);\r\n    }\r\n  }\r\n\r\n  wasmBinaryFile ??= findWasmBinary();\r\n\r\n  // If instantiation fails, reject the module ready promise.\r\n  instantiateAsync(wasmBinary, wasmBinaryFile, info, receiveInstantiationResult).catch(readyPromiseReject);\r\n  return {}; // no exports yet; we'll fill them in later\r\n}\r\n\r\n// Globals used by JS i64 conversions (see makeSetValue)\r\nvar tempDouble;\r\nvar tempI64;\r\n\r\n// include: runtime_debug.js\r\n// Endianness check\r\n(() => {\r\n  var h16 = new Int16Array(1);\r\n  var h8 = new Int8Array(h16.buffer);\r\n  h16[0] = 0x6373;\r\n  if (h8[0] !== 0x73 || h8[1] !== 0x63) throw 'Runtime error: expected the system to be little-endian! (Run with -sSUPPORT_BIG_ENDIAN to bypass)';\r\n})();\r\n\r\nif (Module['ENVIRONMENT']) {\r\n  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -sENVIRONMENT=web or -sENVIRONMENT=node)');\r\n}\r\n\r\nfunction legacyModuleProp(prop, newName, incoming=true) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    Object.defineProperty(Module, prop, {\r\n      configurable: true,\r\n      get() {\r\n        let extra = incoming ? ' (the initial value can be provided on Module, but after startup the value is only looked for on a local variable of that name)' : '';\r\n        abort(`\\`Module.${prop}\\` has been replaced by \\`${newName}\\`` + extra);\r\n\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction ignoredModuleProp(prop) {\r\n  if (Object.getOwnPropertyDescriptor(Module, prop)) {\r\n    abort(`\\`Module.${prop}\\` was supplied but \\`${prop}\\` not included in INCOMING_MODULE_JS_API`);\r\n  }\r\n}\r\n\r\n// forcing the filesystem exports a few things by default\r\nfunction isExportedByForceFilesystem(name) {\r\n  return name === 'FS_createPath' ||\r\n         name === 'FS_createDataFile' ||\r\n         name === 'FS_createPreloadedFile' ||\r\n         name === 'FS_unlink' ||\r\n         name === 'addRunDependency' ||\r\n         // The old FS has some functionality that WasmFS lacks.\r\n         name === 'FS_createLazyFile' ||\r\n         name === 'FS_createDevice' ||\r\n         name === 'removeRunDependency';\r\n}\r\n\r\n/**\r\n * Intercept access to a global symbol.  This enables us to give informative\r\n * warnings/errors when folks attempt to use symbols they did not include in\r\n * their build, or no symbols that no longer exist.\r\n */\r\nfunction hookGlobalSymbolAccess(sym, func) {\r\n  if (typeof globalThis != 'undefined' && !Object.getOwnPropertyDescriptor(globalThis, sym)) {\r\n    Object.defineProperty(globalThis, sym, {\r\n      configurable: true,\r\n      get() {\r\n        func();\r\n        return undefined;\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\nfunction missingGlobal(sym, msg) {\r\n  hookGlobalSymbolAccess(sym, () => {\r\n    warnOnce(`\\`${sym}\\` is not longer defined by emscripten. ${msg}`);\r\n  });\r\n}\r\n\r\nmissingGlobal('buffer', 'Please use HEAP8.buffer or wasmMemory.buffer');\r\nmissingGlobal('asm', 'Please use wasmExports instead');\r\n\r\nfunction missingLibrarySymbol(sym) {\r\n  hookGlobalSymbolAccess(sym, () => {\r\n    // Can't `abort()` here because it would break code that does runtime\r\n    // checks.  e.g. `if (typeof SDL === 'undefined')`.\r\n    var msg = `\\`${sym}\\` is a library symbol and not included by default; add it to your library.js __deps or to DEFAULT_LIBRARY_FUNCS_TO_INCLUDE on the command line`;\r\n    // DEFAULT_LIBRARY_FUNCS_TO_INCLUDE requires the name as it appears in\r\n    // library.js, which means $name for a JS name with no prefix, or name\r\n    // for a JS name like _name.\r\n    var librarySymbol = sym;\r\n    if (!librarySymbol.startsWith('_')) {\r\n      librarySymbol = '$' + sym;\r\n    }\r\n    msg += ` (e.g. -sDEFAULT_LIBRARY_FUNCS_TO_INCLUDE='${librarySymbol}')`;\r\n    if (isExportedByForceFilesystem(sym)) {\r\n      msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n    }\r\n    warnOnce(msg);\r\n  });\r\n\r\n  // Any symbol that is not included from the JS library is also (by definition)\r\n  // not exported on the Module object.\r\n  unexportedRuntimeSymbol(sym);\r\n}\r\n\r\nfunction unexportedRuntimeSymbol(sym) {\r\n  if (!Object.getOwnPropertyDescriptor(Module, sym)) {\r\n    Object.defineProperty(Module, sym, {\r\n      configurable: true,\r\n      get() {\r\n        var msg = `'${sym}' was not exported. add it to EXPORTED_RUNTIME_METHODS (see the Emscripten FAQ)`;\r\n        if (isExportedByForceFilesystem(sym)) {\r\n          msg += '. Alternatively, forcing filesystem support (-sFORCE_FILESYSTEM) can export this for you';\r\n        }\r\n        abort(msg);\r\n      }\r\n    });\r\n  }\r\n}\r\n\r\n// Used by XXXXX_DEBUG settings to output debug messages.\r\nfunction dbg(...args) {\r\n  // TODO(sbc): Make this configurable somehow.  Its not always convenient for\r\n  // logging to show up as warnings.\r\n  console.warn(...args);\r\n}\r\n// end include: runtime_debug.js\r\n// === Body ===\r\n\r\nvar ASM_CONSTS = {\r\n  70724: () => { console.log('这是 C++ 层的函数在 js 层被调用,且在 C++ 内嵌套 js 代码'); }\r\n};\r\n\r\n// end include: preamble.js\r\n\r\n\r\n  /** @constructor */\r\n  function ExitStatus(status) {\r\n      this.name = 'ExitStatus';\r\n      this.message = `Program terminated with exit(${status})`;\r\n      this.status = status;\r\n    }\r\n\r\n  var callRuntimeCallbacks = (callbacks) => {\r\n      // Pass the module as the first argument.\r\n      callbacks.forEach((f) => f(Module));\r\n    };\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {string} type\r\n     */\r\n  function getValue(ptr, type = 'i8') {\r\n    if (type.endsWith('*')) type = '*';\r\n    switch (type) {\r\n      case 'i1': return HEAP8[ptr];\r\n      case 'i8': return HEAP8[ptr];\r\n      case 'i16': return HEAP16[((ptr)>>1)];\r\n      case 'i32': return HEAP32[((ptr)>>2)];\r\n      case 'i64': abort('to do getValue(i64) use WASM_BIGINT');\r\n      case 'float': return HEAPF32[((ptr)>>2)];\r\n      case 'double': return HEAPF64[((ptr)>>3)];\r\n      case '*': return HEAPU32[((ptr)>>2)];\r\n      default: abort(`invalid type for getValue: ${type}`);\r\n    }\r\n  }\r\n\r\n  var noExitRuntime = Module['noExitRuntime'] || true;\r\n\r\n  var ptrToString = (ptr) => {\r\n      assert(typeof ptr === 'number');\r\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n      ptr >>>= 0;\r\n      return '0x' + ptr.toString(16).padStart(8, '0');\r\n    };\r\n\r\n  \r\n    /**\r\n     * @param {number} ptr\r\n     * @param {number} value\r\n     * @param {string} type\r\n     */\r\n  function setValue(ptr, value, type = 'i8') {\r\n    if (type.endsWith('*')) type = '*';\r\n    switch (type) {\r\n      case 'i1': HEAP8[ptr] = value; break;\r\n      case 'i8': HEAP8[ptr] = value; break;\r\n      case 'i16': HEAP16[((ptr)>>1)] = value; break;\r\n      case 'i32': HEAP32[((ptr)>>2)] = value; break;\r\n      case 'i64': abort('to do setValue(i64) use WASM_BIGINT');\r\n      case 'float': HEAPF32[((ptr)>>2)] = value; break;\r\n      case 'double': HEAPF64[((ptr)>>3)] = value; break;\r\n      case '*': HEAPU32[((ptr)>>2)] = value; break;\r\n      default: abort(`invalid type for setValue: ${type}`);\r\n    }\r\n  }\r\n\r\n  var stackRestore = (val) => __emscripten_stack_restore(val);\r\n\r\n  var stackSave = () => _emscripten_stack_get_current();\r\n\r\n  var warnOnce = (text) => {\r\n      warnOnce.shown ||= {};\r\n      if (!warnOnce.shown[text]) {\r\n        warnOnce.shown[text] = 1;\r\n        if (ENVIRONMENT_IS_NODE) text = 'warning: ' + text;\r\n        err(text);\r\n      }\r\n    };\r\n\r\n  var UTF8Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder() : undefined;\r\n  \r\n    /**\r\n     * Given a pointer 'idx' to a null-terminated UTF8-encoded string in the given\r\n     * array that contains uint8 values, returns a copy of that string as a\r\n     * Javascript String object.\r\n     * heapOrArray is either a regular array, or a JavaScript typed array view.\r\n     * @param {number=} idx\r\n     * @param {number=} maxBytesToRead\r\n     * @return {string}\r\n     */\r\n  var UTF8ArrayToString = (heapOrArray, idx = 0, maxBytesToRead = NaN) => {\r\n      var endIdx = idx + maxBytesToRead;\r\n      var endPtr = idx;\r\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n      // null terminator by itself.  Also, use the length info to avoid running tiny\r\n      // strings through TextDecoder, since .subarray() allocates garbage.\r\n      // (As a tiny code save trick, compare endPtr against endIdx using a negation,\r\n      // so that undefined/NaN means Infinity)\r\n      while (heapOrArray[endPtr] && !(endPtr >= endIdx)) ++endPtr;\r\n  \r\n      if (endPtr - idx > 16 && heapOrArray.buffer && UTF8Decoder) {\r\n        return UTF8Decoder.decode(heapOrArray.subarray(idx, endPtr));\r\n      }\r\n      var str = '';\r\n      // If building with TextDecoder, we have already computed the string length\r\n      // above, so test loop end condition against that\r\n      while (idx < endPtr) {\r\n        // For UTF8 byte structure, see:\r\n        // http://en.wikipedia.org/wiki/UTF-8#Description\r\n        // https://www.ietf.org/rfc/rfc2279.txt\r\n        // https://tools.ietf.org/html/rfc3629\r\n        var u0 = heapOrArray[idx++];\r\n        if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }\r\n        var u1 = heapOrArray[idx++] & 63;\r\n        if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }\r\n        var u2 = heapOrArray[idx++] & 63;\r\n        if ((u0 & 0xF0) == 0xE0) {\r\n          u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;\r\n        } else {\r\n          if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte ' + ptrToString(u0) + ' encountered when deserializing a UTF-8 string in wasm memory to a JS string!');\r\n          u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (heapOrArray[idx++] & 63);\r\n        }\r\n  \r\n        if (u0 < 0x10000) {\r\n          str += String.fromCharCode(u0);\r\n        } else {\r\n          var ch = u0 - 0x10000;\r\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n        }\r\n      }\r\n      return str;\r\n    };\r\n  \r\n    /**\r\n     * Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the\r\n     * emscripten HEAP, returns a copy of that string as a Javascript String object.\r\n     *\r\n     * @param {number} ptr\r\n     * @param {number=} maxBytesToRead - An optional length that specifies the\r\n     *   maximum number of bytes to read. You can omit this parameter to scan the\r\n     *   string until the first 0 byte. If maxBytesToRead is passed, and the string\r\n     *   at [ptr, ptr+maxBytesToReadr[ contains a null byte in the middle, then the\r\n     *   string will cut short at that byte index (i.e. maxBytesToRead will not\r\n     *   produce a string of exact length [ptr, ptr+maxBytesToRead[) N.B. mixing\r\n     *   frequent uses of UTF8ToString() with and without maxBytesToRead may throw\r\n     *   JS JIT optimizations off, so it is worth to consider consistently using one\r\n     * @return {string}\r\n     */\r\n  var UTF8ToString = (ptr, maxBytesToRead) => {\r\n      assert(typeof ptr == 'number', `UTF8ToString expects a number (got ${typeof ptr})`);\r\n      return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';\r\n    };\r\n  var ___assert_fail = (condition, filename, line, func) => {\r\n      abort(`Assertion failed: ${UTF8ToString(condition)}, at: ` + [filename ? UTF8ToString(filename) : 'unknown filename', line, func ? UTF8ToString(func) : 'unknown function']);\r\n    };\r\n\r\n  var __abort_js = () => {\r\n      abort('native code called abort()');\r\n    };\r\n\r\n  var __embind_register_bigint = (primitiveType, name, size, minRange, maxRange) => {};\r\n\r\n  var embind_init_charCodes = () => {\r\n      var codes = new Array(256);\r\n      for (var i = 0; i < 256; ++i) {\r\n          codes[i] = String.fromCharCode(i);\r\n      }\r\n      embind_charCodes = codes;\r\n    };\r\n  var embind_charCodes;\r\n  var readLatin1String = (ptr) => {\r\n      var ret = \"\";\r\n      var c = ptr;\r\n      while (HEAPU8[c]) {\r\n          ret += embind_charCodes[HEAPU8[c++]];\r\n      }\r\n      return ret;\r\n    };\r\n  \r\n  var awaitingDependencies = {\r\n  };\r\n  \r\n  var registeredTypes = {\r\n  };\r\n  \r\n  var typeDependencies = {\r\n  };\r\n  \r\n  var BindingError;\r\n  var throwBindingError = (message) => { throw new BindingError(message); };\r\n  \r\n  \r\n  \r\n  \r\n  var InternalError;\r\n  var throwInternalError = (message) => { throw new InternalError(message); };\r\n  var whenDependentTypesAreResolved = (myTypes, dependentTypes, getTypeConverters) => {\r\n      myTypes.forEach((type) => typeDependencies[type] = dependentTypes);\r\n  \r\n      function onComplete(typeConverters) {\r\n        var myTypeConverters = getTypeConverters(typeConverters);\r\n        if (myTypeConverters.length !== myTypes.length) {\r\n          throwInternalError('Mismatched type converter count');\r\n        }\r\n        for (var i = 0; i < myTypes.length; ++i) {\r\n          registerType(myTypes[i], myTypeConverters[i]);\r\n        }\r\n      }\r\n  \r\n      var typeConverters = new Array(dependentTypes.length);\r\n      var unregisteredTypes = [];\r\n      var registered = 0;\r\n      dependentTypes.forEach((dt, i) => {\r\n        if (registeredTypes.hasOwnProperty(dt)) {\r\n          typeConverters[i] = registeredTypes[dt];\r\n        } else {\r\n          unregisteredTypes.push(dt);\r\n          if (!awaitingDependencies.hasOwnProperty(dt)) {\r\n            awaitingDependencies[dt] = [];\r\n          }\r\n          awaitingDependencies[dt].push(() => {\r\n            typeConverters[i] = registeredTypes[dt];\r\n            ++registered;\r\n            if (registered === unregisteredTypes.length) {\r\n              onComplete(typeConverters);\r\n            }\r\n          });\r\n        }\r\n      });\r\n      if (0 === unregisteredTypes.length) {\r\n        onComplete(typeConverters);\r\n      }\r\n    };\r\n  /** @param {Object=} options */\r\n  function sharedRegisterType(rawType, registeredInstance, options = {}) {\r\n      var name = registeredInstance.name;\r\n      if (!rawType) {\r\n        throwBindingError(`type \"${name}\" must have a positive integer typeid pointer`);\r\n      }\r\n      if (registeredTypes.hasOwnProperty(rawType)) {\r\n        if (options.ignoreDuplicateRegistrations) {\r\n          return;\r\n        } else {\r\n          throwBindingError(`Cannot register type '${name}' twice`);\r\n        }\r\n      }\r\n  \r\n      registeredTypes[rawType] = registeredInstance;\r\n      delete typeDependencies[rawType];\r\n  \r\n      if (awaitingDependencies.hasOwnProperty(rawType)) {\r\n        var callbacks = awaitingDependencies[rawType];\r\n        delete awaitingDependencies[rawType];\r\n        callbacks.forEach((cb) => cb());\r\n      }\r\n    }\r\n  /** @param {Object=} options */\r\n  function registerType(rawType, registeredInstance, options = {}) {\r\n      if (!('argPackAdvance' in registeredInstance)) {\r\n        throw new TypeError('registerType registeredInstance requires argPackAdvance');\r\n      }\r\n      return sharedRegisterType(rawType, registeredInstance, options);\r\n    }\r\n  \r\n  var GenericWireTypeSize = 8;\r\n  /** @suppress {globalThis} */\r\n  var __embind_register_bool = (rawType, name, trueValue, falseValue) => {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n          name,\r\n          'fromWireType': function(wt) {\r\n              // ambiguous emscripten ABI: sometimes return values are\r\n              // true or false, and sometimes integers (0 or 1)\r\n              return !!wt;\r\n          },\r\n          'toWireType': function(destructors, o) {\r\n              return o ? trueValue : falseValue;\r\n          },\r\n          argPackAdvance: GenericWireTypeSize,\r\n          'readValueFromPointer': function(pointer) {\r\n              return this['fromWireType'](HEAPU8[pointer]);\r\n          },\r\n          destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    };\r\n\r\n  \r\n  \r\n  var shallowCopyInternalPointer = (o) => {\r\n      return {\r\n        count: o.count,\r\n        deleteScheduled: o.deleteScheduled,\r\n        preservePointerOnDelete: o.preservePointerOnDelete,\r\n        ptr: o.ptr,\r\n        ptrType: o.ptrType,\r\n        smartPtr: o.smartPtr,\r\n        smartPtrType: o.smartPtrType,\r\n      };\r\n    };\r\n  \r\n  var throwInstanceAlreadyDeleted = (obj) => {\r\n      function getInstanceTypeName(handle) {\r\n        return handle.$$.ptrType.registeredClass.name;\r\n      }\r\n      throwBindingError(getInstanceTypeName(obj) + ' instance already deleted');\r\n    };\r\n  \r\n  var finalizationRegistry = false;\r\n  \r\n  var detachFinalizer = (handle) => {};\r\n  \r\n  var runDestructor = ($$) => {\r\n      if ($$.smartPtr) {\r\n        $$.smartPtrType.rawDestructor($$.smartPtr);\r\n      } else {\r\n        $$.ptrType.registeredClass.rawDestructor($$.ptr);\r\n      }\r\n    };\r\n  var releaseClassHandle = ($$) => {\r\n      $$.count.value -= 1;\r\n      var toDelete = 0 === $$.count.value;\r\n      if (toDelete) {\r\n        runDestructor($$);\r\n      }\r\n    };\r\n  \r\n  var downcastPointer = (ptr, ptrClass, desiredClass) => {\r\n      if (ptrClass === desiredClass) {\r\n        return ptr;\r\n      }\r\n      if (undefined === desiredClass.baseClass) {\r\n        return null; // no conversion\r\n      }\r\n  \r\n      var rv = downcastPointer(ptr, ptrClass, desiredClass.baseClass);\r\n      if (rv === null) {\r\n        return null;\r\n      }\r\n      return desiredClass.downcast(rv);\r\n    };\r\n  \r\n  var registeredPointers = {\r\n  };\r\n  \r\n  var registeredInstances = {\r\n  };\r\n  \r\n  var getBasestPointer = (class_, ptr) => {\r\n      if (ptr === undefined) {\r\n          throwBindingError('ptr should not be undefined');\r\n      }\r\n      while (class_.baseClass) {\r\n          ptr = class_.upcast(ptr);\r\n          class_ = class_.baseClass;\r\n      }\r\n      return ptr;\r\n    };\r\n  var getInheritedInstance = (class_, ptr) => {\r\n      ptr = getBasestPointer(class_, ptr);\r\n      return registeredInstances[ptr];\r\n    };\r\n  \r\n  \r\n  var makeClassHandle = (prototype, record) => {\r\n      if (!record.ptrType || !record.ptr) {\r\n        throwInternalError('makeClassHandle requires ptr and ptrType');\r\n      }\r\n      var hasSmartPtrType = !!record.smartPtrType;\r\n      var hasSmartPtr = !!record.smartPtr;\r\n      if (hasSmartPtrType !== hasSmartPtr) {\r\n        throwInternalError('Both smartPtrType and smartPtr must be specified');\r\n      }\r\n      record.count = { value: 1 };\r\n      return attachFinalizer(Object.create(prototype, {\r\n        $$: {\r\n          value: record,\r\n          writable: true,\r\n        },\r\n      }));\r\n    };\r\n  /** @suppress {globalThis} */\r\n  function RegisteredPointer_fromWireType(ptr) {\r\n      // ptr is a raw pointer (or a raw smartpointer)\r\n  \r\n      // rawPointer is a maybe-null raw pointer\r\n      var rawPointer = this.getPointee(ptr);\r\n      if (!rawPointer) {\r\n        this.destructor(ptr);\r\n        return null;\r\n      }\r\n  \r\n      var registeredInstance = getInheritedInstance(this.registeredClass, rawPointer);\r\n      if (undefined !== registeredInstance) {\r\n        // JS object has been neutered, time to repopulate it\r\n        if (0 === registeredInstance.$$.count.value) {\r\n          registeredInstance.$$.ptr = rawPointer;\r\n          registeredInstance.$$.smartPtr = ptr;\r\n          return registeredInstance['clone']();\r\n        } else {\r\n          // else, just increment reference count on existing object\r\n          // it already has a reference to the smart pointer\r\n          var rv = registeredInstance['clone']();\r\n          this.destructor(ptr);\r\n          return rv;\r\n        }\r\n      }\r\n  \r\n      function makeDefaultHandle() {\r\n        if (this.isSmartPointer) {\r\n          return makeClassHandle(this.registeredClass.instancePrototype, {\r\n            ptrType: this.pointeeType,\r\n            ptr: rawPointer,\r\n            smartPtrType: this,\r\n            smartPtr: ptr,\r\n          });\r\n        } else {\r\n          return makeClassHandle(this.registeredClass.instancePrototype, {\r\n            ptrType: this,\r\n            ptr,\r\n          });\r\n        }\r\n      }\r\n  \r\n      var actualType = this.registeredClass.getActualType(rawPointer);\r\n      var registeredPointerRecord = registeredPointers[actualType];\r\n      if (!registeredPointerRecord) {\r\n        return makeDefaultHandle.call(this);\r\n      }\r\n  \r\n      var toType;\r\n      if (this.isConst) {\r\n        toType = registeredPointerRecord.constPointerType;\r\n      } else {\r\n        toType = registeredPointerRecord.pointerType;\r\n      }\r\n      var dp = downcastPointer(\r\n          rawPointer,\r\n          this.registeredClass,\r\n          toType.registeredClass);\r\n      if (dp === null) {\r\n        return makeDefaultHandle.call(this);\r\n      }\r\n      if (this.isSmartPointer) {\r\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n          ptrType: toType,\r\n          ptr: dp,\r\n          smartPtrType: this,\r\n          smartPtr: ptr,\r\n        });\r\n      } else {\r\n        return makeClassHandle(toType.registeredClass.instancePrototype, {\r\n          ptrType: toType,\r\n          ptr: dp,\r\n        });\r\n      }\r\n    }\r\n  var attachFinalizer = (handle) => {\r\n      if ('undefined' === typeof FinalizationRegistry) {\r\n        attachFinalizer = (handle) => handle;\r\n        return handle;\r\n      }\r\n      // If the running environment has a FinalizationRegistry (see\r\n      // https://github.com/tc39/proposal-weakrefs), then attach finalizers\r\n      // for class handles.  We check for the presence of FinalizationRegistry\r\n      // at run-time, not build-time.\r\n      finalizationRegistry = new FinalizationRegistry((info) => {\r\n        console.warn(info.leakWarning);\r\n        releaseClassHandle(info.$$);\r\n      });\r\n      attachFinalizer = (handle) => {\r\n        var $$ = handle.$$;\r\n        var hasSmartPtr = !!$$.smartPtr;\r\n        if (hasSmartPtr) {\r\n          // We should not call the destructor on raw pointers in case other code expects the pointee to live\r\n          var info = { $$: $$ };\r\n          // Create a warning as an Error instance in advance so that we can store\r\n          // the current stacktrace and point to it when / if a leak is detected.\r\n          // This is more useful than the empty stacktrace of `FinalizationRegistry`\r\n          // callback.\r\n          var cls = $$.ptrType.registeredClass;\r\n          var err = new Error(`Embind found a leaked C++ instance ${cls.name} <${ptrToString($$.ptr)}>.\\n` +\r\n          \"We'll free it automatically in this case, but this functionality is not reliable across various environments.\\n\" +\r\n          \"Make sure to invoke .delete() manually once you're done with the instance instead.\\n\" +\r\n          \"Originally allocated\"); // `.stack` will add \"at ...\" after this sentence\r\n          if ('captureStackTrace' in Error) {\r\n            Error.captureStackTrace(err, RegisteredPointer_fromWireType);\r\n          }\r\n          info.leakWarning = err.stack.replace(/^Error: /, '');\r\n          finalizationRegistry.register(handle, info, handle);\r\n        }\r\n        return handle;\r\n      };\r\n      detachFinalizer = (handle) => finalizationRegistry.unregister(handle);\r\n      return attachFinalizer(handle);\r\n    };\r\n  \r\n  \r\n  \r\n  \r\n  var deletionQueue = [];\r\n  var flushPendingDeletes = () => {\r\n      while (deletionQueue.length) {\r\n        var obj = deletionQueue.pop();\r\n        obj.$$.deleteScheduled = false;\r\n        obj['delete']();\r\n      }\r\n    };\r\n  \r\n  var delayFunction;\r\n  var init_ClassHandle = () => {\r\n      Object.assign(ClassHandle.prototype, {\r\n        \"isAliasOf\"(other) {\r\n          if (!(this instanceof ClassHandle)) {\r\n            return false;\r\n          }\r\n          if (!(other instanceof ClassHandle)) {\r\n            return false;\r\n          }\r\n  \r\n          var leftClass = this.$$.ptrType.registeredClass;\r\n          var left = this.$$.ptr;\r\n          other.$$ = /** @type {Object} */ (other.$$);\r\n          var rightClass = other.$$.ptrType.registeredClass;\r\n          var right = other.$$.ptr;\r\n  \r\n          while (leftClass.baseClass) {\r\n            left = leftClass.upcast(left);\r\n            leftClass = leftClass.baseClass;\r\n          }\r\n  \r\n          while (rightClass.baseClass) {\r\n            right = rightClass.upcast(right);\r\n            rightClass = rightClass.baseClass;\r\n          }\r\n  \r\n          return leftClass === rightClass && left === right;\r\n        },\r\n  \r\n        \"clone\"() {\r\n          if (!this.$$.ptr) {\r\n            throwInstanceAlreadyDeleted(this);\r\n          }\r\n  \r\n          if (this.$$.preservePointerOnDelete) {\r\n            this.$$.count.value += 1;\r\n            return this;\r\n          } else {\r\n            var clone = attachFinalizer(Object.create(Object.getPrototypeOf(this), {\r\n              $$: {\r\n                value: shallowCopyInternalPointer(this.$$),\r\n              }\r\n            }));\r\n  \r\n            clone.$$.count.value += 1;\r\n            clone.$$.deleteScheduled = false;\r\n            return clone;\r\n          }\r\n        },\r\n  \r\n        \"delete\"() {\r\n          if (!this.$$.ptr) {\r\n            throwInstanceAlreadyDeleted(this);\r\n          }\r\n  \r\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n            throwBindingError('Object already scheduled for deletion');\r\n          }\r\n  \r\n          detachFinalizer(this);\r\n          releaseClassHandle(this.$$);\r\n  \r\n          if (!this.$$.preservePointerOnDelete) {\r\n            this.$$.smartPtr = undefined;\r\n            this.$$.ptr = undefined;\r\n          }\r\n        },\r\n  \r\n        \"isDeleted\"() {\r\n          return !this.$$.ptr;\r\n        },\r\n  \r\n        \"deleteLater\"() {\r\n          if (!this.$$.ptr) {\r\n            throwInstanceAlreadyDeleted(this);\r\n          }\r\n          if (this.$$.deleteScheduled && !this.$$.preservePointerOnDelete) {\r\n            throwBindingError('Object already scheduled for deletion');\r\n          }\r\n          deletionQueue.push(this);\r\n          if (deletionQueue.length === 1 && delayFunction) {\r\n            delayFunction(flushPendingDeletes);\r\n          }\r\n          this.$$.deleteScheduled = true;\r\n          return this;\r\n        },\r\n      });\r\n    };\r\n  /** @constructor */\r\n  function ClassHandle() {\r\n    }\r\n  \r\n  var createNamedFunction = (name, body) => Object.defineProperty(body, 'name', {\r\n      value: name\r\n    });\r\n  \r\n  \r\n  var ensureOverloadTable = (proto, methodName, humanName) => {\r\n      if (undefined === proto[methodName].overloadTable) {\r\n        var prevFunc = proto[methodName];\r\n        // Inject an overload resolver function that routes to the appropriate overload based on the number of arguments.\r\n        proto[methodName] = function(...args) {\r\n          // TODO This check can be removed in -O3 level \"unsafe\" optimizations.\r\n          if (!proto[methodName].overloadTable.hasOwnProperty(args.length)) {\r\n            throwBindingError(`Function '${humanName}' called with an invalid number of arguments (${args.length}) - expects one of (${proto[methodName].overloadTable})!`);\r\n          }\r\n          return proto[methodName].overloadTable[args.length].apply(this, args);\r\n        };\r\n        // Move the previous function into the overload table.\r\n        proto[methodName].overloadTable = [];\r\n        proto[methodName].overloadTable[prevFunc.argCount] = prevFunc;\r\n      }\r\n    };\r\n  \r\n  /** @param {number=} numArguments */\r\n  var exposePublicSymbol = (name, value, numArguments) => {\r\n      if (Module.hasOwnProperty(name)) {\r\n        if (undefined === numArguments || (undefined !== Module[name].overloadTable && undefined !== Module[name].overloadTable[numArguments])) {\r\n          throwBindingError(`Cannot register public name '${name}' twice`);\r\n        }\r\n  \r\n        // We are exposing a function with the same name as an existing function. Create an overload table and a function selector\r\n        // that routes between the two.\r\n        ensureOverloadTable(Module, name, name);\r\n        if (Module.hasOwnProperty(numArguments)) {\r\n          throwBindingError(`Cannot register multiple overloads of a function with the same number of arguments (${numArguments})!`);\r\n        }\r\n        // Add the new function into the overload table.\r\n        Module[name].overloadTable[numArguments] = value;\r\n      }\r\n      else {\r\n        Module[name] = value;\r\n        if (undefined !== numArguments) {\r\n          Module[name].numArguments = numArguments;\r\n        }\r\n      }\r\n    };\r\n  \r\n  var char_0 = 48;\r\n  \r\n  var char_9 = 57;\r\n  var makeLegalFunctionName = (name) => {\r\n      assert(typeof name === 'string');\r\n      name = name.replace(/[^a-zA-Z0-9_]/g, '$');\r\n      var f = name.charCodeAt(0);\r\n      if (f >= char_0 && f <= char_9) {\r\n        return `_${name}`;\r\n      }\r\n      return name;\r\n    };\r\n  \r\n  \r\n  /** @constructor */\r\n  function RegisteredClass(name,\r\n                               constructor,\r\n                               instancePrototype,\r\n                               rawDestructor,\r\n                               baseClass,\r\n                               getActualType,\r\n                               upcast,\r\n                               downcast) {\r\n      this.name = name;\r\n      this.constructor = constructor;\r\n      this.instancePrototype = instancePrototype;\r\n      this.rawDestructor = rawDestructor;\r\n      this.baseClass = baseClass;\r\n      this.getActualType = getActualType;\r\n      this.upcast = upcast;\r\n      this.downcast = downcast;\r\n      this.pureVirtualFunctions = [];\r\n    }\r\n  \r\n  \r\n  var upcastPointer = (ptr, ptrClass, desiredClass) => {\r\n      while (ptrClass !== desiredClass) {\r\n        if (!ptrClass.upcast) {\r\n          throwBindingError(`Expected null or instance of ${desiredClass.name}, got an instance of ${ptrClass.name}`);\r\n        }\r\n        ptr = ptrClass.upcast(ptr);\r\n        ptrClass = ptrClass.baseClass;\r\n      }\r\n      return ptr;\r\n    };\r\n  /** @suppress {globalThis} */\r\n  function constNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError(`null is not a valid ${this.name}`);\r\n        }\r\n        return 0;\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n      return ptr;\r\n    }\r\n  \r\n  \r\n  /** @suppress {globalThis} */\r\n  function genericPointerToWireType(destructors, handle) {\r\n      var ptr;\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError(`null is not a valid ${this.name}`);\r\n        }\r\n  \r\n        if (this.isSmartPointer) {\r\n          ptr = this.rawConstructor();\r\n          if (destructors !== null) {\r\n            destructors.push(this.rawDestructor, ptr);\r\n          }\r\n          return ptr;\r\n        } else {\r\n          return 0;\r\n        }\r\n      }\r\n  \r\n      if (!handle || !handle.$$) {\r\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\r\n      }\r\n      if (!this.isConst && handle.$$.ptrType.isConst) {\r\n        throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n  \r\n      if (this.isSmartPointer) {\r\n        // TODO: this is not strictly true\r\n        // We could support BY_EMVAL conversions from raw pointers to smart pointers\r\n        // because the smart pointer can hold a reference to the handle\r\n        if (undefined === handle.$$.smartPtr) {\r\n          throwBindingError('Passing raw pointer to smart pointer is illegal');\r\n        }\r\n  \r\n        switch (this.sharingPolicy) {\r\n          case 0: // NONE\r\n            // no upcasting\r\n            if (handle.$$.smartPtrType === this) {\r\n              ptr = handle.$$.smartPtr;\r\n            } else {\r\n              throwBindingError(`Cannot convert argument of type ${(handle.$$.smartPtrType ? handle.$$.smartPtrType.name : handle.$$.ptrType.name)} to parameter type ${this.name}`);\r\n            }\r\n            break;\r\n  \r\n          case 1: // INTRUSIVE\r\n            ptr = handle.$$.smartPtr;\r\n            break;\r\n  \r\n          case 2: // BY_EMVAL\r\n            if (handle.$$.smartPtrType === this) {\r\n              ptr = handle.$$.smartPtr;\r\n            } else {\r\n              var clonedHandle = handle['clone']();\r\n              ptr = this.rawShare(\r\n                ptr,\r\n                Emval.toHandle(() => clonedHandle['delete']())\r\n              );\r\n              if (destructors !== null) {\r\n                destructors.push(this.rawDestructor, ptr);\r\n              }\r\n            }\r\n            break;\r\n  \r\n          default:\r\n            throwBindingError('Unsupporting sharing policy');\r\n        }\r\n      }\r\n      return ptr;\r\n    }\r\n  \r\n  \r\n  /** @suppress {globalThis} */\r\n  function nonConstNoSmartPtrRawPointerToWireType(destructors, handle) {\r\n      if (handle === null) {\r\n        if (this.isReference) {\r\n          throwBindingError(`null is not a valid ${this.name}`);\r\n        }\r\n        return 0;\r\n      }\r\n  \r\n      if (!handle.$$) {\r\n        throwBindingError(`Cannot pass \"${embindRepr(handle)}\" as a ${this.name}`);\r\n      }\r\n      if (!handle.$$.ptr) {\r\n        throwBindingError(`Cannot pass deleted object as a pointer of type ${this.name}`);\r\n      }\r\n      if (handle.$$.ptrType.isConst) {\r\n          throwBindingError(`Cannot convert argument of type ${handle.$$.ptrType.name} to parameter type ${this.name}`);\r\n      }\r\n      var handleClass = handle.$$.ptrType.registeredClass;\r\n      var ptr = upcastPointer(handle.$$.ptr, handleClass, this.registeredClass);\r\n      return ptr;\r\n    }\r\n  \r\n  \r\n  /** @suppress {globalThis} */\r\n  function readPointer(pointer) {\r\n      return this['fromWireType'](HEAPU32[((pointer)>>2)]);\r\n    }\r\n  \r\n  \r\n  var init_RegisteredPointer = () => {\r\n      Object.assign(RegisteredPointer.prototype, {\r\n        getPointee(ptr) {\r\n          if (this.rawGetPointee) {\r\n            ptr = this.rawGetPointee(ptr);\r\n          }\r\n          return ptr;\r\n        },\r\n        destructor(ptr) {\r\n          this.rawDestructor?.(ptr);\r\n        },\r\n        argPackAdvance: GenericWireTypeSize,\r\n        'readValueFromPointer': readPointer,\r\n        'fromWireType': RegisteredPointer_fromWireType,\r\n      });\r\n    };\r\n  /** @constructor\r\n      @param {*=} pointeeType,\r\n      @param {*=} sharingPolicy,\r\n      @param {*=} rawGetPointee,\r\n      @param {*=} rawConstructor,\r\n      @param {*=} rawShare,\r\n      @param {*=} rawDestructor,\r\n       */\r\n  function RegisteredPointer(\r\n      name,\r\n      registeredClass,\r\n      isReference,\r\n      isConst,\r\n  \r\n      // smart pointer properties\r\n      isSmartPointer,\r\n      pointeeType,\r\n      sharingPolicy,\r\n      rawGetPointee,\r\n      rawConstructor,\r\n      rawShare,\r\n      rawDestructor\r\n    ) {\r\n      this.name = name;\r\n      this.registeredClass = registeredClass;\r\n      this.isReference = isReference;\r\n      this.isConst = isConst;\r\n  \r\n      // smart pointer properties\r\n      this.isSmartPointer = isSmartPointer;\r\n      this.pointeeType = pointeeType;\r\n      this.sharingPolicy = sharingPolicy;\r\n      this.rawGetPointee = rawGetPointee;\r\n      this.rawConstructor = rawConstructor;\r\n      this.rawShare = rawShare;\r\n      this.rawDestructor = rawDestructor;\r\n  \r\n      if (!isSmartPointer && registeredClass.baseClass === undefined) {\r\n        if (isConst) {\r\n          this['toWireType'] = constNoSmartPtrRawPointerToWireType;\r\n          this.destructorFunction = null;\r\n        } else {\r\n          this['toWireType'] = nonConstNoSmartPtrRawPointerToWireType;\r\n          this.destructorFunction = null;\r\n        }\r\n      } else {\r\n        this['toWireType'] = genericPointerToWireType;\r\n        // Here we must leave this.destructorFunction undefined, since whether genericPointerToWireType returns\r\n        // a pointer that needs to be freed up is runtime-dependent, and cannot be evaluated at registration time.\r\n        // TODO: Create an alternative mechanism that allows removing the use of var destructors = []; array in\r\n        //       craftInvokerFunction altogether.\r\n      }\r\n    }\r\n  \r\n  /** @param {number=} numArguments */\r\n  var replacePublicSymbol = (name, value, numArguments) => {\r\n      if (!Module.hasOwnProperty(name)) {\r\n        throwInternalError('Replacing nonexistent public symbol');\r\n      }\r\n      // If there's an overload table for this symbol, replace the symbol in the overload table instead.\r\n      if (undefined !== Module[name].overloadTable && undefined !== numArguments) {\r\n        Module[name].overloadTable[numArguments] = value;\r\n      }\r\n      else {\r\n        Module[name] = value;\r\n        Module[name].argCount = numArguments;\r\n      }\r\n    };\r\n  \r\n  \r\n  \r\n  var dynCallLegacy = (sig, ptr, args) => {\r\n      sig = sig.replace(/p/g, 'i')\r\n      assert(('dynCall_' + sig) in Module, `bad function pointer type - dynCall function not found for sig '${sig}'`);\r\n      if (args?.length) {\r\n        // j (64-bit integer) must be passed in as two numbers [low 32, high 32].\r\n        assert(args.length === sig.substring(1).replace(/j/g, '--').length);\r\n      } else {\r\n        assert(sig.length == 1);\r\n      }\r\n      var f = Module['dynCall_' + sig];\r\n      return f(ptr, ...args);\r\n    };\r\n  \r\n  var wasmTableMirror = [];\r\n  \r\n  /** @type {WebAssembly.Table} */\r\n  var wasmTable;\r\n  var getWasmTableEntry = (funcPtr) => {\r\n      var func = wasmTableMirror[funcPtr];\r\n      if (!func) {\r\n        if (funcPtr >= wasmTableMirror.length) wasmTableMirror.length = funcPtr + 1;\r\n        wasmTableMirror[funcPtr] = func = wasmTable.get(funcPtr);\r\n      }\r\n      assert(wasmTable.get(funcPtr) == func, 'JavaScript-side Wasm function table mirror is out of date!');\r\n      return func;\r\n    };\r\n  \r\n  var dynCall = (sig, ptr, args = []) => {\r\n      // Without WASM_BIGINT support we cannot directly call function with i64 as\r\n      // part of their signature, so we rely on the dynCall functions generated by\r\n      // wasm-emscripten-finalize\r\n      if (sig.includes('j')) {\r\n        return dynCallLegacy(sig, ptr, args);\r\n      }\r\n      assert(getWasmTableEntry(ptr), `missing table entry in dynCall: ${ptr}`);\r\n      var rtn = getWasmTableEntry(ptr)(...args);\r\n      return rtn;\r\n    };\r\n  var getDynCaller = (sig, ptr) => {\r\n      assert(sig.includes('j') || sig.includes('p'), 'getDynCaller should only be called with i64 sigs')\r\n      return (...args) => dynCall(sig, ptr, args);\r\n    };\r\n  \r\n  \r\n  var embind__requireFunction = (signature, rawFunction) => {\r\n      signature = readLatin1String(signature);\r\n  \r\n      function makeDynCaller() {\r\n        if (signature.includes('j')) {\r\n          return getDynCaller(signature, rawFunction);\r\n        }\r\n        return getWasmTableEntry(rawFunction);\r\n      }\r\n  \r\n      var fp = makeDynCaller();\r\n      if (typeof fp != \"function\") {\r\n          throwBindingError(`unknown function pointer with signature ${signature}: ${rawFunction}`);\r\n      }\r\n      return fp;\r\n    };\r\n  \r\n  \r\n  \r\n  var extendError = (baseErrorType, errorName) => {\r\n      var errorClass = createNamedFunction(errorName, function(message) {\r\n        this.name = errorName;\r\n        this.message = message;\r\n  \r\n        var stack = (new Error(message)).stack;\r\n        if (stack !== undefined) {\r\n          this.stack = this.toString() + '\\n' +\r\n              stack.replace(/^Error(:[^\\n]*)?\\n/, '');\r\n        }\r\n      });\r\n      errorClass.prototype = Object.create(baseErrorType.prototype);\r\n      errorClass.prototype.constructor = errorClass;\r\n      errorClass.prototype.toString = function() {\r\n        if (this.message === undefined) {\r\n          return this.name;\r\n        } else {\r\n          return `${this.name}: ${this.message}`;\r\n        }\r\n      };\r\n  \r\n      return errorClass;\r\n    };\r\n  var UnboundTypeError;\r\n  \r\n  \r\n  \r\n  var getTypeName = (type) => {\r\n      var ptr = ___getTypeName(type);\r\n      var rv = readLatin1String(ptr);\r\n      _free(ptr);\r\n      return rv;\r\n    };\r\n  var throwUnboundTypeError = (message, types) => {\r\n      var unboundTypes = [];\r\n      var seen = {};\r\n      function visit(type) {\r\n        if (seen[type]) {\r\n          return;\r\n        }\r\n        if (registeredTypes[type]) {\r\n          return;\r\n        }\r\n        if (typeDependencies[type]) {\r\n          typeDependencies[type].forEach(visit);\r\n          return;\r\n        }\r\n        unboundTypes.push(type);\r\n        seen[type] = true;\r\n      }\r\n      types.forEach(visit);\r\n  \r\n      throw new UnboundTypeError(`${message}: ` + unboundTypes.map(getTypeName).join([', ']));\r\n    };\r\n  \r\n  var __embind_register_class = (rawType,\r\n                             rawPointerType,\r\n                             rawConstPointerType,\r\n                             baseClassRawType,\r\n                             getActualTypeSignature,\r\n                             getActualType,\r\n                             upcastSignature,\r\n                             upcast,\r\n                             downcastSignature,\r\n                             downcast,\r\n                             name,\r\n                             destructorSignature,\r\n                             rawDestructor) => {\r\n      name = readLatin1String(name);\r\n      getActualType = embind__requireFunction(getActualTypeSignature, getActualType);\r\n      upcast &&= embind__requireFunction(upcastSignature, upcast);\r\n      downcast &&= embind__requireFunction(downcastSignature, downcast);\r\n      rawDestructor = embind__requireFunction(destructorSignature, rawDestructor);\r\n      var legalFunctionName = makeLegalFunctionName(name);\r\n  \r\n      exposePublicSymbol(legalFunctionName, function() {\r\n        // this code cannot run if baseClassRawType is zero\r\n        throwUnboundTypeError(`Cannot construct ${name} due to unbound types`, [baseClassRawType]);\r\n      });\r\n  \r\n      whenDependentTypesAreResolved(\r\n        [rawType, rawPointerType, rawConstPointerType],\r\n        baseClassRawType ? [baseClassRawType] : [],\r\n        (base) => {\r\n          base = base[0];\r\n  \r\n          var baseClass;\r\n          var basePrototype;\r\n          if (baseClassRawType) {\r\n            baseClass = base.registeredClass;\r\n            basePrototype = baseClass.instancePrototype;\r\n          } else {\r\n            basePrototype = ClassHandle.prototype;\r\n          }\r\n  \r\n          var constructor = createNamedFunction(name, function(...args) {\r\n            if (Object.getPrototypeOf(this) !== instancePrototype) {\r\n              throw new BindingError(\"Use 'new' to construct \" + name);\r\n            }\r\n            if (undefined === registeredClass.constructor_body) {\r\n              throw new BindingError(name + \" has no accessible constructor\");\r\n            }\r\n            var body = registeredClass.constructor_body[args.length];\r\n            if (undefined === body) {\r\n              throw new BindingError(`Tried to invoke ctor of ${name} with invalid number of parameters (${args.length}) - expected (${Object.keys(registeredClass.constructor_body).toString()}) parameters instead!`);\r\n            }\r\n            return body.apply(this, args);\r\n          });\r\n  \r\n          var instancePrototype = Object.create(basePrototype, {\r\n            constructor: { value: constructor },\r\n          });\r\n  \r\n          constructor.prototype = instancePrototype;\r\n  \r\n          var registeredClass = new RegisteredClass(name,\r\n                                                    constructor,\r\n                                                    instancePrototype,\r\n                                                    rawDestructor,\r\n                                                    baseClass,\r\n                                                    getActualType,\r\n                                                    upcast,\r\n                                                    downcast);\r\n  \r\n          if (registeredClass.baseClass) {\r\n            // Keep track of class hierarchy. Used to allow sub-classes to inherit class functions.\r\n            registeredClass.baseClass.__derivedClasses ??= [];\r\n  \r\n            registeredClass.baseClass.__derivedClasses.push(registeredClass);\r\n          }\r\n  \r\n          var referenceConverter = new RegisteredPointer(name,\r\n                                                         registeredClass,\r\n                                                         true,\r\n                                                         false,\r\n                                                         false);\r\n  \r\n          var pointerConverter = new RegisteredPointer(name + '*',\r\n                                                       registeredClass,\r\n                                                       false,\r\n                                                       false,\r\n                                                       false);\r\n  \r\n          var constPointerConverter = new RegisteredPointer(name + ' const*',\r\n                                                            registeredClass,\r\n                                                            false,\r\n                                                            true,\r\n                                                            false);\r\n  \r\n          registeredPointers[rawType] = {\r\n            pointerType: pointerConverter,\r\n            constPointerType: constPointerConverter\r\n          };\r\n  \r\n          replacePublicSymbol(legalFunctionName, constructor);\r\n  \r\n          return [referenceConverter, pointerConverter, constPointerConverter];\r\n        }\r\n      );\r\n    };\r\n\r\n  var heap32VectorToArray = (count, firstElement) => {\r\n      var array = [];\r\n      for (var i = 0; i < count; i++) {\r\n        // TODO(https://github.com/emscripten-core/emscripten/issues/17310):\r\n        // Find a way to hoist the `>> 2` or `>> 3` out of this loop.\r\n        array.push(HEAPU32[(((firstElement)+(i * 4))>>2)]);\r\n      }\r\n      return array;\r\n    };\r\n  \r\n  \r\n  var runDestructors = (destructors) => {\r\n      while (destructors.length) {\r\n        var ptr = destructors.pop();\r\n        var del = destructors.pop();\r\n        del(ptr);\r\n      }\r\n    };\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  function usesDestructorStack(argTypes) {\r\n      // Skip return value at index 0 - it's not deleted here.\r\n      for (var i = 1; i < argTypes.length; ++i) {\r\n        // The type does not define a destructor function - must use dynamic stack\r\n        if (argTypes[i] !== null && argTypes[i].destructorFunction === undefined) {\r\n          return true;\r\n        }\r\n      }\r\n      return false;\r\n    }\r\n  \r\n  function newFunc(constructor, argumentList) {\r\n      if (!(constructor instanceof Function)) {\r\n        throw new TypeError(`new_ called with constructor type ${typeof(constructor)} which is not a function`);\r\n      }\r\n      /*\r\n       * Previously, the following line was just:\r\n       *   function dummy() {};\r\n       * Unfortunately, Chrome was preserving 'dummy' as the object's name, even\r\n       * though at creation, the 'dummy' has the correct constructor name.  Thus,\r\n       * objects created with IMVU.new would show up in the debugger as 'dummy',\r\n       * which isn't very helpful.  Using IMVU.createNamedFunction addresses the\r\n       * issue.  Doubly-unfortunately, there's no way to write a test for this\r\n       * behavior.  -NRD 2013.02.22\r\n       */\r\n      var dummy = createNamedFunction(constructor.name || 'unknownFunctionName', function(){});\r\n      dummy.prototype = constructor.prototype;\r\n      var obj = new dummy;\r\n  \r\n      var r = constructor.apply(obj, argumentList);\r\n      return (r instanceof Object) ? r : obj;\r\n    }\r\n  \r\n  \r\n  function checkArgCount(numArgs, minArgs, maxArgs, humanName, throwBindingError) {\r\n      if (numArgs < minArgs || numArgs > maxArgs) {\r\n        var argCountMessage = minArgs == maxArgs ? minArgs : `${minArgs} to ${maxArgs}`;\r\n        throwBindingError(`function ${humanName} called with ${numArgs} arguments, expected ${argCountMessage}`);\r\n      }\r\n    }\r\n  function createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync) {\r\n      var needsDestructorStack = usesDestructorStack(argTypes);\r\n      var argCount = argTypes.length - 2;\r\n      var argsList = [];\r\n      var argsListWired = ['fn'];\r\n      if (isClassMethodFunc) {\r\n        argsListWired.push('thisWired');\r\n      }\r\n      for (var i = 0; i < argCount; ++i) {\r\n        argsList.push(`arg${i}`)\r\n        argsListWired.push(`arg${i}Wired`)\r\n      }\r\n      argsList = argsList.join(',')\r\n      argsListWired = argsListWired.join(',')\r\n  \r\n      var invokerFnBody = `return function (${argsList}) {\\n`;\r\n  \r\n      invokerFnBody += \"checkArgCount(arguments.length, minArgs, maxArgs, humanName, throwBindingError);\\n\";\r\n  \r\n      if (needsDestructorStack) {\r\n        invokerFnBody += \"var destructors = [];\\n\";\r\n      }\r\n  \r\n      var dtorStack = needsDestructorStack ? \"destructors\" : \"null\";\r\n      var args1 = [\"humanName\", \"throwBindingError\", \"invoker\", \"fn\", \"runDestructors\", \"retType\", \"classParam\"];\r\n  \r\n      if (isClassMethodFunc) {\r\n        invokerFnBody += `var thisWired = classParam['toWireType'](${dtorStack}, this);\\n`;\r\n      }\r\n  \r\n      for (var i = 0; i < argCount; ++i) {\r\n        invokerFnBody += `var arg${i}Wired = argType${i}['toWireType'](${dtorStack}, arg${i});\\n`;\r\n        args1.push(`argType${i}`);\r\n      }\r\n  \r\n      invokerFnBody += (returns || isAsync ? \"var rv = \":\"\") + `invoker(${argsListWired});\\n`;\r\n  \r\n      var returnVal = returns ? \"rv\" : \"\";\r\n  \r\n      if (needsDestructorStack) {\r\n        invokerFnBody += \"runDestructors(destructors);\\n\";\r\n      } else {\r\n        for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n          var paramName = (i === 1 ? \"thisWired\" : (\"arg\"+(i - 2)+\"Wired\"));\r\n          if (argTypes[i].destructorFunction !== null) {\r\n            invokerFnBody += `${paramName}_dtor(${paramName});\\n`;\r\n            args1.push(`${paramName}_dtor`);\r\n          }\r\n        }\r\n      }\r\n  \r\n      if (returns) {\r\n        invokerFnBody += \"var ret = retType['fromWireType'](rv);\\n\" +\r\n                         \"return ret;\\n\";\r\n      } else {\r\n      }\r\n  \r\n      invokerFnBody += \"}\\n\";\r\n  \r\n      args1.push('checkArgCount', 'minArgs', 'maxArgs');\r\n      invokerFnBody = `if (arguments.length !== ${args1.length}){ throw new Error(humanName + \"Expected ${args1.length} closure arguments \" + arguments.length + \" given.\"); }\\n${invokerFnBody}`;\r\n      return [args1, invokerFnBody];\r\n    }\r\n  \r\n  function getRequiredArgCount(argTypes) {\r\n      var requiredArgCount = argTypes.length - 2;\r\n      for (var i = argTypes.length - 1; i >= 2; --i) {\r\n        if (!argTypes[i].optional) {\r\n          break;\r\n        }\r\n        requiredArgCount--;\r\n      }\r\n      return requiredArgCount;\r\n    }\r\n  \r\n  function craftInvokerFunction(humanName, argTypes, classType, cppInvokerFunc, cppTargetFunc, /** boolean= */ isAsync) {\r\n      // humanName: a human-readable string name for the function to be generated.\r\n      // argTypes: An array that contains the embind type objects for all types in the function signature.\r\n      //    argTypes[0] is the type object for the function return value.\r\n      //    argTypes[1] is the type object for function this object/class type, or null if not crafting an invoker for a class method.\r\n      //    argTypes[2...] are the actual function parameters.\r\n      // classType: The embind type object for the class to be bound, or null if this is not a method of a class.\r\n      // cppInvokerFunc: JS Function object to the C++-side function that interops into C++ code.\r\n      // cppTargetFunc: Function pointer (an integer to FUNCTION_TABLE) to the target C++ function the cppInvokerFunc will end up calling.\r\n      // isAsync: Optional. If true, returns an async function. Async bindings are only supported with JSPI.\r\n      var argCount = argTypes.length;\r\n  \r\n      if (argCount < 2) {\r\n        throwBindingError(\"argTypes array size mismatch! Must at least get return value and 'this' types!\");\r\n      }\r\n  \r\n      assert(!isAsync, 'Async bindings are only supported with JSPI.');\r\n  \r\n      var isClassMethodFunc = (argTypes[1] !== null && classType !== null);\r\n  \r\n      // Free functions with signature \"void function()\" do not need an invoker that marshalls between wire types.\r\n  // TODO: This omits argument count check - enable only at -O3 or similar.\r\n  //    if (ENABLE_UNSAFE_OPTS && argCount == 2 && argTypes[0].name == \"void\" && !isClassMethodFunc) {\r\n  //       return FUNCTION_TABLE[fn];\r\n  //    }\r\n  \r\n      // Determine if we need to use a dynamic stack to store the destructors for the function parameters.\r\n      // TODO: Remove this completely once all function invokers are being dynamically generated.\r\n      var needsDestructorStack = usesDestructorStack(argTypes);\r\n  \r\n      var returns = (argTypes[0].name !== \"void\");\r\n  \r\n      var expectedArgCount = argCount - 2;\r\n      var minArgs = getRequiredArgCount(argTypes);\r\n    // Builld the arguments that will be passed into the closure around the invoker\r\n    // function.\r\n    var closureArgs = [humanName, throwBindingError, cppInvokerFunc, cppTargetFunc, runDestructors, argTypes[0], argTypes[1]];\r\n    for (var i = 0; i < argCount - 2; ++i) {\r\n      closureArgs.push(argTypes[i+2]);\r\n    }\r\n    if (!needsDestructorStack) {\r\n      for (var i = isClassMethodFunc?1:2; i < argTypes.length; ++i) { // Skip return value at index 0 - it's not deleted here. Also skip class type if not a method.\r\n        if (argTypes[i].destructorFunction !== null) {\r\n          closureArgs.push(argTypes[i].destructorFunction);\r\n        }\r\n      }\r\n    }\r\n    closureArgs.push(checkArgCount, minArgs, expectedArgCount);\r\n  \r\n    let [args, invokerFnBody] = createJsInvoker(argTypes, isClassMethodFunc, returns, isAsync);\r\n    args.push(invokerFnBody);\r\n    var invokerFn = newFunc(Function, args)(...closureArgs);\r\n      return createNamedFunction(humanName, invokerFn);\r\n    }\r\n  var __embind_register_class_constructor = (\r\n      rawClassType,\r\n      argCount,\r\n      rawArgTypesAddr,\r\n      invokerSignature,\r\n      invoker,\r\n      rawConstructor\r\n    ) => {\r\n      assert(argCount > 0);\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      invoker = embind__requireFunction(invokerSignature, invoker);\r\n      var args = [rawConstructor];\r\n      var destructors = [];\r\n  \r\n      whenDependentTypesAreResolved([], [rawClassType], (classType) => {\r\n        classType = classType[0];\r\n        var humanName = `constructor ${classType.name}`;\r\n  \r\n        if (undefined === classType.registeredClass.constructor_body) {\r\n          classType.registeredClass.constructor_body = [];\r\n        }\r\n        if (undefined !== classType.registeredClass.constructor_body[argCount - 1]) {\r\n          throw new BindingError(`Cannot register multiple constructors with identical number of parameters (${argCount-1}) for class '${classType.name}'! Overload resolution is currently only performed using the parameter count, not actual type info!`);\r\n        }\r\n        classType.registeredClass.constructor_body[argCount - 1] = () => {\r\n          throwUnboundTypeError(`Cannot construct ${classType.name} due to unbound types`, rawArgTypes);\r\n        };\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\r\n          // Insert empty slot for context type (argTypes[1]).\r\n          argTypes.splice(1, 0, null);\r\n          classType.registeredClass.constructor_body[argCount - 1] = craftInvokerFunction(humanName, argTypes, null, invoker, rawConstructor);\r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    };\r\n\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  \r\n  var getFunctionName = (signature) => {\r\n      signature = signature.trim();\r\n      const argsIndex = signature.indexOf(\"(\");\r\n      if (argsIndex !== -1) {\r\n        assert(signature[signature.length - 1] == \")\", \"Parentheses for argument names should match.\");\r\n        return signature.substr(0, argsIndex);\r\n      } else {\r\n        return signature;\r\n      }\r\n    };\r\n  var __embind_register_class_function = (rawClassType,\r\n                                      methodName,\r\n                                      argCount,\r\n                                      rawArgTypesAddr, // [ReturnType, ThisType, Args...]\r\n                                      invokerSignature,\r\n                                      rawInvoker,\r\n                                      context,\r\n                                      isPureVirtual,\r\n                                      isAsync,\r\n                                      isNonnullReturn) => {\r\n      var rawArgTypes = heap32VectorToArray(argCount, rawArgTypesAddr);\r\n      methodName = readLatin1String(methodName);\r\n      methodName = getFunctionName(methodName);\r\n      rawInvoker = embind__requireFunction(invokerSignature, rawInvoker);\r\n  \r\n      whenDependentTypesAreResolved([], [rawClassType], (classType) => {\r\n        classType = classType[0];\r\n        var humanName = `${classType.name}.${methodName}`;\r\n  \r\n        if (methodName.startsWith(\"@@\")) {\r\n          methodName = Symbol[methodName.substring(2)];\r\n        }\r\n  \r\n        if (isPureVirtual) {\r\n          classType.registeredClass.pureVirtualFunctions.push(methodName);\r\n        }\r\n  \r\n        function unboundTypesHandler() {\r\n          throwUnboundTypeError(`Cannot call ${humanName} due to unbound types`, rawArgTypes);\r\n        }\r\n  \r\n        var proto = classType.registeredClass.instancePrototype;\r\n        var method = proto[methodName];\r\n        if (undefined === method || (undefined === method.overloadTable && method.className !== classType.name && method.argCount === argCount - 2)) {\r\n          // This is the first overload to be registered, OR we are replacing a\r\n          // function in the base class with a function in the derived class.\r\n          unboundTypesHandler.argCount = argCount - 2;\r\n          unboundTypesHandler.className = classType.name;\r\n          proto[methodName] = unboundTypesHandler;\r\n        } else {\r\n          // There was an existing function with the same name registered. Set up\r\n          // a function overload routing table.\r\n          ensureOverloadTable(proto, methodName, humanName);\r\n          proto[methodName].overloadTable[argCount - 2] = unboundTypesHandler;\r\n        }\r\n  \r\n        whenDependentTypesAreResolved([], rawArgTypes, (argTypes) => {\r\n          var memberFunction = craftInvokerFunction(humanName, argTypes, classType, rawInvoker, context, isAsync);\r\n  \r\n          // Replace the initial unbound-handler-stub function with the\r\n          // appropriate member function, now that all types are resolved. If\r\n          // multiple overloads are registered for this function, the function\r\n          // goes into an overload table.\r\n          if (undefined === proto[methodName].overloadTable) {\r\n            // Set argCount in case an overload is registered later\r\n            memberFunction.argCount = argCount - 2;\r\n            proto[methodName] = memberFunction;\r\n          } else {\r\n            proto[methodName].overloadTable[argCount - 2] = memberFunction;\r\n          }\r\n  \r\n          return [];\r\n        });\r\n        return [];\r\n      });\r\n    };\r\n\r\n  \r\n  var emval_freelist = [];\r\n  \r\n  var emval_handles = [];\r\n  var __emval_decref = (handle) => {\r\n      if (handle > 9 && 0 === --emval_handles[handle + 1]) {\r\n        assert(emval_handles[handle] !== undefined, `Decref for unallocated handle.`);\r\n        emval_handles[handle] = undefined;\r\n        emval_freelist.push(handle);\r\n      }\r\n    };\r\n  \r\n  \r\n  \r\n  \r\n  \r\n  var count_emval_handles = () => {\r\n      return emval_handles.length / 2 - 5 - emval_freelist.length;\r\n    };\r\n  \r\n  var init_emval = () => {\r\n      // reserve 0 and some special values. These never get de-allocated.\r\n      emval_handles.push(\r\n        0, 1,\r\n        undefined, 1,\r\n        null, 1,\r\n        true, 1,\r\n        false, 1,\r\n      );\r\n      assert(emval_handles.length === 5 * 2);\r\n      Module['count_emval_handles'] = count_emval_handles;\r\n    };\r\n  var Emval = {\r\n  toValue:(handle) => {\r\n        if (!handle) {\r\n            throwBindingError('Cannot use deleted val. handle = ' + handle);\r\n        }\r\n        // handle 2 is supposed to be `undefined`.\r\n        assert(handle === 2 || emval_handles[handle] !== undefined && handle % 2 === 0, `invalid handle: ${handle}`);\r\n        return emval_handles[handle];\r\n      },\r\n  toHandle:(value) => {\r\n        switch (value) {\r\n          case undefined: return 2;\r\n          case null: return 4;\r\n          case true: return 6;\r\n          case false: return 8;\r\n          default:{\r\n            const handle = emval_freelist.pop() || emval_handles.length;\r\n            emval_handles[handle] = value;\r\n            emval_handles[handle + 1] = 1;\r\n            return handle;\r\n          }\r\n        }\r\n      },\r\n  };\r\n  \r\n  \r\n  var EmValType = {\r\n      name: 'emscripten::val',\r\n      'fromWireType': (handle) => {\r\n        var rv = Emval.toValue(handle);\r\n        __emval_decref(handle);\r\n        return rv;\r\n      },\r\n      'toWireType': (destructors, value) => Emval.toHandle(value),\r\n      argPackAdvance: GenericWireTypeSize,\r\n      'readValueFromPointer': readPointer,\r\n      destructorFunction: null, // This type does not need a destructor\r\n  \r\n      // TODO: do we need a deleteObject here?  write a test where\r\n      // emval is passed into JS via an interface\r\n    };\r\n  var __embind_register_emval = (rawType) => registerType(rawType, EmValType);\r\n\r\n  var embindRepr = (v) => {\r\n      if (v === null) {\r\n          return 'null';\r\n      }\r\n      var t = typeof v;\r\n      if (t === 'object' || t === 'array' || t === 'function') {\r\n          return v.toString();\r\n      } else {\r\n          return '' + v;\r\n      }\r\n    };\r\n  \r\n  var floatReadValueFromPointer = (name, width) => {\r\n      switch (width) {\r\n          case 4: return function(pointer) {\r\n              return this['fromWireType'](HEAPF32[((pointer)>>2)]);\r\n          };\r\n          case 8: return function(pointer) {\r\n              return this['fromWireType'](HEAPF64[((pointer)>>3)]);\r\n          };\r\n          default:\r\n              throw new TypeError(`invalid float width (${width}): ${name}`);\r\n      }\r\n    };\r\n  \r\n  \r\n  var __embind_register_float = (rawType, name, size) => {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name,\r\n        'fromWireType': (value) => value,\r\n        'toWireType': (destructors, value) => {\r\n          if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n            throw new TypeError(`Cannot convert ${embindRepr(value)} to ${this.name}`);\r\n          }\r\n          // The VM will perform JS to Wasm value conversion, according to the spec:\r\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n          return value;\r\n        },\r\n        argPackAdvance: GenericWireTypeSize,\r\n        'readValueFromPointer': floatReadValueFromPointer(name, size),\r\n        destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    };\r\n\r\n  \r\n  var integerReadValueFromPointer = (name, width, signed) => {\r\n      // integers are quite common, so generate very specialized functions\r\n      switch (width) {\r\n          case 1: return signed ?\r\n              (pointer) => HEAP8[pointer] :\r\n              (pointer) => HEAPU8[pointer];\r\n          case 2: return signed ?\r\n              (pointer) => HEAP16[((pointer)>>1)] :\r\n              (pointer) => HEAPU16[((pointer)>>1)]\r\n          case 4: return signed ?\r\n              (pointer) => HEAP32[((pointer)>>2)] :\r\n              (pointer) => HEAPU32[((pointer)>>2)]\r\n          default:\r\n              throw new TypeError(`invalid integer width (${width}): ${name}`);\r\n      }\r\n    };\r\n  \r\n  \r\n  /** @suppress {globalThis} */\r\n  var __embind_register_integer = (primitiveType, name, size, minRange, maxRange) => {\r\n      name = readLatin1String(name);\r\n      // LLVM doesn't have signed and unsigned 32-bit types, so u32 literals come\r\n      // out as 'i32 -1'. Always treat those as max u32.\r\n      if (maxRange === -1) {\r\n        maxRange = 4294967295;\r\n      }\r\n  \r\n      var fromWireType = (value) => value;\r\n  \r\n      if (minRange === 0) {\r\n        var bitshift = 32 - 8*size;\r\n        fromWireType = (value) => (value << bitshift) >>> bitshift;\r\n      }\r\n  \r\n      var isUnsignedType = (name.includes('unsigned'));\r\n      var checkAssertions = (value, toTypeName) => {\r\n        if (typeof value != \"number\" && typeof value != \"boolean\") {\r\n          throw new TypeError(`Cannot convert \"${embindRepr(value)}\" to ${toTypeName}`);\r\n        }\r\n        if (value < minRange || value > maxRange) {\r\n          throw new TypeError(`Passing a number \"${embindRepr(value)}\" from JS side to C/C++ side to an argument of type \"${name}\", which is outside the valid range [${minRange}, ${maxRange}]!`);\r\n        }\r\n      }\r\n      var toWireType;\r\n      if (isUnsignedType) {\r\n        toWireType = function(destructors, value) {\r\n          checkAssertions(value, this.name);\r\n          return value >>> 0;\r\n        }\r\n      } else {\r\n        toWireType = function(destructors, value) {\r\n          checkAssertions(value, this.name);\r\n          // The VM will perform JS to Wasm value conversion, according to the spec:\r\n          // https://www.w3.org/TR/wasm-js-api-1/#towebassemblyvalue\r\n          return value;\r\n        }\r\n      }\r\n      registerType(primitiveType, {\r\n        name,\r\n        'fromWireType': fromWireType,\r\n        'toWireType': toWireType,\r\n        argPackAdvance: GenericWireTypeSize,\r\n        'readValueFromPointer': integerReadValueFromPointer(name, size, minRange !== 0),\r\n        destructorFunction: null, // This type does not need a destructor\r\n      });\r\n    };\r\n\r\n  \r\n  var __embind_register_memory_view = (rawType, dataTypeIndex, name) => {\r\n      var typeMapping = [\r\n        Int8Array,\r\n        Uint8Array,\r\n        Int16Array,\r\n        Uint16Array,\r\n        Int32Array,\r\n        Uint32Array,\r\n        Float32Array,\r\n        Float64Array,\r\n      ];\r\n  \r\n      var TA = typeMapping[dataTypeIndex];\r\n  \r\n      function decodeMemoryView(handle) {\r\n        var size = HEAPU32[((handle)>>2)];\r\n        var data = HEAPU32[(((handle)+(4))>>2)];\r\n        return new TA(HEAP8.buffer, data, size);\r\n      }\r\n  \r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        name,\r\n        'fromWireType': decodeMemoryView,\r\n        argPackAdvance: GenericWireTypeSize,\r\n        'readValueFromPointer': decodeMemoryView,\r\n      }, {\r\n        ignoreDuplicateRegistrations: true,\r\n      });\r\n    };\r\n\r\n  \r\n  \r\n  \r\n  \r\n  var stringToUTF8Array = (str, heap, outIdx, maxBytesToWrite) => {\r\n      assert(typeof str === 'string', `stringToUTF8Array expects a string (got ${typeof str})`);\r\n      // Parameter maxBytesToWrite is not optional. Negative values, 0, null,\r\n      // undefined and false each don't write out any bytes.\r\n      if (!(maxBytesToWrite > 0))\r\n        return 0;\r\n  \r\n      var startIdx = outIdx;\r\n      var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n        // unit, not a Unicode code point of the character! So decode\r\n        // UTF16->UTF32->UTF8.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description\r\n        // and https://www.ietf.org/rfc/rfc2279.txt\r\n        // and https://tools.ietf.org/html/rfc3629\r\n        var u = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (u >= 0xD800 && u <= 0xDFFF) {\r\n          var u1 = str.charCodeAt(++i);\r\n          u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);\r\n        }\r\n        if (u <= 0x7F) {\r\n          if (outIdx >= endIdx) break;\r\n          heap[outIdx++] = u;\r\n        } else if (u <= 0x7FF) {\r\n          if (outIdx + 1 >= endIdx) break;\r\n          heap[outIdx++] = 0xC0 | (u >> 6);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        } else if (u <= 0xFFFF) {\r\n          if (outIdx + 2 >= endIdx) break;\r\n          heap[outIdx++] = 0xE0 | (u >> 12);\r\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        } else {\r\n          if (outIdx + 3 >= endIdx) break;\r\n          if (u > 0x10FFFF) warnOnce('Invalid Unicode code point ' + ptrToString(u) + ' encountered when serializing a JS string to a UTF-8 string in wasm memory! (Valid unicode code points should be in range 0-0x10FFFF).');\r\n          heap[outIdx++] = 0xF0 | (u >> 18);\r\n          heap[outIdx++] = 0x80 | ((u >> 12) & 63);\r\n          heap[outIdx++] = 0x80 | ((u >> 6) & 63);\r\n          heap[outIdx++] = 0x80 | (u & 63);\r\n        }\r\n      }\r\n      // Null-terminate the pointer to the buffer.\r\n      heap[outIdx] = 0;\r\n      return outIdx - startIdx;\r\n    };\r\n  var stringToUTF8 = (str, outPtr, maxBytesToWrite) => {\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      return stringToUTF8Array(str, HEAPU8, outPtr, maxBytesToWrite);\r\n    };\r\n  \r\n  var lengthBytesUTF8 = (str) => {\r\n      var len = 0;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code\r\n        // unit, not a Unicode code point of the character! So decode\r\n        // UTF16->UTF32->UTF8.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var c = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (c <= 0x7F) {\r\n          len++;\r\n        } else if (c <= 0x7FF) {\r\n          len += 2;\r\n        } else if (c >= 0xD800 && c <= 0xDFFF) {\r\n          len += 4; ++i;\r\n        } else {\r\n          len += 3;\r\n        }\r\n      }\r\n      return len;\r\n    };\r\n  \r\n  \r\n  \r\n  var __embind_register_std_string = (rawType, name) => {\r\n      name = readLatin1String(name);\r\n      var stdStringIsUTF8\r\n      //process only std::string bindings with UTF8 support, in contrast to e.g. std::basic_string<unsigned char>\r\n      = (name === \"std::string\");\r\n  \r\n      registerType(rawType, {\r\n        name,\r\n        // For some method names we use string keys here since they are part of\r\n        // the public/external API and/or used by the runtime-generated code.\r\n        'fromWireType'(value) {\r\n          var length = HEAPU32[((value)>>2)];\r\n          var payload = value + 4;\r\n  \r\n          var str;\r\n          if (stdStringIsUTF8) {\r\n            var decodeStartPtr = payload;\r\n            // Looping here to support possible embedded '0' bytes\r\n            for (var i = 0; i <= length; ++i) {\r\n              var currentBytePtr = payload + i;\r\n              if (i == length || HEAPU8[currentBytePtr] == 0) {\r\n                var maxRead = currentBytePtr - decodeStartPtr;\r\n                var stringSegment = UTF8ToString(decodeStartPtr, maxRead);\r\n                if (str === undefined) {\r\n                  str = stringSegment;\r\n                } else {\r\n                  str += String.fromCharCode(0);\r\n                  str += stringSegment;\r\n                }\r\n                decodeStartPtr = currentBytePtr + 1;\r\n              }\r\n            }\r\n          } else {\r\n            var a = new Array(length);\r\n            for (var i = 0; i < length; ++i) {\r\n              a[i] = String.fromCharCode(HEAPU8[payload + i]);\r\n            }\r\n            str = a.join('');\r\n          }\r\n  \r\n          _free(value);\r\n  \r\n          return str;\r\n        },\r\n        'toWireType'(destructors, value) {\r\n          if (value instanceof ArrayBuffer) {\r\n            value = new Uint8Array(value);\r\n          }\r\n  \r\n          var length;\r\n          var valueIsOfTypeString = (typeof value == 'string');\r\n  \r\n          if (!(valueIsOfTypeString || value instanceof Uint8Array || value instanceof Uint8ClampedArray || value instanceof Int8Array)) {\r\n            throwBindingError('Cannot pass non-string to std::string');\r\n          }\r\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n            length = lengthBytesUTF8(value);\r\n          } else {\r\n            length = value.length;\r\n          }\r\n  \r\n          // assumes POINTER_SIZE alignment\r\n          var base = _malloc(4 + length + 1);\r\n          var ptr = base + 4;\r\n          HEAPU32[((base)>>2)] = length;\r\n          if (stdStringIsUTF8 && valueIsOfTypeString) {\r\n            stringToUTF8(value, ptr, length + 1);\r\n          } else {\r\n            if (valueIsOfTypeString) {\r\n              for (var i = 0; i < length; ++i) {\r\n                var charCode = value.charCodeAt(i);\r\n                if (charCode > 255) {\r\n                  _free(ptr);\r\n                  throwBindingError('String has UTF-16 code units that do not fit in 8 bits');\r\n                }\r\n                HEAPU8[ptr + i] = charCode;\r\n              }\r\n            } else {\r\n              for (var i = 0; i < length; ++i) {\r\n                HEAPU8[ptr + i] = value[i];\r\n              }\r\n            }\r\n          }\r\n  \r\n          if (destructors !== null) {\r\n            destructors.push(_free, base);\r\n          }\r\n          return base;\r\n        },\r\n        argPackAdvance: GenericWireTypeSize,\r\n        'readValueFromPointer': readPointer,\r\n        destructorFunction(ptr) {\r\n          _free(ptr);\r\n        },\r\n      });\r\n    };\r\n\r\n  \r\n  \r\n  \r\n  var UTF16Decoder = typeof TextDecoder != 'undefined' ? new TextDecoder('utf-16le') : undefined;;\r\n  var UTF16ToString = (ptr, maxBytesToRead) => {\r\n      assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');\r\n      var endPtr = ptr;\r\n      // TextDecoder needs to know the byte length in advance, it doesn't stop on\r\n      // null terminator by itself.\r\n      // Also, use the length info to avoid running tiny strings through\r\n      // TextDecoder, since .subarray() allocates garbage.\r\n      var idx = endPtr >> 1;\r\n      var maxIdx = idx + maxBytesToRead / 2;\r\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n      // will always evaluate to true. This saves on code size.\r\n      while (!(idx >= maxIdx) && HEAPU16[idx]) ++idx;\r\n      endPtr = idx << 1;\r\n  \r\n      if (endPtr - ptr > 32 && UTF16Decoder)\r\n        return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));\r\n  \r\n      // Fallback: decode without UTF16Decoder\r\n      var str = '';\r\n  \r\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and the\r\n      // for-loop's condition will always evaluate to true. The loop is then\r\n      // terminated on the first null char.\r\n      for (var i = 0; !(i >= maxBytesToRead / 2); ++i) {\r\n        var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];\r\n        if (codeUnit == 0) break;\r\n        // fromCharCode constructs a character from a UTF-16 code unit, so we can\r\n        // pass the UTF16 string right through.\r\n        str += String.fromCharCode(codeUnit);\r\n      }\r\n  \r\n      return str;\r\n    };\r\n  \r\n  var stringToUTF16 = (str, outPtr, maxBytesToWrite) => {\r\n      assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n      maxBytesToWrite ??= 0x7FFFFFFF;\r\n      if (maxBytesToWrite < 2) return 0;\r\n      maxBytesToWrite -= 2; // Null terminator.\r\n      var startPtr = outPtr;\r\n      var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;\r\n      for (var i = 0; i < numCharsToWrite; ++i) {\r\n        // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.\r\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n        HEAP16[((outPtr)>>1)] = codeUnit;\r\n        outPtr += 2;\r\n      }\r\n      // Null-terminate the pointer to the HEAP.\r\n      HEAP16[((outPtr)>>1)] = 0;\r\n      return outPtr - startPtr;\r\n    };\r\n  \r\n  var lengthBytesUTF16 = (str) => {\r\n      return str.length*2;\r\n    };\r\n  \r\n  var UTF32ToString = (ptr, maxBytesToRead) => {\r\n      assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');\r\n      var i = 0;\r\n  \r\n      var str = '';\r\n      // If maxBytesToRead is not passed explicitly, it will be undefined, and this\r\n      // will always evaluate to true. This saves on code size.\r\n      while (!(i >= maxBytesToRead / 4)) {\r\n        var utf32 = HEAP32[(((ptr)+(i*4))>>2)];\r\n        if (utf32 == 0) break;\r\n        ++i;\r\n        // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        if (utf32 >= 0x10000) {\r\n          var ch = utf32 - 0x10000;\r\n          str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));\r\n        } else {\r\n          str += String.fromCharCode(utf32);\r\n        }\r\n      }\r\n      return str;\r\n    };\r\n  \r\n  var stringToUTF32 = (str, outPtr, maxBytesToWrite) => {\r\n      assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');\r\n      assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');\r\n      // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.\r\n      maxBytesToWrite ??= 0x7FFFFFFF;\r\n      if (maxBytesToWrite < 4) return 0;\r\n      var startPtr = outPtr;\r\n      var endPtr = startPtr + maxBytesToWrite - 4;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var codeUnit = str.charCodeAt(i); // possibly a lead surrogate\r\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {\r\n          var trailSurrogate = str.charCodeAt(++i);\r\n          codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);\r\n        }\r\n        HEAP32[((outPtr)>>2)] = codeUnit;\r\n        outPtr += 4;\r\n        if (outPtr + 4 > endPtr) break;\r\n      }\r\n      // Null-terminate the pointer to the HEAP.\r\n      HEAP32[((outPtr)>>2)] = 0;\r\n      return outPtr - startPtr;\r\n    };\r\n  \r\n  var lengthBytesUTF32 = (str) => {\r\n      var len = 0;\r\n      for (var i = 0; i < str.length; ++i) {\r\n        // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.\r\n        // See http://unicode.org/faq/utf_bom.html#utf16-3\r\n        var codeUnit = str.charCodeAt(i);\r\n        if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.\r\n        len += 4;\r\n      }\r\n  \r\n      return len;\r\n    };\r\n  var __embind_register_std_wstring = (rawType, charSize, name) => {\r\n      name = readLatin1String(name);\r\n      var decodeString, encodeString, readCharAt, lengthBytesUTF;\r\n      if (charSize === 2) {\r\n        decodeString = UTF16ToString;\r\n        encodeString = stringToUTF16;\r\n        lengthBytesUTF = lengthBytesUTF16;\r\n        readCharAt = (pointer) => HEAPU16[((pointer)>>1)];\r\n      } else if (charSize === 4) {\r\n        decodeString = UTF32ToString;\r\n        encodeString = stringToUTF32;\r\n        lengthBytesUTF = lengthBytesUTF32;\r\n        readCharAt = (pointer) => HEAPU32[((pointer)>>2)];\r\n      }\r\n      registerType(rawType, {\r\n        name,\r\n        'fromWireType': (value) => {\r\n          // Code mostly taken from _embind_register_std_string fromWireType\r\n          var length = HEAPU32[((value)>>2)];\r\n          var str;\r\n  \r\n          var decodeStartPtr = value + 4;\r\n          // Looping here to support possible embedded '0' bytes\r\n          for (var i = 0; i <= length; ++i) {\r\n            var currentBytePtr = value + 4 + i * charSize;\r\n            if (i == length || readCharAt(currentBytePtr) == 0) {\r\n              var maxReadBytes = currentBytePtr - decodeStartPtr;\r\n              var stringSegment = decodeString(decodeStartPtr, maxReadBytes);\r\n              if (str === undefined) {\r\n                str = stringSegment;\r\n              } else {\r\n                str += String.fromCharCode(0);\r\n                str += stringSegment;\r\n              }\r\n              decodeStartPtr = currentBytePtr + charSize;\r\n            }\r\n          }\r\n  \r\n          _free(value);\r\n  \r\n          return str;\r\n        },\r\n        'toWireType': (destructors, value) => {\r\n          if (!(typeof value == 'string')) {\r\n            throwBindingError(`Cannot pass non-string to C++ string type ${name}`);\r\n          }\r\n  \r\n          // assumes POINTER_SIZE alignment\r\n          var length = lengthBytesUTF(value);\r\n          var ptr = _malloc(4 + length + charSize);\r\n          HEAPU32[((ptr)>>2)] = length / charSize;\r\n  \r\n          encodeString(value, ptr + 4, length + charSize);\r\n  \r\n          if (destructors !== null) {\r\n            destructors.push(_free, ptr);\r\n          }\r\n          return ptr;\r\n        },\r\n        argPackAdvance: GenericWireTypeSize,\r\n        'readValueFromPointer': readPointer,\r\n        destructorFunction(ptr) {\r\n          _free(ptr);\r\n        }\r\n      });\r\n    };\r\n\r\n  \r\n  var __embind_register_void = (rawType, name) => {\r\n      name = readLatin1String(name);\r\n      registerType(rawType, {\r\n        isVoid: true, // void return values can be optimized out sometimes\r\n        name,\r\n        argPackAdvance: 0,\r\n        'fromWireType': () => undefined,\r\n        // TODO: assert if anything else is given?\r\n        'toWireType': (destructors, o) => undefined,\r\n      });\r\n    };\r\n\r\n  var __emscripten_memcpy_js = (dest, src, num) => HEAPU8.copyWithin(dest, src, src + num);\r\n\r\n  var emval_methodCallers = [];\r\n  \r\n  var __emval_call = (caller, handle, destructorsRef, args) => {\r\n      caller = emval_methodCallers[caller];\r\n      handle = Emval.toValue(handle);\r\n      return caller(null, handle, destructorsRef, args);\r\n    };\r\n\r\n\r\n  var emval_addMethodCaller = (caller) => {\r\n      var id = emval_methodCallers.length;\r\n      emval_methodCallers.push(caller);\r\n      return id;\r\n    };\r\n  \r\n  \r\n  \r\n  var requireRegisteredType = (rawType, humanName) => {\r\n      var impl = registeredTypes[rawType];\r\n      if (undefined === impl) {\r\n        throwBindingError(`${humanName} has unknown type ${getTypeName(rawType)}`);\r\n      }\r\n      return impl;\r\n    };\r\n  var emval_lookupTypes = (argCount, argTypes) => {\r\n      var a = new Array(argCount);\r\n      for (var i = 0; i < argCount; ++i) {\r\n        a[i] = requireRegisteredType(HEAPU32[(((argTypes)+(i * 4))>>2)],\r\n                                     \"parameter \" + i);\r\n      }\r\n      return a;\r\n    };\r\n  \r\n  \r\n  var reflectConstruct = Reflect.construct;\r\n  \r\n  var emval_returnValue = (returnType, destructorsRef, handle) => {\r\n      var destructors = [];\r\n      var result = returnType['toWireType'](destructors, handle);\r\n      if (destructors.length) {\r\n        // void, primitives and any other types w/o destructors don't need to allocate a handle\r\n        HEAPU32[((destructorsRef)>>2)] = Emval.toHandle(destructors);\r\n      }\r\n      return result;\r\n    };\r\n  \r\n  var __emval_get_method_caller = (argCount, argTypes, kind) => {\r\n      var types = emval_lookupTypes(argCount, argTypes);\r\n      var retType = types.shift();\r\n      argCount--; // remove the shifted off return type\r\n  \r\n      var functionBody =\r\n        `return function (obj, func, destructorsRef, args) {\\n`;\r\n  \r\n      var offset = 0;\r\n      var argsList = []; // 'obj?, arg0, arg1, arg2, ... , argN'\r\n      if (kind === /* FUNCTION */ 0) {\r\n        argsList.push(\"obj\");\r\n      }\r\n      var params = [\"retType\"];\r\n      var args = [retType];\r\n      for (var i = 0; i < argCount; ++i) {\r\n        argsList.push(\"arg\" + i);\r\n        params.push(\"argType\" + i);\r\n        args.push(types[i]);\r\n        functionBody +=\r\n          `  var arg${i} = argType${i}.readValueFromPointer(args${offset ? \"+\" + offset : \"\"});\\n`;\r\n        offset += types[i].argPackAdvance;\r\n      }\r\n      var invoker = kind === /* CONSTRUCTOR */ 1 ? 'new func' : 'func.call';\r\n      functionBody +=\r\n        `  var rv = ${invoker}(${argsList.join(\", \")});\\n`;\r\n      if (!retType.isVoid) {\r\n        params.push(\"emval_returnValue\");\r\n        args.push(emval_returnValue);\r\n        functionBody +=\r\n          \"  return emval_returnValue(retType, destructorsRef, rv);\\n\";\r\n      }\r\n      functionBody +=\r\n        \"};\\n\";\r\n  \r\n      params.push(functionBody);\r\n      var invokerFunction = newFunc(Function, params)(...args);\r\n      var functionName = `methodCaller<(${types.map(t => t.name).join(', ')}) => ${retType.name}>`;\r\n      return emval_addMethodCaller(createNamedFunction(functionName, invokerFunction));\r\n    };\r\n\r\n  \r\n  \r\n  var __emval_run_destructors = (handle) => {\r\n      var destructors = Emval.toValue(handle);\r\n      runDestructors(destructors);\r\n      __emval_decref(handle);\r\n    };\r\n\r\n  var readEmAsmArgsArray = [];\r\n  var readEmAsmArgs = (sigPtr, buf) => {\r\n      // Nobody should have mutated _readEmAsmArgsArray underneath us to be something else than an array.\r\n      assert(Array.isArray(readEmAsmArgsArray));\r\n      // The input buffer is allocated on the stack, so it must be stack-aligned.\r\n      assert(buf % 16 == 0);\r\n      readEmAsmArgsArray.length = 0;\r\n      var ch;\r\n      // Most arguments are i32s, so shift the buffer pointer so it is a plain\r\n      // index into HEAP32.\r\n      while (ch = HEAPU8[sigPtr++]) {\r\n        var chr = String.fromCharCode(ch);\r\n        var validChars = ['d', 'f', 'i', 'p'];\r\n        assert(validChars.includes(chr), `Invalid character ${ch}(\"${chr}\") in readEmAsmArgs! Use only [${validChars}], and do not specify \"v\" for void return argument.`);\r\n        // Floats are always passed as doubles, so all types except for 'i'\r\n        // are 8 bytes and require alignment.\r\n        var wide = (ch != 105);\r\n        wide &= (ch != 112);\r\n        buf += wide && (buf % 8) ? 4 : 0;\r\n        readEmAsmArgsArray.push(\r\n          // Special case for pointers under wasm64 or CAN_ADDRESS_2GB mode.\r\n          ch == 112 ? HEAPU32[((buf)>>2)] :\r\n          ch == 105 ?\r\n            HEAP32[((buf)>>2)] :\r\n            HEAPF64[((buf)>>3)]\r\n        );\r\n        buf += wide ? 8 : 4;\r\n      }\r\n      return readEmAsmArgsArray;\r\n    };\r\n  var runEmAsmFunction = (code, sigPtr, argbuf) => {\r\n      var args = readEmAsmArgs(sigPtr, argbuf);\r\n      assert(ASM_CONSTS.hasOwnProperty(code), `No EM_ASM constant found at address ${code}.  The loaded WebAssembly file is likely out of sync with the generated JavaScript.`);\r\n      return ASM_CONSTS[code](...args);\r\n    };\r\n  var _emscripten_asm_const_int = (code, sigPtr, argbuf) => {\r\n      return runEmAsmFunction(code, sigPtr, argbuf);\r\n    };\r\n\r\n  var getHeapMax = () =>\r\n      HEAPU8.length;\r\n  \r\n  var alignMemory = (size, alignment) => {\r\n      assert(alignment, \"alignment argument is required\");\r\n      return Math.ceil(size / alignment) * alignment;\r\n    };\r\n  \r\n  var abortOnCannotGrowMemory = (requestedSize) => {\r\n      abort(`Cannot enlarge memory arrays to size ${requestedSize} bytes (OOM). Either (1) compile with -sINITIAL_MEMORY=X with X higher than the current value ${HEAP8.length}, (2) compile with -sALLOW_MEMORY_GROWTH which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with -sABORTING_MALLOC=0`);\r\n    };\r\n  var _emscripten_resize_heap = (requestedSize) => {\r\n      var oldSize = HEAPU8.length;\r\n      // With CAN_ADDRESS_2GB or MEMORY64, pointers are already unsigned.\r\n      requestedSize >>>= 0;\r\n      abortOnCannotGrowMemory(requestedSize);\r\n    };\r\n\r\n  var SYSCALLS = {\r\n  varargs:undefined,\r\n  getStr(ptr) {\r\n        var ret = UTF8ToString(ptr);\r\n        return ret;\r\n      },\r\n  };\r\n  var _fd_close = (fd) => {\r\n      abort('fd_close called without SYSCALLS_REQUIRE_FILESYSTEM');\r\n    };\r\n\r\n  var convertI32PairToI53Checked = (lo, hi) => {\r\n      assert(lo == (lo >>> 0) || lo == (lo|0)); // lo should either be a i32 or a u32\r\n      assert(hi === (hi|0));                    // hi should be a i32\r\n      return ((hi + 0x200000) >>> 0 < 0x400001 - !!lo) ? (lo >>> 0) + hi * 4294967296 : NaN;\r\n    };\r\n  function _fd_seek(fd,offset_low, offset_high,whence,newOffset) {\r\n    var offset = convertI32PairToI53Checked(offset_low, offset_high);\r\n  \r\n    \r\n      return 70;\r\n    ;\r\n  }\r\n\r\n  var printCharBuffers = [null,[],[]];\r\n  \r\n  var printChar = (stream, curr) => {\r\n      var buffer = printCharBuffers[stream];\r\n      assert(buffer);\r\n      if (curr === 0 || curr === 10) {\r\n        (stream === 1 ? out : err)(UTF8ArrayToString(buffer));\r\n        buffer.length = 0;\r\n      } else {\r\n        buffer.push(curr);\r\n      }\r\n    };\r\n  \r\n  var flush_NO_FILESYSTEM = () => {\r\n      // flush anything remaining in the buffers during shutdown\r\n      _fflush(0);\r\n      if (printCharBuffers[1].length) printChar(1, 10);\r\n      if (printCharBuffers[2].length) printChar(2, 10);\r\n    };\r\n  \r\n  \r\n  var _fd_write = (fd, iov, iovcnt, pnum) => {\r\n      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n      var num = 0;\r\n      for (var i = 0; i < iovcnt; i++) {\r\n        var ptr = HEAPU32[((iov)>>2)];\r\n        var len = HEAPU32[(((iov)+(4))>>2)];\r\n        iov += 8;\r\n        for (var j = 0; j < len; j++) {\r\n          printChar(fd, HEAPU8[ptr+j]);\r\n        }\r\n        num += len;\r\n      }\r\n      HEAPU32[((pnum)>>2)] = num;\r\n      return 0;\r\n    };\r\nembind_init_charCodes();\r\nBindingError = Module['BindingError'] = class BindingError extends Error { constructor(message) { super(message); this.name = 'BindingError'; }};\r\nInternalError = Module['InternalError'] = class InternalError extends Error { constructor(message) { super(message); this.name = 'InternalError'; }};\r\ninit_ClassHandle();\r\ninit_RegisteredPointer();\r\nUnboundTypeError = Module['UnboundTypeError'] = extendError(Error, 'UnboundTypeError');;\r\ninit_emval();;\r\nfunction checkIncomingModuleAPI() {\r\n  ignoredModuleProp('fetchSettings');\r\n}\r\nvar wasmImports = {\r\n  /** @export */\r\n  __assert_fail: ___assert_fail,\r\n  /** @export */\r\n  _abort_js: __abort_js,\r\n  /** @export */\r\n  _embind_register_bigint: __embind_register_bigint,\r\n  /** @export */\r\n  _embind_register_bool: __embind_register_bool,\r\n  /** @export */\r\n  _embind_register_class: __embind_register_class,\r\n  /** @export */\r\n  _embind_register_class_constructor: __embind_register_class_constructor,\r\n  /** @export */\r\n  _embind_register_class_function: __embind_register_class_function,\r\n  /** @export */\r\n  _embind_register_emval: __embind_register_emval,\r\n  /** @export */\r\n  _embind_register_float: __embind_register_float,\r\n  /** @export */\r\n  _embind_register_integer: __embind_register_integer,\r\n  /** @export */\r\n  _embind_register_memory_view: __embind_register_memory_view,\r\n  /** @export */\r\n  _embind_register_std_string: __embind_register_std_string,\r\n  /** @export */\r\n  _embind_register_std_wstring: __embind_register_std_wstring,\r\n  /** @export */\r\n  _embind_register_void: __embind_register_void,\r\n  /** @export */\r\n  _emscripten_memcpy_js: __emscripten_memcpy_js,\r\n  /** @export */\r\n  _emval_call: __emval_call,\r\n  /** @export */\r\n  _emval_decref: __emval_decref,\r\n  /** @export */\r\n  _emval_get_method_caller: __emval_get_method_caller,\r\n  /** @export */\r\n  _emval_run_destructors: __emval_run_destructors,\r\n  /** @export */\r\n  emscripten_asm_const_int: _emscripten_asm_const_int,\r\n  /** @export */\r\n  emscripten_resize_heap: _emscripten_resize_heap,\r\n  /** @export */\r\n  fd_close: _fd_close,\r\n  /** @export */\r\n  fd_seek: _fd_seek,\r\n  /** @export */\r\n  fd_write: _fd_write\r\n};\r\nvar wasmExports = createWasm();\r\nvar ___wasm_call_ctors = createExportWrapper('__wasm_call_ctors', 0);\r\nvar ___getTypeName = createExportWrapper('__getTypeName', 1);\r\nvar _fflush = createExportWrapper('fflush', 1);\r\nvar _malloc = createExportWrapper('malloc', 1);\r\nvar _strerror = createExportWrapper('strerror', 1);\r\nvar _free = createExportWrapper('free', 1);\r\nvar _emscripten_stack_init = () => (_emscripten_stack_init = wasmExports['emscripten_stack_init'])();\r\nvar _emscripten_stack_get_free = () => (_emscripten_stack_get_free = wasmExports['emscripten_stack_get_free'])();\r\nvar _emscripten_stack_get_base = () => (_emscripten_stack_get_base = wasmExports['emscripten_stack_get_base'])();\r\nvar _emscripten_stack_get_end = () => (_emscripten_stack_get_end = wasmExports['emscripten_stack_get_end'])();\r\nvar __emscripten_stack_restore = (a0) => (__emscripten_stack_restore = wasmExports['_emscripten_stack_restore'])(a0);\r\nvar __emscripten_stack_alloc = (a0) => (__emscripten_stack_alloc = wasmExports['_emscripten_stack_alloc'])(a0);\r\nvar _emscripten_stack_get_current = () => (_emscripten_stack_get_current = wasmExports['emscripten_stack_get_current'])();\r\nvar dynCall_jiji = Module['dynCall_jiji'] = createExportWrapper('dynCall_jiji', 5);\r\n\r\n\r\n// include: postamble.js\r\n// === Auto-generated postamble setup entry stuff ===\r\n\r\nvar missingLibrarySymbols = [\r\n  'writeI53ToI64',\r\n  'writeI53ToI64Clamped',\r\n  'writeI53ToI64Signaling',\r\n  'writeI53ToU64Clamped',\r\n  'writeI53ToU64Signaling',\r\n  'readI53FromI64',\r\n  'readI53FromU64',\r\n  'convertI32PairToI53',\r\n  'convertU32PairToI53',\r\n  'stackAlloc',\r\n  'getTempRet0',\r\n  'setTempRet0',\r\n  'zeroMemory',\r\n  'exitJS',\r\n  'growMemory',\r\n  'strError',\r\n  'inetPton4',\r\n  'inetNtop4',\r\n  'inetPton6',\r\n  'inetNtop6',\r\n  'readSockaddr',\r\n  'writeSockaddr',\r\n  'initRandomFill',\r\n  'randomFill',\r\n  'emscriptenLog',\r\n  'runMainThreadEmAsm',\r\n  'jstoi_q',\r\n  'getExecutableName',\r\n  'listenOnce',\r\n  'autoResumeAudioContext',\r\n  'handleException',\r\n  'keepRuntimeAlive',\r\n  'runtimeKeepalivePush',\r\n  'runtimeKeepalivePop',\r\n  'callUserCallback',\r\n  'maybeExit',\r\n  'asmjsMangle',\r\n  'asyncLoad',\r\n  'mmapAlloc',\r\n  'HandleAllocator',\r\n  'getNativeTypeSize',\r\n  'STACK_SIZE',\r\n  'STACK_ALIGN',\r\n  'POINTER_SIZE',\r\n  'ASSERTIONS',\r\n  'getCFunc',\r\n  'ccall',\r\n  'cwrap',\r\n  'uleb128Encode',\r\n  'sigToWasmTypes',\r\n  'generateFuncType',\r\n  'convertJsFunctionToWasm',\r\n  'getEmptyTableSlot',\r\n  'updateTableMap',\r\n  'getFunctionAddress',\r\n  'addFunction',\r\n  'removeFunction',\r\n  'reallyNegative',\r\n  'unSign',\r\n  'strLen',\r\n  'reSign',\r\n  'formatString',\r\n  'intArrayFromString',\r\n  'intArrayToString',\r\n  'AsciiToString',\r\n  'stringToAscii',\r\n  'stringToNewUTF8',\r\n  'stringToUTF8OnStack',\r\n  'writeArrayToMemory',\r\n  'registerKeyEventCallback',\r\n  'maybeCStringToJsString',\r\n  'findEventTarget',\r\n  'getBoundingClientRect',\r\n  'fillMouseEventData',\r\n  'registerMouseEventCallback',\r\n  'registerWheelEventCallback',\r\n  'registerUiEventCallback',\r\n  'registerFocusEventCallback',\r\n  'fillDeviceOrientationEventData',\r\n  'registerDeviceOrientationEventCallback',\r\n  'fillDeviceMotionEventData',\r\n  'registerDeviceMotionEventCallback',\r\n  'screenOrientation',\r\n  'fillOrientationChangeEventData',\r\n  'registerOrientationChangeEventCallback',\r\n  'fillFullscreenChangeEventData',\r\n  'registerFullscreenChangeEventCallback',\r\n  'JSEvents_requestFullscreen',\r\n  'JSEvents_resizeCanvasForFullscreen',\r\n  'registerRestoreOldStyle',\r\n  'hideEverythingExceptGivenElement',\r\n  'restoreHiddenElements',\r\n  'setLetterbox',\r\n  'softFullscreenResizeWebGLRenderTarget',\r\n  'doRequestFullscreen',\r\n  'fillPointerlockChangeEventData',\r\n  'registerPointerlockChangeEventCallback',\r\n  'registerPointerlockErrorEventCallback',\r\n  'requestPointerLock',\r\n  'fillVisibilityChangeEventData',\r\n  'registerVisibilityChangeEventCallback',\r\n  'registerTouchEventCallback',\r\n  'fillGamepadEventData',\r\n  'registerGamepadEventCallback',\r\n  'registerBeforeUnloadEventCallback',\r\n  'fillBatteryEventData',\r\n  'battery',\r\n  'registerBatteryEventCallback',\r\n  'setCanvasElementSize',\r\n  'getCanvasElementSize',\r\n  'jsStackTrace',\r\n  'getCallstack',\r\n  'convertPCtoSourceLocation',\r\n  'getEnvStrings',\r\n  'checkWasiClock',\r\n  'wasiRightsToMuslOFlags',\r\n  'wasiOFlagsToMuslOFlags',\r\n  'createDyncallWrapper',\r\n  'safeSetTimeout',\r\n  'setImmediateWrapped',\r\n  'clearImmediateWrapped',\r\n  'polyfillSetImmediate',\r\n  'registerPostMainLoop',\r\n  'registerPreMainLoop',\r\n  'getPromise',\r\n  'makePromise',\r\n  'idsToPromises',\r\n  'makePromiseCallback',\r\n  'ExceptionInfo',\r\n  'findMatchingCatch',\r\n  'Browser_asyncPrepareDataCounter',\r\n  'safeRequestAnimationFrame',\r\n  'isLeapYear',\r\n  'ydayFromDate',\r\n  'arraySum',\r\n  'addDays',\r\n  'getSocketFromFD',\r\n  'getSocketAddress',\r\n  'FS_createPreloadedFile',\r\n  'FS_modeStringToFlags',\r\n  'FS_getMode',\r\n  'FS_stdin_getChar',\r\n  'FS_unlink',\r\n  'FS_createDataFile',\r\n  'FS_mkdirTree',\r\n  '_setNetworkCallback',\r\n  'heapObjectForWebGLType',\r\n  'toTypedArrayIndex',\r\n  'webgl_enable_ANGLE_instanced_arrays',\r\n  'webgl_enable_OES_vertex_array_object',\r\n  'webgl_enable_WEBGL_draw_buffers',\r\n  'webgl_enable_WEBGL_multi_draw',\r\n  'webgl_enable_EXT_polygon_offset_clamp',\r\n  'webgl_enable_EXT_clip_control',\r\n  'webgl_enable_WEBGL_polygon_mode',\r\n  'emscriptenWebGLGet',\r\n  'computeUnpackAlignedImageSize',\r\n  'colorChannelsInGlTextureFormat',\r\n  'emscriptenWebGLGetTexPixelData',\r\n  'emscriptenWebGLGetUniform',\r\n  'webglGetUniformLocation',\r\n  'webglPrepareUniformLocationsBeforeFirstUse',\r\n  'webglGetLeftBracePos',\r\n  'emscriptenWebGLGetVertexAttrib',\r\n  '__glGetActiveAttribOrUniform',\r\n  'writeGLArray',\r\n  'registerWebGlEventCallback',\r\n  'runAndAbortIfError',\r\n  'ALLOC_NORMAL',\r\n  'ALLOC_STACK',\r\n  'allocate',\r\n  'writeStringToMemory',\r\n  'writeAsciiToMemory',\r\n  'setErrNo',\r\n  'demangle',\r\n  'stackTrace',\r\n  'getFunctionArgsName',\r\n  'createJsInvokerSignature',\r\n  'registerInheritedInstance',\r\n  'unregisterInheritedInstance',\r\n  'getInheritedInstanceCount',\r\n  'getLiveInheritedInstances',\r\n  'enumReadValueFromPointer',\r\n  'setDelayFunction',\r\n  'validateThis',\r\n  'getStringOrSymbol',\r\n  'emval_get_global',\r\n];\r\nmissingLibrarySymbols.forEach(missingLibrarySymbol)\r\n\r\nvar unexportedSymbols = [\r\n  'run',\r\n  'addOnPreRun',\r\n  'addOnInit',\r\n  'addOnPreMain',\r\n  'addOnExit',\r\n  'addOnPostRun',\r\n  'addRunDependency',\r\n  'removeRunDependency',\r\n  'out',\r\n  'err',\r\n  'callMain',\r\n  'abort',\r\n  'wasmMemory',\r\n  'wasmExports',\r\n  'writeStackCookie',\r\n  'checkStackCookie',\r\n  'convertI32PairToI53Checked',\r\n  'stackSave',\r\n  'stackRestore',\r\n  'ptrToString',\r\n  'getHeapMax',\r\n  'abortOnCannotGrowMemory',\r\n  'ENV',\r\n  'ERRNO_CODES',\r\n  'DNS',\r\n  'Protocols',\r\n  'Sockets',\r\n  'timers',\r\n  'warnOnce',\r\n  'readEmAsmArgsArray',\r\n  'readEmAsmArgs',\r\n  'runEmAsmFunction',\r\n  'jstoi_s',\r\n  'dynCallLegacy',\r\n  'getDynCaller',\r\n  'dynCall',\r\n  'alignMemory',\r\n  'wasmTable',\r\n  'noExitRuntime',\r\n  'freeTableIndexes',\r\n  'functionsInTableMap',\r\n  'setValue',\r\n  'getValue',\r\n  'PATH',\r\n  'PATH_FS',\r\n  'UTF8Decoder',\r\n  'UTF8ArrayToString',\r\n  'UTF8ToString',\r\n  'stringToUTF8Array',\r\n  'stringToUTF8',\r\n  'lengthBytesUTF8',\r\n  'UTF16Decoder',\r\n  'UTF16ToString',\r\n  'stringToUTF16',\r\n  'lengthBytesUTF16',\r\n  'UTF32ToString',\r\n  'stringToUTF32',\r\n  'lengthBytesUTF32',\r\n  'JSEvents',\r\n  'specialHTMLTargets',\r\n  'findCanvasEventTarget',\r\n  'currentFullscreenStrategy',\r\n  'restoreOldWindowedStyle',\r\n  'UNWIND_CACHE',\r\n  'ExitStatus',\r\n  'flush_NO_FILESYSTEM',\r\n  'promiseMap',\r\n  'uncaughtExceptionCount',\r\n  'exceptionLast',\r\n  'exceptionCaught',\r\n  'Browser',\r\n  'getPreloadedImageData__data',\r\n  'wget',\r\n  'MONTH_DAYS_REGULAR',\r\n  'MONTH_DAYS_LEAP',\r\n  'MONTH_DAYS_REGULAR_CUMULATIVE',\r\n  'MONTH_DAYS_LEAP_CUMULATIVE',\r\n  'SYSCALLS',\r\n  'preloadPlugins',\r\n  'FS_stdin_getChar_buffer',\r\n  'FS_createPath',\r\n  'FS_createDevice',\r\n  'FS_readFile',\r\n  'FS',\r\n  'FS_createLazyFile',\r\n  'MEMFS',\r\n  'TTY',\r\n  'PIPEFS',\r\n  'SOCKFS',\r\n  'tempFixedLengthArray',\r\n  'miniTempWebGLFloatBuffers',\r\n  'miniTempWebGLIntBuffers',\r\n  'GL',\r\n  'AL',\r\n  'GLUT',\r\n  'EGL',\r\n  'GLEW',\r\n  'IDBStore',\r\n  'SDL',\r\n  'SDL_gfx',\r\n  'allocateUTF8',\r\n  'allocateUTF8OnStack',\r\n  'print',\r\n  'printErr',\r\n  'InternalError',\r\n  'BindingError',\r\n  'throwInternalError',\r\n  'throwBindingError',\r\n  'registeredTypes',\r\n  'awaitingDependencies',\r\n  'typeDependencies',\r\n  'tupleRegistrations',\r\n  'structRegistrations',\r\n  'sharedRegisterType',\r\n  'whenDependentTypesAreResolved',\r\n  'embind_charCodes',\r\n  'embind_init_charCodes',\r\n  'readLatin1String',\r\n  'getTypeName',\r\n  'getFunctionName',\r\n  'heap32VectorToArray',\r\n  'requireRegisteredType',\r\n  'usesDestructorStack',\r\n  'checkArgCount',\r\n  'getRequiredArgCount',\r\n  'createJsInvoker',\r\n  'UnboundTypeError',\r\n  'PureVirtualError',\r\n  'GenericWireTypeSize',\r\n  'EmValType',\r\n  'EmValOptionalType',\r\n  'throwUnboundTypeError',\r\n  'ensureOverloadTable',\r\n  'exposePublicSymbol',\r\n  'replacePublicSymbol',\r\n  'extendError',\r\n  'createNamedFunction',\r\n  'embindRepr',\r\n  'registeredInstances',\r\n  'getBasestPointer',\r\n  'getInheritedInstance',\r\n  'registeredPointers',\r\n  'registerType',\r\n  'integerReadValueFromPointer',\r\n  'floatReadValueFromPointer',\r\n  'readPointer',\r\n  'runDestructors',\r\n  'newFunc',\r\n  'craftInvokerFunction',\r\n  'embind__requireFunction',\r\n  'genericPointerToWireType',\r\n  'constNoSmartPtrRawPointerToWireType',\r\n  'nonConstNoSmartPtrRawPointerToWireType',\r\n  'init_RegisteredPointer',\r\n  'RegisteredPointer',\r\n  'RegisteredPointer_fromWireType',\r\n  'runDestructor',\r\n  'releaseClassHandle',\r\n  'finalizationRegistry',\r\n  'detachFinalizer_deps',\r\n  'detachFinalizer',\r\n  'attachFinalizer',\r\n  'makeClassHandle',\r\n  'init_ClassHandle',\r\n  'ClassHandle',\r\n  'throwInstanceAlreadyDeleted',\r\n  'deletionQueue',\r\n  'flushPendingDeletes',\r\n  'delayFunction',\r\n  'RegisteredClass',\r\n  'shallowCopyInternalPointer',\r\n  'downcastPointer',\r\n  'upcastPointer',\r\n  'char_0',\r\n  'char_9',\r\n  'makeLegalFunctionName',\r\n  'emval_freelist',\r\n  'emval_handles',\r\n  'emval_symbols',\r\n  'init_emval',\r\n  'count_emval_handles',\r\n  'Emval',\r\n  'emval_returnValue',\r\n  'emval_lookupTypes',\r\n  'emval_methodCallers',\r\n  'emval_addMethodCaller',\r\n  'reflectConstruct',\r\n];\r\nunexportedSymbols.forEach(unexportedRuntimeSymbol);\r\n\r\n\r\n\r\nvar calledRun;\r\nvar calledPrerun;\r\n\r\ndependenciesFulfilled = function runCaller() {\r\n  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)\r\n  if (!calledRun) run();\r\n  if (!calledRun) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled\r\n};\r\n\r\nfunction stackCheckInit() {\r\n  // This is normally called automatically during __wasm_call_ctors but need to\r\n  // get these values before even running any of the ctors so we call it redundantly\r\n  // here.\r\n  _emscripten_stack_init();\r\n  // TODO(sbc): Move writeStackCookie to native to to avoid this.\r\n  writeStackCookie();\r\n}\r\n\r\nfunction run() {\r\n\r\n  if (runDependencies > 0) {\r\n    return;\r\n  }\r\n\r\n    stackCheckInit();\r\n\r\n  if (!calledPrerun) {\r\n    calledPrerun = 1;\r\n    preRun();\r\n\r\n    // a preRun added a dependency, run will be called later\r\n    if (runDependencies > 0) {\r\n      return;\r\n    }\r\n  }\r\n\r\n  function doRun() {\r\n    // run may have just been called through dependencies being fulfilled just in this very frame,\r\n    // or while the async setStatus time below was happening\r\n    if (calledRun) return;\r\n    calledRun = 1;\r\n    Module['calledRun'] = 1;\r\n\r\n    if (ABORT) return;\r\n\r\n    initRuntime();\r\n\r\n    readyPromiseResolve(Module);\r\n    Module['onRuntimeInitialized']?.();\r\n\r\n    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module[\"onRuntimeInitialized\"]');\r\n\r\n    postRun();\r\n  }\r\n\r\n  if (Module['setStatus']) {\r\n    Module['setStatus']('Running...');\r\n    setTimeout(() => {\r\n      setTimeout(() => Module['setStatus'](''), 1);\r\n      doRun();\r\n    }, 1);\r\n  } else\r\n  {\r\n    doRun();\r\n  }\r\n  checkStackCookie();\r\n}\r\n\r\nfunction checkUnflushedContent() {\r\n  // Compiler settings do not allow exiting the runtime, so flushing\r\n  // the streams is not possible. but in ASSERTIONS mode we check\r\n  // if there was something to flush, and if so tell the user they\r\n  // should request that the runtime be exitable.\r\n  // Normally we would not even include flush() at all, but in ASSERTIONS\r\n  // builds we do so just for this check, and here we see if there is any\r\n  // content to flush, that is, we check if there would have been\r\n  // something a non-ASSERTIONS build would have not seen.\r\n  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0\r\n  // mode (which has its own special function for this; otherwise, all\r\n  // the code is inside libc)\r\n  var oldOut = out;\r\n  var oldErr = err;\r\n  var has = false;\r\n  out = err = (x) => {\r\n    has = true;\r\n  }\r\n  try { // it doesn't matter if it fails\r\n    flush_NO_FILESYSTEM();\r\n  } catch(e) {}\r\n  out = oldOut;\r\n  err = oldErr;\r\n  if (has) {\r\n    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the Emscripten FAQ), or make sure to emit a newline when you printf etc.');\r\n    warnOnce('(this may also be due to not including full filesystem support - try building with -sFORCE_FILESYSTEM)');\r\n  }\r\n}\r\n\r\nif (Module['preInit']) {\r\n  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];\r\n  while (Module['preInit'].length > 0) {\r\n    Module['preInit'].pop()();\r\n  }\r\n}\r\n\r\nrun();\r\n\r\n// end include: postamble.js\r\n\r\n// include: F:\\project\\WebAssembly\\demo\\compile\\js\\utils.js\r\nconst safelyParse = (str) => {\r\n  return str\r\n}\r\nModule[\"safelyParse\"] = safelyParse\r\n// end include: F:\\project\\WebAssembly\\demo\\compile\\js\\utils.js\r\n\r\n// include: postamble_modularize.js\r\n// In MODULARIZE mode we wrap the generated code in a factory function\r\n// and return either the Module itself, or a promise of the module.\r\n//\r\n// We assign to the `moduleRtn` global here and configure closure to see\r\n// this as and extern so it won't get minified.\r\n\r\nmoduleRtn = readyPromise;\r\n\r\n// Assertion for attempting to access module properties on the incoming\r\n// moduleArg.  In the past we used this object as the prototype of the module\r\n// and assigned properties to it, but now we return a distinct object.  This\r\n// keeps the instance private until it is ready (i.e the promise has been\r\n// resolved).\r\nfor (const prop of Object.keys(Module)) {\r\n  if (!(prop in moduleArg)) {\r\n    Object.defineProperty(moduleArg, prop, {\r\n      configurable: true,\r\n      get() {\r\n        abort(`Access to module property ('${prop}') is no longer possible via the module constructor argument; Instead, use the result of the module constructor.`)\r\n      }\r\n    });\r\n  }\r\n}\r\n// end include: postamble_modularize.js\r\n\r\n\r\n\r\n  return moduleRtn;\r\n}\r\n);\r\n})();\r\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (Module);\r\n\n\n//# sourceURL=webpack:///./communication.wasm.js?");

/***/ }),

/***/ "./main.js":
/*!*****************!*\
  !*** ./main.js ***!
  \*****************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _communication_wasm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./communication.wasm.js */ \"./communication.wasm.js\");\n\r\n// console.log(Module.safelyParse(\"{name: 'icebergfeng'}\"), \"Module0000000\")\r\n\r\n// Wasm模块加载并初始化完成后被调用的回调函数\r\n_communication_wasm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].onRuntimeInitialized = (_) => {\r\n  const communicateModule = new _communication_wasm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].Communication()\r\n  // 调用 C++ 层的函数\r\n  communicateModule.executeCb()\r\n\r\n  // js 层的函数在 C++ 层被调用\r\n  communicateModule.monitorCb(() => {\r\n    console.log(\"这是 js 层的函数在 C++ 层被调用\")\r\n  }, true)\r\n\r\n  // 编译 C++ 代码时在末尾插入的额外的 js 代码\r\n  const result = _communication_wasm_js__WEBPACK_IMPORTED_MODULE_0__[\"default\"].safelyParse(\"{name: 'icebergfeng'}\")\r\n  console.log(result)\r\n}\r\n\n\n//# sourceURL=webpack:///./main.js?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		__webpack_require__.b = document.baseURI || self.location.href;
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			"main": 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		// no on chunks loaded
/******/ 		
/******/ 		// no jsonp function
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module can't be inlined because the eval devtool is used.
/******/ 	var __webpack_exports__ = __webpack_require__("./main.js");
/******/ 	
/******/ })()
;